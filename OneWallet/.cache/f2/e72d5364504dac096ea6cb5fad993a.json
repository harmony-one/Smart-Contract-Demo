{"id":"../node_modules/@harmony-js/contract/dist/abi/abiCoder.js","dependencies":[{"name":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/contract/dist/abi/abiCoder.js.map","includedInParent":true,"mtime":499162500000},{"name":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/contract/src/abi/abiCoder.ts","includedInParent":true,"mtime":499162500000},{"name":"/home/rachit/Projects/demo/web/package.json","includedInParent":true,"mtime":1605273881149},{"name":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/contract/package.json","includedInParent":true,"mtime":1605275414276},{"name":"tslib","loc":{"line":115,"column":22},"parent":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/contract/dist/abi/abiCoder.js","resolved":"/home/rachit/Projects/demo/node_modules/tslib/tslib.es6.js"},{"name":"@harmony-js/crypto","loc":{"line":120,"column":23},"parent":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/contract/dist/abi/abiCoder.js","resolved":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/crypto/dist/index.js"},{"name":"@harmony-js/utils","loc":{"line":121,"column":22},"parent":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/contract/dist/abi/abiCoder.js","resolved":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/utils/dist/index.js"}],"generated":{"js":"\"use strict\";\n/**\n * ## About this package\n *\n * `@harmony-js/contract` makes it easy to interact with smart contract on the Harmony Blockchain. This allows you to interact with smart contracts as if they were JavaScript objects.\n *\n * ## How to use this package\n *\n * ### Deploy a contract to blockchain\n * ```javascript\n * // Step 1: Use Solidity to build a sample contract instance\n * contract Inbox {\n *   string public message;\n *   constructor() public {\n *     message = \"hello\";\n *   }\n *   function setMessage(string memory newMessage) public {\n *     message = newMessage;\n *   }\n * }\n *\n * // Step 2: Use truffle to compile the contract\n * $ truffle compile\n *\n * // Step 3: Use truffle to deploy the contract (by truffle)\n * $ truffle migrate --network local --reset\n * $ truffle migrate --network testnet --reset\n * ```\n * [Tutorial: using truffle to compile and deploy smart-contract](https://github.com/harmony-one/HRC/tree/master/examples/dapp_Lottery)\n *\n * ### Interact with the contract\n * ```javascript\n * // Step 1: create a harmony instance\n * const { Harmony } = require('@harmony-js/core');\n * const { ChainID, ChainType } = require('@harmony-js/utils');\n * const hmy = new Harmony(\n *   // let's assume we deploy smart contract to this end-point URL\n *   'https://api.s0.b.hmny.io'\n *   {\n *     chainType: ChainType.Harmony,\n *     chainId: ChainID.HmyLocal,\n *   }\n * )\n *\n * // Step 2: get a contract instance\n * const getContractInstance = (hmy, artifact) => {\n *   return hmy.contracts.createContract(artifact.abi, address);\n * }\n * const inbox = getContractInstance(hmy, inboxJson)\n *\n * // Step 3: interact with the instance\n * // Example 1: methods.myMethod.call()\n * const message = await inbox.methods.message().call();\n * console.log(message);\n *\n * // Example 2: methods.myMethod.send()\n * inbox.methods.setMessage('666').send({\n *   gasLimit: '1000001',\n *   gasPrice: new hmy.utils.Unit('10').asGwei().toWei(),\n * });\n * ```\n *\n * ### Integrate MathWallet\n * Using MathWallet to sign Transaction\n * ```javascript\n * // Step 0: set up MathWallet extension on Chrome\n *\n * // Step 1: Create a harmonyExtension instance\n * const { Harmony, HarmonyExtension } = require('@harmony-js/core');\n * let hmyEx, ExContract;\n * export const initExtension = async() => {\n *   hmyEx = await new HarmonyExtension(window.harmony);\n *\n *   exContract = hmyEx.contracts.createContract(abi, address);\n *   return exContract;\n * };\n *\n * // Step 2: interact with hmyEx instance\n * // wait for hmy inject into window\n * async componentDidMount() {\n *   ...\n *   await waitForInjected()\n *   ...\n * }\n * // Example: methods.myMethod.send()\n * onSubmit = async event => {\n *   const exContract = await initExtension()\n *   await exContract.methods.Mymethod().send({\n *     value: new hmy.utils.Unit('1').asOne().toWei(),\n *   })\n * }\n *\n * // wait for injected\n * export const waitForInjected = () => new Promise((resolve) => {\n *   const check = () => {\n *     if (!window.harmony) setTimeout(check, 250);\n *     else resolve(window.harmony);\n *   }\n *   check();\n * });\n * ```\n *\n * ## [More Examples: HRC repo](https://github.com/harmony-one/HRC/tree/master/examples)\n * - Lottery\n * - HRC 20\n * - HRC 721\n * - Node-dao\n * - Node-faucet\n *\n * @packageDocumentation\n * @module harmony-contract\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.defaultAbiCoder = exports.AbiCoder = exports.deepCopy = exports.shallowCopy = exports.isType = exports.parseBytes32String = exports.formatBytes32String = exports.toUtf8String = exports.toUtf8Bytes = exports.UnicodeNormalizationForm = exports.parseSignature = exports.formatSignature = exports.formatParamType = exports.parseParamType = exports.defaultCoerceFunc = void 0;\nvar tslib_1 = require(\"tslib\");\n// this file is mainly ported from `ethers.js`, but done some fixes\n// 1. added bytesPadRight support\n// 2. ts-lint\n// 3. use BN as default Bignumber instance\nvar crypto_1 = require(\"@harmony-js/crypto\");\nvar utils_1 = require(\"@harmony-js/utils\");\n/** @hidden */\nvar NegativeOne = new crypto_1.BN(-1);\n/** @hidden */\nvar One = new crypto_1.BN(1);\n/** @hidden */\nvar Zero = new crypto_1.BN(0);\n/** @hidden */\nvar HashZero = '0x0000000000000000000000000000000000000000000000000000000000000000';\n/** @hidden */\nvar MaxUint256 = utils_1.hexToBN('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\n///////////////////////////////\n/** @hidden */\nvar paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\n/** @hidden */\nvar paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\n/** @hidden */\nvar paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\n/** @hidden */\nexports.defaultCoerceFunc = function (type, value) {\n    var match = type.match(paramTypeNumber);\n    if (match && parseInt(match[2], 10) <= 48) {\n        // return value.toNumber();\n        return value.toString('hex');\n    }\n    return value;\n};\n///////////////////////////////////\n// Parsing for Solidity Signatures\n///////////////////////////////////\n// Parsing for Solidity Signatures\n/** @hidden */\nvar regexParen = new RegExp('^([^)(]*)\\\\((.*)\\\\)([^)(]*)$');\n/** @hidden */\nvar regexIdentifier = new RegExp('^[A-Za-z_][A-Za-z0-9_]*$');\n/** @hidden */\nfunction verifyType(type) {\n    // These need to be transformed to their full description\n    if (type.match(/^uint($|[^1-9])/)) {\n        type = 'uint256' + type.substring(4);\n    }\n    else if (type.match(/^int($|[^1-9])/)) {\n        type = 'int256' + type.substring(3);\n    }\n    return type;\n}\n/** @hidden */\nfunction parseParam(param, allowIndexed) {\n    var originalParam = param;\n    // tslint:disable-next-line: no-shadowed-variable\n    function throwError(i) {\n        throw new Error('unexpected character \"' +\n            originalParam[i] +\n            '\" at position ' +\n            i +\n            ' in \"' +\n            originalParam +\n            '\"');\n    }\n    param = param.replace(/\\s/g, ' ');\n    var parent = { type: '', name: '', state: { allowType: true } };\n    var node = parent;\n    for (var i = 0; i < param.length; i++) {\n        var c = param[i];\n        switch (c) {\n            case '(':\n                if (!node.state || !node.state.allowParams) {\n                    throwError(i);\n                }\n                if (node.state) {\n                    node.state.allowType = false;\n                }\n                if (node.type) {\n                    node.type = verifyType(node.type);\n                }\n                node.components = [{ type: '', name: '', parent: node, state: { allowType: true } }];\n                node = node.components[0];\n                break;\n            case ')':\n                delete node.state;\n                if (allowIndexed && node.name === 'indexed') {\n                    node.indexed = true;\n                    node.name = '';\n                }\n                if (node.type) {\n                    node.type = verifyType(node.type);\n                }\n                var child = node;\n                node = node.parent;\n                if (!node) {\n                    throwError(i);\n                }\n                delete child.parent;\n                if (node.state) {\n                    node.state.allowParams = false;\n                    node.state.allowName = true;\n                    node.state.allowArray = true;\n                }\n                break;\n            case ',':\n                delete node.state;\n                if (allowIndexed && node.name === 'indexed') {\n                    node.indexed = true;\n                    node.name = '';\n                }\n                if (node.type) {\n                    node.type = verifyType(node.type);\n                }\n                var sibling = {\n                    type: '',\n                    name: '',\n                    parent: node.parent,\n                    state: { allowType: true },\n                };\n                node.parent.components.push(sibling);\n                delete node.parent;\n                node = sibling;\n                break;\n            // Hit a space...\n            case ' ':\n                // If reading type, the type is done and may read a param or name\n                if (node.state) {\n                    if (node.state.allowType) {\n                        if (node.type !== '' && node.type) {\n                            node.type = verifyType(node.type);\n                            delete node.state.allowType;\n                            node.state.allowName = true;\n                            node.state.allowParams = true;\n                        }\n                    }\n                    // If reading name, the name is done\n                    if (node.state.allowName) {\n                        if (node.name !== '') {\n                            if (allowIndexed && node.name === 'indexed') {\n                                node.indexed = true;\n                                node.name = '';\n                            }\n                            else {\n                                node.state.allowName = false;\n                            }\n                        }\n                    }\n                }\n                break;\n            case '[':\n                if (!node.state || !node.state.allowArray) {\n                    throwError(i);\n                }\n                if (node.state) {\n                    node.type += c;\n                    node.state.allowArray = false;\n                    node.state.allowName = false;\n                    node.state.readArray = true;\n                }\n                break;\n            case ']':\n                if (!node.state || !node.state.readArray) {\n                    throwError(i);\n                }\n                if (node.state) {\n                    node.type += c;\n                    node.state.readArray = false;\n                    node.state.allowArray = true;\n                    node.state.allowName = true;\n                }\n                break;\n            default:\n                if (node.state) {\n                    if (node.state.allowType) {\n                        node.type += c;\n                        node.state.allowParams = true;\n                        node.state.allowArray = true;\n                    }\n                    else if (node.state.allowName) {\n                        node.name += c;\n                        delete node.state.allowArray;\n                    }\n                    else if (node.state.readArray) {\n                        node.type += c;\n                    }\n                    else {\n                        throwError(i);\n                    }\n                }\n        }\n    }\n    if (node.parent) {\n        throw new Error('unexpected eof');\n    }\n    delete parent.state;\n    if (allowIndexed && node.name === 'indexed') {\n        node.indexed = true;\n        node.name = '';\n    }\n    if (parent.type) {\n        parent.type = verifyType(parent.type);\n    }\n    return parent;\n}\n// @TODO: Better return type\n/** @hidden */\nfunction parseSignatureEvent(fragment) {\n    var abi = {\n        anonymous: false,\n        inputs: [],\n        name: '',\n        type: 'event',\n    };\n    var match = fragment.match(regexParen);\n    if (!match) {\n        throw new Error('invalid event: ' + fragment);\n    }\n    abi.name = match[1].trim();\n    splitNesting(match[2]).forEach(function (param) {\n        param = parseParam(param, true);\n        param.indexed = !!param.indexed;\n        abi.inputs.push(param);\n    });\n    match[3].split(' ').forEach(function (modifier) {\n        switch (modifier) {\n            case 'anonymous':\n                abi.anonymous = true;\n                break;\n            case '':\n                break;\n            default:\n                crypto_1.info('unknown modifier: ' + modifier);\n        }\n    });\n    if (abi.name && !abi.name.match(regexIdentifier)) {\n        throw new Error('invalid identifier: \"' + abi.name + '\"');\n    }\n    return abi;\n}\n/** @hidden */\nfunction parseParamType(type) {\n    return parseParam(type, true);\n}\nexports.parseParamType = parseParamType;\n// @TODO: Allow a second boolean to expose names\n/** @hidden */\nfunction formatParamType(paramType) {\n    return getParamCoder(exports.defaultCoerceFunc, paramType).type;\n}\nexports.formatParamType = formatParamType;\n/** @hidden */\nfunction parseSignatureFunction(fragment) {\n    var abi = {\n        constant: false,\n        gas: null,\n        inputs: [],\n        name: '',\n        outputs: [],\n        payable: false,\n        stateMutability: null,\n        type: 'function',\n    };\n    var comps = fragment.split('@');\n    if (comps.length !== 1) {\n        if (comps.length > 2) {\n            throw new Error('invalid signature');\n        }\n        if (!comps[1].match(/^[0-9]+$/)) {\n            throw new Error('invalid signature gas');\n        }\n        abi.gas = new crypto_1.BN(comps[1]);\n        fragment = comps[0];\n    }\n    comps = fragment.split(' returns ');\n    var left = comps[0].match(regexParen);\n    if (!left) {\n        throw new Error('invalid signature');\n    }\n    abi.name = left[1].trim();\n    if (!abi.name.match(regexIdentifier)) {\n        throw new Error('invalid identifier: \"' + left[1] + '\"');\n    }\n    splitNesting(left[2]).forEach(function (param) {\n        abi.inputs.push(parseParam(param));\n    });\n    left[3].split(' ').forEach(function (modifier) {\n        switch (modifier) {\n            case 'constant':\n                abi.constant = true;\n                break;\n            case 'payable':\n                abi.payable = true;\n                abi.stateMutability = 'payable';\n                break;\n            case 'pure':\n                abi.constant = true;\n                abi.stateMutability = 'pure';\n                break;\n            case 'view':\n                abi.constant = true;\n                abi.stateMutability = 'view';\n                break;\n            case 'external':\n            case 'public':\n            case '':\n                break;\n            default:\n                crypto_1.info('unknown modifier: ' + modifier);\n        }\n    });\n    // We have outputs\n    if (comps.length > 1) {\n        var right = comps[1].match(regexParen);\n        if (right === null || right[1].trim() !== '' || right[3].trim() !== '') {\n            throw new Error('unexpected tokens');\n        }\n        splitNesting(right[2]).forEach(function (param) {\n            abi.outputs.push(parseParam(param));\n        });\n    }\n    if (abi.name === 'constructor') {\n        abi.type = 'constructor';\n        if (abi.outputs.length) {\n            throw new Error('constructor may not have outputs');\n        }\n        delete abi.name;\n        delete abi.outputs;\n    }\n    return abi;\n}\n// @TODO: Allow a second boolean to expose names and modifiers\n/** @hidden */\nfunction formatSignature(fragment) {\n    return fragment.name + '(' + fragment.inputs.map(function (i) { return formatParamType(i); }).join(',') + ')';\n}\nexports.formatSignature = formatSignature;\n/** @hidden */\nfunction parseSignature(fragment) {\n    if (typeof fragment === 'string') {\n        // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n        fragment = fragment.replace(/\\s/g, ' ');\n        fragment = fragment\n            .replace(/\\(/g, ' (')\n            .replace(/\\)/g, ') ')\n            .replace(/\\s+/g, ' ');\n        fragment = fragment.trim();\n        if (fragment.substring(0, 6) === 'event ') {\n            return parseSignatureEvent(fragment.substring(6).trim());\n        }\n        else {\n            if (fragment.substring(0, 9) === 'function ') {\n                fragment = fragment.substring(9);\n            }\n            return parseSignatureFunction(fragment.trim());\n        }\n    }\n    throw new Error('unknown signature');\n}\nexports.parseSignature = parseSignature;\n/** @hidden */\nvar Coder = /** @class */ (function () {\n    function Coder(coerceFunc, name, type, localName, dynamic) {\n        this.coerceFunc = coerceFunc;\n        this.name = name;\n        this.type = type;\n        this.localName = localName;\n        this.dynamic = dynamic;\n    }\n    return Coder;\n}());\n// Clones the functionality of an existing Coder, but without a localName\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nvar CoderAnonymous = /** @class */ (function (_super) {\n    tslib_1.__extends(CoderAnonymous, _super);\n    function CoderAnonymous(coder) {\n        var _this = _super.call(this, coder.coerceFunc, coder.name, coder.type, undefined, coder.dynamic) || this;\n        _this.coder = coder;\n        return _this;\n    }\n    CoderAnonymous.prototype.encode = function (value) {\n        return this.coder.encode(value);\n    };\n    CoderAnonymous.prototype.decode = function (data, offset) {\n        return this.coder.decode(data, offset);\n    };\n    return CoderAnonymous;\n}(Coder));\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nvar CoderNull = /** @class */ (function (_super) {\n    tslib_1.__extends(CoderNull, _super);\n    function CoderNull(coerceFunc, localName) {\n        return _super.call(this, coerceFunc, 'null', '', localName, false) || this;\n    }\n    CoderNull.prototype.encode = function (value) {\n        var result = crypto_1.arrayify([]) || new Uint8Array();\n        return result;\n    };\n    CoderNull.prototype.decode = function (data, offset) {\n        if (offset > data.length) {\n            throw new Error('invalid null');\n        }\n        return {\n            consumed: 0,\n            value: this.coerceFunc('null', undefined),\n        };\n    };\n    return CoderNull;\n}(Coder));\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nvar CoderNumber = /** @class */ (function (_super) {\n    tslib_1.__extends(CoderNumber, _super);\n    function CoderNumber(coerceFunc, size, signed, localName) {\n        var _this = this;\n        var name = (signed ? 'int' : 'uint') + size * 8;\n        _this = _super.call(this, coerceFunc, name, name, localName, false) || this;\n        _this.size = size;\n        _this.signed = signed;\n        return _this;\n    }\n    CoderNumber.prototype.encode = function (value) {\n        var result;\n        try {\n            var v = new crypto_1.BN(value);\n            if (this.signed) {\n                var bounds = MaxUint256.maskn(this.size * 8 - 1);\n                if (v.gt(bounds)) {\n                    throw new Error('out-of-bounds');\n                }\n                bounds = bounds.add(One).mul(NegativeOne);\n                if (v.lt(bounds)) {\n                    throw new Error('out-of-bounds');\n                }\n            }\n            else if (v.lt(Zero) || v.gt(MaxUint256.maskn(this.size * 8))) {\n                throw new Error('out-of-bounds');\n            }\n            v = v.toTwos(this.size * 8).maskn(this.size * 8);\n            if (this.signed) {\n                v = v.fromTwos(this.size * 8).toTwos(256);\n            }\n            var vString = v.toString('hex');\n            result = crypto_1.padZeros(crypto_1.arrayify(\"0x\" + vString) || new Uint8Array(), 32);\n        }\n        catch (error) {\n            crypto_1.throwError('invalid number value', crypto_1.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: this.name,\n                value: value,\n            });\n        }\n        return result || crypto_1.padZeros(new Uint8Array(), 32);\n    };\n    CoderNumber.prototype.decode = function (data, offset) {\n        if (data.length < offset + 32) {\n            crypto_1.throwError('insufficient data for ' + this.name + ' type', crypto_1.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: this.name,\n                value: crypto_1.hexlify(data.slice(offset, offset + 32)),\n            });\n        }\n        var junkLength = 32 - this.size;\n        var dataValue = crypto_1.hexlify(data.slice(offset + junkLength, offset + 32));\n        var value = utils_1.hexToBN(dataValue);\n        // tslint:disable-next-line: prefer-conditional-expression\n        if (this.signed) {\n            value = value.fromTwos(this.size * 8);\n        }\n        else {\n            value = value.maskn(this.size * 8);\n        }\n        return {\n            consumed: 32,\n            value: this.coerceFunc(this.name, value),\n        };\n    };\n    return CoderNumber;\n}(Coder));\n/** @hidden */\nvar uint256Coder = new CoderNumber(function (type, value) {\n    return value;\n}, 32, false, 'none');\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nvar CoderBoolean = /** @class */ (function (_super) {\n    tslib_1.__extends(CoderBoolean, _super);\n    function CoderBoolean(coerceFunc, localName) {\n        return _super.call(this, coerceFunc, 'bool', 'bool', localName, false) || this;\n    }\n    CoderBoolean.prototype.encode = function (value) {\n        return uint256Coder.encode(!!value ? new crypto_1.BN(1) : new crypto_1.BN(0));\n    };\n    CoderBoolean.prototype.decode = function (data, offset) {\n        var result;\n        try {\n            result = uint256Coder.decode(data, offset);\n        }\n        catch (error) {\n            if (error.reason === 'insufficient data for uint256 type') {\n                crypto_1.throwError('insufficient data for boolean type', crypto_1.INVALID_ARGUMENT, {\n                    arg: this.localName,\n                    coderType: 'boolean',\n                    value: error.value,\n                });\n            }\n            throw error;\n        }\n        return {\n            consumed: result.consumed,\n            value: this.coerceFunc('bool', !result.value.isZero()),\n        };\n    };\n    return CoderBoolean;\n}(Coder));\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nvar CoderFixedBytes = /** @class */ (function (_super) {\n    tslib_1.__extends(CoderFixedBytes, _super);\n    function CoderFixedBytes(coerceFunc, length, localName) {\n        var _this = this;\n        var name = 'bytes' + length;\n        _this = _super.call(this, coerceFunc, name, name, localName, false) || this;\n        _this.length = length;\n        return _this;\n    }\n    CoderFixedBytes.prototype.encode = function (value) {\n        var result = new Uint8Array(this.length);\n        try {\n            var arrayied = crypto_1.arrayify(value);\n            var data = null;\n            if (arrayied !== null) {\n                var valueToByte = crypto_1.hexlify(arrayied);\n                data = crypto_1.arrayify(crypto_1.bytesPadRight(valueToByte, this.length));\n            }\n            else {\n                throw new Error('cannot arraify data');\n            }\n            if (data === null || data.length !== this.length) {\n                throw new Error('incorrect data length');\n            }\n            result.set(data);\n        }\n        catch (error) {\n            crypto_1.throwError('invalid ' + this.name + ' value', crypto_1.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: this.name,\n                value: error.value || value,\n            });\n        }\n        return result;\n    };\n    CoderFixedBytes.prototype.decode = function (data, offset) {\n        if (data.length < offset + 32) {\n            crypto_1.throwError('insufficient data for ' + name + ' type', crypto_1.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: this.name,\n                value: crypto_1.hexlify(data.slice(offset, offset + 32)),\n            });\n        }\n        return {\n            consumed: 32,\n            value: this.coerceFunc(this.name, crypto_1.hexlify(data.slice(offset, offset + this.length))),\n        };\n    };\n    return CoderFixedBytes;\n}(Coder));\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nvar CoderAddress = /** @class */ (function (_super) {\n    tslib_1.__extends(CoderAddress, _super);\n    function CoderAddress(coerceFunc, localName) {\n        return _super.call(this, coerceFunc, 'address', 'address', localName, false) || this;\n    }\n    CoderAddress.prototype.encode = function (value) {\n        var result = new Uint8Array(32);\n        try {\n            var addr = crypto_1.arrayify(crypto_1.toChecksumAddress(value)) || new Uint8Array();\n            result.set(addr, 12);\n        }\n        catch (error) {\n            crypto_1.throwError('invalid address', crypto_1.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: 'address',\n                value: value,\n            });\n        }\n        return result;\n    };\n    CoderAddress.prototype.decode = function (data, offset) {\n        if (data.length < offset + 32) {\n            crypto_1.throwError('insufficuent data for address type', crypto_1.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: 'address',\n                value: crypto_1.hexlify(data.slice(offset, offset + 32)),\n            });\n        }\n        return {\n            consumed: 32,\n            value: this.coerceFunc('address', crypto_1.toChecksumAddress(crypto_1.hexlify(data.slice(offset + 12, offset + 32)))),\n        };\n    };\n    return CoderAddress;\n}(Coder));\n/** @hidden */\nfunction _encodeDynamicBytes(value) {\n    var dataLength = 32 * Math.ceil(value.length / 32);\n    var padding = new Uint8Array(dataLength - value.length);\n    return crypto_1.concat([uint256Coder.encode(new crypto_1.BN(value.length)), value, padding]);\n}\n/** @hidden */\nfunction _decodeDynamicBytes(data, offset, localName) {\n    if (data.length < offset + 32) {\n        crypto_1.throwError('insufficient data for dynamicBytes length', crypto_1.INVALID_ARGUMENT, {\n            arg: localName,\n            coderType: 'dynamicBytes',\n            value: crypto_1.hexlify(data.slice(offset, offset + 32)),\n        });\n    }\n    var length = uint256Coder.decode(data, offset).value;\n    try {\n        length = length.toNumber();\n    }\n    catch (error) {\n        crypto_1.throwError('dynamic bytes count too large', crypto_1.INVALID_ARGUMENT, {\n            arg: localName,\n            coderType: 'dynamicBytes',\n            value: length.toString(),\n        });\n    }\n    if (data.length < offset + 32 + length) {\n        crypto_1.throwError('insufficient data for dynamicBytes type', crypto_1.INVALID_ARGUMENT, {\n            arg: localName,\n            coderType: 'dynamicBytes',\n            value: crypto_1.hexlify(data.slice(offset, offset + 32 + length)),\n        });\n    }\n    return {\n        consumed: 32 + 32 * Math.ceil(length / 32),\n        value: data.slice(offset + 32, offset + 32 + length),\n    };\n}\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nvar CoderDynamicBytes = /** @class */ (function (_super) {\n    tslib_1.__extends(CoderDynamicBytes, _super);\n    function CoderDynamicBytes(coerceFunc, localName) {\n        return _super.call(this, coerceFunc, 'bytes', 'bytes', localName, true) || this;\n    }\n    CoderDynamicBytes.prototype.encode = function (value) {\n        var result = new Uint8Array();\n        try {\n            result = _encodeDynamicBytes(crypto_1.arrayify(value) || new Uint8Array());\n        }\n        catch (error) {\n            crypto_1.throwError('invalid bytes value', crypto_1.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: 'bytes',\n                value: error.value,\n            });\n        }\n        return result;\n    };\n    CoderDynamicBytes.prototype.decode = function (data, offset) {\n        var result = _decodeDynamicBytes(data, offset, this.localName || '');\n        result.value = this.coerceFunc('bytes', crypto_1.hexlify(result.value));\n        return result;\n    };\n    return CoderDynamicBytes;\n}(Coder));\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nvar CoderString = /** @class */ (function (_super) {\n    tslib_1.__extends(CoderString, _super);\n    function CoderString(coerceFunc, localName) {\n        return _super.call(this, coerceFunc, 'string', 'string', localName, true) || this;\n    }\n    CoderString.prototype.encode = function (value) {\n        if (typeof value !== 'string') {\n            crypto_1.throwError('invalid string value', crypto_1.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: 'string',\n                value: value,\n            });\n        }\n        return _encodeDynamicBytes(toUtf8Bytes(value));\n    };\n    CoderString.prototype.decode = function (data, offset) {\n        var result = _decodeDynamicBytes(data, offset, this.localName || '');\n        result.value = this.coerceFunc('string', toUtf8String(result.value));\n        return result;\n    };\n    return CoderString;\n}(Coder));\n/** @hidden */\nfunction alignSize(size) {\n    return 32 * Math.ceil(size / 32);\n}\n/** @hidden */\nfunction pack(coders, values) {\n    if (Array.isArray(values)) {\n        // do nothing\n    }\n    else if (values && typeof values === 'object') {\n        var arrayValues_1 = [];\n        coders.forEach(function (coder) {\n            arrayValues_1.push(values[coder.localName || '']);\n        });\n        values = arrayValues_1;\n    }\n    else {\n        crypto_1.throwError('invalid tuple value', crypto_1.INVALID_ARGUMENT, {\n            coderType: 'tuple',\n            value: values,\n        });\n    }\n    if (coders.length !== values.length) {\n        crypto_1.throwError('types/value length mismatch', crypto_1.INVALID_ARGUMENT, {\n            coderType: 'tuple',\n            value: values,\n        });\n    }\n    var parts = [];\n    coders.forEach(function (coder, index) {\n        parts.push({ dynamic: coder.dynamic, value: coder.encode(values[index]) });\n    });\n    var staticSize = 0;\n    var dynamicSize = 0;\n    parts.forEach(function (part) {\n        if (part.dynamic) {\n            staticSize += 32;\n            dynamicSize += alignSize(part.value.length);\n        }\n        else {\n            staticSize += alignSize(part.value.length);\n            // todo : is it to be static size not alignSize?\n        }\n    });\n    var offset = 0;\n    var dynamicOffset = staticSize;\n    var data = new Uint8Array(staticSize + dynamicSize);\n    parts.forEach(function (part) {\n        if (part.dynamic) {\n            // uint256Coder.encode(dynamicOffset).copy(data, offset);\n            data.set(uint256Coder.encode(new crypto_1.BN(dynamicOffset)), offset);\n            offset += 32;\n            // part.value.copy(data, dynamicOffset);  @TODO\n            data.set(part.value, dynamicOffset);\n            dynamicOffset += alignSize(part.value.length);\n        }\n        else {\n            // part.value.copy(data, offset);  @TODO\n            data.set(part.value, offset);\n            offset += alignSize(part.value.length);\n        }\n    });\n    return data;\n}\n/** @hidden */\nfunction unpack(coders, data, offset) {\n    var baseOffset = offset;\n    var consumed = 0;\n    var value = [];\n    coders.forEach(function (coder) {\n        var result;\n        if (coder.dynamic) {\n            var dynamicOffset = uint256Coder.decode(data, offset);\n            result = coder.decode(data, baseOffset + dynamicOffset.value.toNumber());\n            // The dynamic part is leap-frogged somewhere else; doesn't count towards size\n            result.consumed = dynamicOffset.consumed;\n        }\n        else {\n            result = coder.decode(data, offset);\n        }\n        if (result.value !== undefined) {\n            value.push(result.value);\n        }\n        offset += result.consumed;\n        consumed += result.consumed;\n    });\n    coders.forEach(function (coder, index) {\n        var name = coder.localName;\n        if (!name) {\n            return;\n        }\n        if (name === 'length') {\n            name = '_length';\n        }\n        if (value[name] != null) {\n            return;\n        }\n        value[name] = value[index];\n    });\n    return {\n        value: value,\n        consumed: consumed,\n    };\n}\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nvar CoderArray = /** @class */ (function (_super) {\n    tslib_1.__extends(CoderArray, _super);\n    function CoderArray(coerceFunc, coder, length, localName) {\n        var _this = this;\n        var type = coder.type + '[' + (length >= 0 ? length : '') + ']';\n        var dynamic = length === -1 || coder.dynamic;\n        _this = _super.call(this, coerceFunc, 'array', type, localName, dynamic) || this;\n        _this.coder = coder;\n        _this.length = length;\n        return _this;\n    }\n    CoderArray.prototype.encode = function (value) {\n        if (!Array.isArray(value)) {\n            crypto_1.throwError('expected array value', crypto_1.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: 'array',\n                value: value,\n            });\n        }\n        var count = this.length;\n        var result = new Uint8Array(0);\n        if (count === -1) {\n            count = value.length;\n            result = uint256Coder.encode(new crypto_1.BN(count));\n        }\n        crypto_1.checkArgumentCount(count, value.length, ' in coder array' + (this.localName ? ' ' + this.localName : ''));\n        var coders = [];\n        // tslint:disable-next-line: prefer-for-of\n        for (var i = 0; i < value.length; i++) {\n            coders.push(this.coder);\n        }\n        return crypto_1.concat([result, pack(coders, value)]);\n    };\n    CoderArray.prototype.decode = function (data, offset) {\n        // @TODO:\n        // if (data.length < offset + length * 32) { throw new Error('invalid array'); }\n        var consumed = 0;\n        var count = this.length;\n        var decodedLength = { consumed: 0, value: undefined };\n        if (count === -1) {\n            try {\n                decodedLength = uint256Coder.decode(data, offset);\n            }\n            catch (error) {\n                crypto_1.throwError('insufficient data for dynamic array length', crypto_1.INVALID_ARGUMENT, {\n                    arg: this.localName,\n                    coderType: 'array',\n                    value: error.value,\n                });\n            }\n            try {\n                count = decodedLength.value.toNumber();\n            }\n            catch (error) {\n                crypto_1.throwError('array count too large', crypto_1.INVALID_ARGUMENT, {\n                    arg: this.localName,\n                    coderType: 'array',\n                    value: decodedLength.value.toString(),\n                });\n            }\n            consumed += decodedLength.consumed;\n            offset += decodedLength.consumed;\n        }\n        var coders = [];\n        for (var i = 0; i < count; i++) {\n            coders.push(new CoderAnonymous(this.coder));\n        }\n        var result = unpack(coders, data, offset);\n        result.consumed += consumed;\n        result.value = this.coerceFunc(this.type, result.value);\n        return result;\n    };\n    return CoderArray;\n}(Coder));\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nvar CoderTuple = /** @class */ (function (_super) {\n    tslib_1.__extends(CoderTuple, _super);\n    function CoderTuple(coerceFunc, coders, localName) {\n        var _this = this;\n        var dynamic = false;\n        var types = [];\n        coders.forEach(function (coder) {\n            if (coder.dynamic) {\n                dynamic = true;\n            }\n            types.push(coder.type);\n        });\n        var type = 'tuple(' + types.join(',') + ')';\n        _this = _super.call(this, coerceFunc, 'tuple', type, localName, dynamic) || this;\n        _this.coders = coders;\n        return _this;\n    }\n    CoderTuple.prototype.encode = function (value) {\n        return pack(this.coders, value);\n    };\n    CoderTuple.prototype.decode = function (data, offset) {\n        var result = unpack(this.coders, data, offset);\n        result.value = this.coerceFunc(this.type, result.value);\n        return result;\n    };\n    return CoderTuple;\n}(Coder));\n/** @hidden */\nfunction splitNesting(value) {\n    value = value.trim();\n    var result = [];\n    var accum = '';\n    var depth = 0;\n    // tslint:disable-next-line: prefer-for-of\n    for (var offset = 0; offset < value.length; offset++) {\n        var c = value[offset];\n        if (c === ',' && depth === 0) {\n            result.push(accum);\n            accum = '';\n        }\n        else {\n            accum += c;\n            if (c === '(') {\n                depth++;\n            }\n            else if (c === ')') {\n                depth--;\n                if (depth === -1) {\n                    throw new Error('unbalanced parenthsis');\n                }\n            }\n        }\n    }\n    if (accum) {\n        result.push(accum);\n    }\n    return result;\n}\n// @TODO: Is there a way to return \"class\"?\n/** @hidden */\nvar paramTypeSimple = {\n    address: CoderAddress,\n    bool: CoderBoolean,\n    string: CoderString,\n    bytes: CoderDynamicBytes,\n};\n/** @hidden */\nfunction getTupleParamCoder(coerceFunc, components, localName) {\n    if (!components) {\n        components = [];\n    }\n    var coders = [];\n    components.forEach(function (component) {\n        coders.push(getParamCoder(coerceFunc, component));\n    });\n    return new CoderTuple(coerceFunc, coders, localName);\n}\n/** @hidden */\nfunction getParamCoder(coerceFunc, param) {\n    var coder = paramTypeSimple[param.type];\n    if (coder) {\n        return new coder(coerceFunc, param.name);\n    }\n    var matcher = param.type.match(paramTypeNumber);\n    if (matcher) {\n        var size = parseInt(matcher[2] || '256', 10);\n        if (size === 0 || size > 256 || size % 8 !== 0) {\n            crypto_1.throwError('invalid ' + matcher[1] + ' bit length', crypto_1.INVALID_ARGUMENT, {\n                arg: 'param',\n                value: param,\n            });\n        }\n        return new CoderNumber(coerceFunc, size / 8, matcher[1] === 'int', param.name || '');\n    }\n    var matcher2 = param.type.match(paramTypeBytes);\n    if (matcher2) {\n        var size = parseInt(matcher2[1], 10);\n        if (size === 0 || size > 32) {\n            crypto_1.throwError('invalid bytes length', crypto_1.INVALID_ARGUMENT, {\n                arg: 'param',\n                value: param,\n            });\n        }\n        return new CoderFixedBytes(coerceFunc, size, param.name || '');\n    }\n    var matcher3 = param.type.match(paramTypeArray);\n    if (matcher3) {\n        var size = parseInt(matcher3[2] || '-1', 10);\n        param = shallowCopy(param);\n        param.type = matcher3[1];\n        param = deepCopy(param);\n        return new CoderArray(coerceFunc, getParamCoder(coerceFunc, param), size, param.name || '');\n    }\n    if (param.type.substring(0, 5) === 'tuple') {\n        return getTupleParamCoder(coerceFunc, param.components || [], param.name || '');\n    }\n    if (param.type === '') {\n        return new CoderNull(coerceFunc, param.name || '');\n    }\n    crypto_1.throwError('invalid type', crypto_1.INVALID_ARGUMENT, {\n        arg: 'type',\n        value: param.type,\n    });\n}\n/** @hidden */\nvar UnicodeNormalizationForm;\n(function (UnicodeNormalizationForm) {\n    UnicodeNormalizationForm[\"current\"] = \"\";\n    UnicodeNormalizationForm[\"NFC\"] = \"NFC\";\n    UnicodeNormalizationForm[\"NFD\"] = \"NFD\";\n    UnicodeNormalizationForm[\"NFKC\"] = \"NFKC\";\n    UnicodeNormalizationForm[\"NFKD\"] = \"NFKD\";\n})(UnicodeNormalizationForm = exports.UnicodeNormalizationForm || (exports.UnicodeNormalizationForm = {}));\n/** @hidden */\nfunction toUtf8Bytes(str, form) {\n    if (form === void 0) { form = UnicodeNormalizationForm.current; }\n    if (form !== UnicodeNormalizationForm.current) {\n        crypto_1.checkNormalize();\n        str = str.normalize(form);\n    }\n    var result = [];\n    for (var i = 0; i < str.length; i++) {\n        var c = str.charCodeAt(i);\n        if (c < 0x80) {\n            result.push(c);\n        }\n        else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n        }\n        else if ((c & 0xfc00) === 0xd800) {\n            i++;\n            var c2 = str.charCodeAt(i);\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n                throw new Error('invalid utf-8 string');\n            }\n            // Surrogate Pair\n            c = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((c >> 18) | 0xf0);\n            result.push(((c >> 12) & 0x3f) | 0x80);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n        else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n    return crypto_1.arrayify(result) || new Uint8Array();\n}\nexports.toUtf8Bytes = toUtf8Bytes;\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\n/** @hidden */\nfunction toUtf8String(bytes, ignoreErrors) {\n    bytes = crypto_1.arrayify(bytes) || new Uint8Array();\n    var result = '';\n    var i = 0;\n    // Invalid bytes are ignored\n    while (i < bytes.length) {\n        var c = bytes[i++];\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result += String.fromCharCode(c);\n            continue;\n        }\n        // Multibyte; how many bytes left for this character?\n        var extraLength = null;\n        var overlongMask = null;\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n            // 1110 xxxx 10xx xxxx 10xx xxxx\n        }\n        else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n            // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        }\n        else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n        }\n        else {\n            if (!ignoreErrors) {\n                if ((c & 0xc0) === 0x80) {\n                    throw new Error('invalid utf8 byte sequence; unexpected continuation byte');\n                }\n                throw new Error('invalid utf8 byte sequence; invalid prefix');\n            }\n            continue;\n        }\n        // Do we have enough bytes in our data?\n        if (i + extraLength > bytes.length) {\n            if (!ignoreErrors) {\n                throw new Error('invalid utf8 byte sequence; too short');\n            }\n            // If there is an invalid unprocessed byte, skip continuation bytes\n            for (; i < bytes.length; i++) {\n                if (bytes[i] >> 6 !== 0x02) {\n                    break;\n                }\n            }\n            continue;\n        }\n        // Remove the length prefix from the char\n        var res = c & ((1 << (8 - extraLength - 1)) - 1);\n        for (var j = 0; j < extraLength; j++) {\n            var nextChar = bytes[i];\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) !== 0x80) {\n                res = null;\n                break;\n            }\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n        if (res === null) {\n            if (!ignoreErrors) {\n                throw new Error('invalid utf8 byte sequence; invalid continuation byte');\n            }\n            continue;\n        }\n        // Check for overlong seuences (more bytes than needed)\n        if (res <= overlongMask) {\n            if (!ignoreErrors) {\n                throw new Error('invalid utf8 byte sequence; overlong');\n            }\n            continue;\n        }\n        // Maximum code point\n        if (res > 0x10ffff) {\n            if (!ignoreErrors) {\n                throw new Error('invalid utf8 byte sequence; out-of-range');\n            }\n            continue;\n        }\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            if (!ignoreErrors) {\n                throw new Error('invalid utf8 byte sequence; utf-16 surrogate');\n            }\n            continue;\n        }\n        if (res <= 0xffff) {\n            result += String.fromCharCode(res);\n            continue;\n        }\n        res -= 0x10000;\n        result += String.fromCharCode(((res >> 10) & 0x3ff) + 0xd800, (res & 0x3ff) + 0xdc00);\n    }\n    return result;\n}\nexports.toUtf8String = toUtf8String;\n/** @hidden */\nfunction formatBytes32String(text) {\n    // Get the bytes\n    var bytes = toUtf8Bytes(text);\n    // Check we have room for null-termination\n    if (bytes.length > 31) {\n        throw new Error('bytes32 string must be less than 32 bytes');\n    }\n    // Zero-pad (implicitly null-terminates)\n    return crypto_1.hexlify(crypto_1.concat([bytes, HashZero]).slice(0, 32));\n}\nexports.formatBytes32String = formatBytes32String;\n/** @hidden */\nfunction parseBytes32String(bytes) {\n    var data = crypto_1.arrayify(bytes) || new Uint8Array();\n    // Must be 32 bytes with a null-termination\n    if (data.length !== 32) {\n        throw new Error('invalid bytes32 - not 32 bytes long');\n    }\n    if (data[31] !== 0) {\n        throw new Error('invalid bytes32 sdtring - no null terminator');\n    }\n    // Find the null termination\n    var length = 31;\n    while (data[length - 1] === 0) {\n        length--;\n    }\n    // Determine the string value\n    return toUtf8String(data.slice(0, length));\n}\nexports.parseBytes32String = parseBytes32String;\n/** @hidden */\nfunction isType(object, type) {\n    return object && object._ethersType === type;\n}\nexports.isType = isType;\n/** @hidden */\nfunction shallowCopy(object) {\n    var result = {};\n    // tslint:disable-next-line: forin\n    for (var key in object) {\n        result[key] = object[key];\n    }\n    return result;\n}\nexports.shallowCopy = shallowCopy;\n/** @hidden */\nvar opaque = {\n    boolean: true,\n    number: true,\n    string: true,\n};\n/** @hidden */\nfunction deepCopy(object, frozen) {\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof object]) {\n        return object;\n    }\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        var result = object.map(function (item) { return deepCopy(item, frozen); });\n        if (frozen) {\n            Object.freeze(result);\n        }\n        return result;\n    }\n    if (typeof object === 'object') {\n        // Some internal objects, which are already immutable\n        if (isType(object, 'BigNumber')) {\n            return object;\n        }\n        if (isType(object, 'Description')) {\n            return object;\n        }\n        if (isType(object, 'Indexed')) {\n            return object;\n        }\n        var result = {};\n        // tslint:disable-next-line: forin\n        for (var key in object) {\n            var value = object[key];\n            if (value === undefined) {\n                continue;\n            }\n            utils_1.defineReadOnly(result, key, deepCopy(value, frozen));\n        }\n        if (frozen) {\n            Object.freeze(result);\n        }\n        return result;\n    }\n    // The function type is also immutable, so safe to copy by assignment\n    if (typeof object === 'function') {\n        return object;\n    }\n    throw new Error('Cannot deepCopy ' + typeof object);\n}\nexports.deepCopy = deepCopy;\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nvar AbiCoder = /** @class */ (function () {\n    function AbiCoder(coerceFunc) {\n        crypto_1.checkNew(this, AbiCoder);\n        if (!coerceFunc) {\n            coerceFunc = exports.defaultCoerceFunc;\n        }\n        this.coerceFunc = coerceFunc;\n    }\n    AbiCoder.prototype.encode = function (types, values) {\n        var _this = this;\n        if (types.length !== values.length) {\n            crypto_1.throwError('types/values length mismatch', crypto_1.INVALID_ARGUMENT, {\n                count: { types: types.length, values: values.length },\n                value: { types: types, values: values },\n            });\n        }\n        var coders = [];\n        types.forEach(function (type) {\n            // Convert types to type objects\n            //   - \"uint foo\" => { type: \"uint\", name: \"foo\" }\n            //   - \"tuple(uint, uint)\" => { type: \"tuple\", components: [ { type: \"uint\" }, { type: \"uint\" }, ] }\n            var typeObject = null;\n            // tslint:disable-next-line: prefer-conditional-expression\n            if (typeof type === 'string') {\n                typeObject = parseParam(type);\n            }\n            else {\n                typeObject = type;\n            }\n            coders.push(getParamCoder(_this.coerceFunc, typeObject));\n        }, this);\n        var encodedArray = new CoderTuple(this.coerceFunc, coders, '_').encode(values);\n        return crypto_1.hexlify(encodedArray);\n    };\n    AbiCoder.prototype.decode = function (types, data) {\n        var _this = this;\n        var coders = [];\n        types.forEach(function (type) {\n            // See encode for details\n            var typeObject = null;\n            // tslint:disable-next-line: prefer-conditional-expression\n            if (typeof type === 'string') {\n                typeObject = parseParam(type);\n            }\n            else {\n                typeObject = deepCopy(type);\n            }\n            coders.push(getParamCoder(_this.coerceFunc, typeObject));\n        }, this);\n        var result = new CoderTuple(this.coerceFunc, coders, '_').decode(crypto_1.arrayify(data) || new Uint8Array(), 0).value;\n        return result;\n    };\n    return AbiCoder;\n}());\nexports.AbiCoder = AbiCoder;\n/** @hidden */\nexports.defaultAbiCoder = new AbiCoder();\n"},"sourceMaps":{"js":{"version":3,"file":"abiCoder.js","sourceRoot":"","sources":["../../src/abi/abiCoder.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * ## About this package\n *\n * `@harmony-js/contract` makes it easy to interact with smart contract on the Harmony Blockchain. This allows you to interact with smart contracts as if they were JavaScript objects.\n *\n * ## How to use this package\n *\n * ### Deploy a contract to blockchain\n * ```javascript\n * // Step 1: Use Solidity to build a sample contract instance\n * contract Inbox {\n *   string public message;\n *   constructor() public {\n *     message = \"hello\";\n *   }\n *   function setMessage(string memory newMessage) public {\n *     message = newMessage;\n *   }\n * }\n *\n * // Step 2: Use truffle to compile the contract\n * $ truffle compile\n *\n * // Step 3: Use truffle to deploy the contract (by truffle)\n * $ truffle migrate --network local --reset\n * $ truffle migrate --network testnet --reset\n * ```\n * [Tutorial: using truffle to compile and deploy smart-contract](https://github.com/harmony-one/HRC/tree/master/examples/dapp_Lottery)\n *\n * ### Interact with the contract\n * ```javascript\n * // Step 1: create a harmony instance\n * const { Harmony } = require('@harmony-js/core');\n * const { ChainID, ChainType } = require('@harmony-js/utils');\n * const hmy = new Harmony(\n *   // let's assume we deploy smart contract to this end-point URL\n *   'https://api.s0.b.hmny.io'\n *   {\n *     chainType: ChainType.Harmony,\n *     chainId: ChainID.HmyLocal,\n *   }\n * )\n *\n * // Step 2: get a contract instance\n * const getContractInstance = (hmy, artifact) => {\n *   return hmy.contracts.createContract(artifact.abi, address);\n * }\n * const inbox = getContractInstance(hmy, inboxJson)\n *\n * // Step 3: interact with the instance\n * // Example 1: methods.myMethod.call()\n * const message = await inbox.methods.message().call();\n * console.log(message);\n *\n * // Example 2: methods.myMethod.send()\n * inbox.methods.setMessage('666').send({\n *   gasLimit: '1000001',\n *   gasPrice: new hmy.utils.Unit('10').asGwei().toWei(),\n * });\n * ```\n *\n * ### Integrate MathWallet\n * Using MathWallet to sign Transaction\n * ```javascript\n * // Step 0: set up MathWallet extension on Chrome\n *\n * // Step 1: Create a harmonyExtension instance\n * const { Harmony, HarmonyExtension } = require('@harmony-js/core');\n * let hmyEx, ExContract;\n * export const initExtension = async() => {\n *   hmyEx = await new HarmonyExtension(window.harmony);\n *\n *   exContract = hmyEx.contracts.createContract(abi, address);\n *   return exContract;\n * };\n *\n * // Step 2: interact with hmyEx instance\n * // wait for hmy inject into window\n * async componentDidMount() {\n *   ...\n *   await waitForInjected()\n *   ...\n * }\n * // Example: methods.myMethod.send()\n * onSubmit = async event => {\n *   const exContract = await initExtension()\n *   await exContract.methods.Mymethod().send({\n *     value: new hmy.utils.Unit('1').asOne().toWei(),\n *   })\n * }\n *\n * // wait for injected\n * export const waitForInjected = () => new Promise((resolve) => {\n *   const check = () => {\n *     if (!window.harmony) setTimeout(check, 250);\n *     else resolve(window.harmony);\n *   }\n *   check();\n * });\n * ```\n *\n * ## [More Examples: HRC repo](https://github.com/harmony-one/HRC/tree/master/examples)\n * - Lottery\n * - HRC 20\n * - HRC 721\n * - Node-dao\n * - Node-faucet\n *\n * @packageDocumentation\n * @module harmony-contract\n */\n\n// this file is mainly ported from `ethers.js`, but done some fixes\n// 1. added bytesPadRight support\n// 2. ts-lint\n// 3. use BN as default Bignumber instance\n\nimport {\n  BN,\n  info,\n  throwError,\n  INVALID_ARGUMENT,\n  arrayify,\n  hexlify,\n  padZeros,\n  concat,\n  toChecksumAddress,\n  checkArgumentCount,\n  checkNormalize,\n  Arrayish,\n  checkNew,\n  bytesPadRight,\n} from '@harmony-js/crypto';\nimport { hexToBN, defineReadOnly } from '@harmony-js/utils';\n\n/** @hidden */\nconst NegativeOne: BN = new BN(-1);\n/** @hidden */\nconst One: BN = new BN(1);\n/** @hidden */\nconst Zero: BN = new BN(0);\n/** @hidden */\nconst HashZero = '0x0000000000000000000000000000000000000000000000000000000000000000';\n/** @hidden */\nconst MaxUint256: BN = hexToBN(\n  '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff',\n);\n\n/** @hidden */\nexport type CoerceFunc = (type: string, value: any) => any;\n\n/** @hidden */\nexport interface ParamType {\n  name?: string;\n  type: string;\n  indexed?: boolean;\n  components?: any[];\n}\n\n// @TODO: should this just be a combined Fragment?\n\n/** @hidden */\nexport interface EventFragment {\n  type: string;\n  name: string;\n\n  anonymous: boolean;\n\n  inputs: ParamType[];\n}\n\n/** @hidden */\nexport interface FunctionFragment {\n  type: string;\n  name: string;\n\n  constant: boolean;\n\n  inputs: ParamType[];\n  outputs: ParamType[];\n\n  payable: boolean;\n  stateMutability: string | null;\n\n  gas: BN | null;\n}\n\n///////////////////////////////\n/** @hidden */\nconst paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\n/** @hidden */\nconst paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\n/** @hidden */\nconst paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\n\n/** @hidden */\nexport const defaultCoerceFunc: CoerceFunc = (type: string, value: any): any => {\n  const match = type.match(paramTypeNumber);\n  if (match && parseInt(match[2], 10) <= 48) {\n    // return value.toNumber();\n    return value.toString('hex');\n  }\n  return value;\n};\n\n///////////////////////////////////\n// Parsing for Solidity Signatures\n\n///////////////////////////////////\n// Parsing for Solidity Signatures\n\n/** @hidden */\nconst regexParen = new RegExp('^([^)(]*)\\\\((.*)\\\\)([^)(]*)$');\n/** @hidden */\nconst regexIdentifier = new RegExp('^[A-Za-z_][A-Za-z0-9_]*$');\n\n/** @hidden */\nfunction verifyType(type: string): string {\n  // These need to be transformed to their full description\n  if (type.match(/^uint($|[^1-9])/)) {\n    type = 'uint256' + type.substring(4);\n  } else if (type.match(/^int($|[^1-9])/)) {\n    type = 'int256' + type.substring(3);\n  }\n\n  return type;\n}\n\n/** @hidden */\ninterface ParseState {\n  allowArray?: boolean;\n  allowName?: boolean;\n  allowParams?: boolean;\n  allowType?: boolean;\n  readArray?: boolean;\n}\n\n/** @hidden */\ninterface ParseNode {\n  parent?: any;\n  type?: string;\n  name?: string;\n  state?: ParseState;\n  indexed?: boolean;\n  components?: any[];\n}\n\n/** @hidden */\nfunction parseParam(param: string, allowIndexed?: boolean): ParamType {\n  const originalParam = param;\n  // tslint:disable-next-line: no-shadowed-variable\n  function throwError(i: number) {\n    throw new Error(\n      'unexpected character \"' +\n        originalParam[i] +\n        '\" at position ' +\n        i +\n        ' in \"' +\n        originalParam +\n        '\"',\n    );\n  }\n  param = param.replace(/\\s/g, ' ');\n\n  const parent: ParseNode = { type: '', name: '', state: { allowType: true } };\n  let node = parent;\n\n  for (let i = 0; i < param.length; i++) {\n    const c = param[i];\n    switch (c) {\n      case '(':\n        if (!node.state || !node.state.allowParams) {\n          throwError(i);\n        }\n        if (node.state) {\n          node.state.allowType = false;\n        }\n        if (node.type) {\n          node.type = verifyType(node.type);\n        }\n\n        node.components = [{ type: '', name: '', parent: node, state: { allowType: true } }];\n        node = node.components[0];\n        break;\n\n      case ')':\n        delete node.state;\n        if (allowIndexed && node.name === 'indexed') {\n          node.indexed = true;\n          node.name = '';\n        }\n        if (node.type) {\n          node.type = verifyType(node.type);\n        }\n\n        const child = node;\n        node = node.parent;\n        if (!node) {\n          throwError(i);\n        }\n        delete child.parent;\n        if (node.state) {\n          node.state.allowParams = false;\n          node.state.allowName = true;\n          node.state.allowArray = true;\n        }\n\n        break;\n\n      case ',':\n        delete node.state;\n        if (allowIndexed && node.name === 'indexed') {\n          node.indexed = true;\n          node.name = '';\n        }\n        if (node.type) {\n          node.type = verifyType(node.type);\n        }\n\n        const sibling: ParseNode = {\n          type: '',\n          name: '',\n          parent: node.parent,\n          state: { allowType: true },\n        };\n        node.parent.components.push(sibling);\n        delete node.parent;\n        node = sibling;\n        break;\n\n      // Hit a space...\n      case ' ':\n        // If reading type, the type is done and may read a param or name\n        if (node.state) {\n          if (node.state.allowType) {\n            if (node.type !== '' && node.type) {\n              node.type = verifyType(node.type);\n              delete node.state.allowType;\n              node.state.allowName = true;\n              node.state.allowParams = true;\n            }\n          }\n\n          // If reading name, the name is done\n          if (node.state.allowName) {\n            if (node.name !== '') {\n              if (allowIndexed && node.name === 'indexed') {\n                node.indexed = true;\n                node.name = '';\n              } else {\n                node.state.allowName = false;\n              }\n            }\n          }\n        }\n\n        break;\n\n      case '[':\n        if (!node.state || !node.state.allowArray) {\n          throwError(i);\n        }\n        if (node.state) {\n          node.type += c;\n          node.state.allowArray = false;\n          node.state.allowName = false;\n          node.state.readArray = true;\n        }\n\n        break;\n\n      case ']':\n        if (!node.state || !node.state.readArray) {\n          throwError(i);\n        }\n        if (node.state) {\n          node.type += c;\n\n          node.state.readArray = false;\n          node.state.allowArray = true;\n          node.state.allowName = true;\n        }\n\n        break;\n\n      default:\n        if (node.state) {\n          if (node.state.allowType) {\n            node.type += c;\n            node.state.allowParams = true;\n            node.state.allowArray = true;\n          } else if (node.state.allowName) {\n            node.name += c;\n            delete node.state.allowArray;\n          } else if (node.state.readArray) {\n            node.type += c;\n          } else {\n            throwError(i);\n          }\n        }\n    }\n  }\n\n  if (node.parent) {\n    throw new Error('unexpected eof');\n  }\n\n  delete parent.state;\n\n  if (allowIndexed && node.name === 'indexed') {\n    node.indexed = true;\n    node.name = '';\n  }\n\n  if (parent.type) {\n    parent.type = verifyType(parent.type);\n  }\n\n  return <ParamType>parent;\n}\n\n// @TODO: Better return type\n/** @hidden */\nfunction parseSignatureEvent(fragment: string): EventFragment {\n  const abi: EventFragment = {\n    anonymous: false,\n    inputs: [],\n    name: '',\n    type: 'event',\n  };\n\n  const match = fragment.match(regexParen);\n  if (!match) {\n    throw new Error('invalid event: ' + fragment);\n  }\n\n  abi.name = match[1].trim();\n\n  splitNesting(match[2]).forEach((param) => {\n    param = parseParam(param, true);\n    param.indexed = !!param.indexed;\n    abi.inputs.push(param);\n  });\n\n  match[3].split(' ').forEach((modifier) => {\n    switch (modifier) {\n      case 'anonymous':\n        abi.anonymous = true;\n        break;\n      case '':\n        break;\n      default:\n        info('unknown modifier: ' + modifier);\n    }\n  });\n\n  if (abi.name && !abi.name.match(regexIdentifier)) {\n    throw new Error('invalid identifier: \"' + abi.name + '\"');\n  }\n\n  return abi;\n}\n\n/** @hidden */\nexport function parseParamType(type: string): ParamType {\n  return parseParam(type, true);\n}\n\n// @TODO: Allow a second boolean to expose names\n/** @hidden */\nexport function formatParamType(paramType: ParamType): string {\n  return getParamCoder(defaultCoerceFunc, paramType).type;\n}\n\n/** @hidden */\nfunction parseSignatureFunction(fragment: string): FunctionFragment {\n  const abi: FunctionFragment = {\n    constant: false,\n    gas: null,\n    inputs: [],\n    name: '',\n    outputs: [],\n    payable: false,\n    stateMutability: null, // @TODO: Should this be initialized to 'nonpayable'?\n    type: 'function',\n  };\n\n  let comps = fragment.split('@');\n  if (comps.length !== 1) {\n    if (comps.length > 2) {\n      throw new Error('invalid signature');\n    }\n    if (!comps[1].match(/^[0-9]+$/)) {\n      throw new Error('invalid signature gas');\n    }\n    abi.gas = new BN(comps[1]);\n    fragment = comps[0];\n  }\n\n  comps = fragment.split(' returns ');\n  const left = comps[0].match(regexParen);\n  if (!left) {\n    throw new Error('invalid signature');\n  }\n\n  abi.name = left[1].trim();\n  if (!abi.name.match(regexIdentifier)) {\n    throw new Error('invalid identifier: \"' + left[1] + '\"');\n  }\n\n  splitNesting(left[2]).forEach((param) => {\n    abi.inputs.push(parseParam(param));\n  });\n\n  left[3].split(' ').forEach((modifier) => {\n    switch (modifier) {\n      case 'constant':\n        abi.constant = true;\n        break;\n      case 'payable':\n        abi.payable = true;\n        abi.stateMutability = 'payable';\n        break;\n      case 'pure':\n        abi.constant = true;\n        abi.stateMutability = 'pure';\n        break;\n      case 'view':\n        abi.constant = true;\n        abi.stateMutability = 'view';\n        break;\n      case 'external':\n      case 'public':\n      case '':\n        break;\n      default:\n        info('unknown modifier: ' + modifier);\n    }\n  });\n\n  // We have outputs\n  if (comps.length > 1) {\n    const right = comps[1].match(regexParen);\n    if (right === null || right[1].trim() !== '' || right[3].trim() !== '') {\n      throw new Error('unexpected tokens');\n    }\n\n    splitNesting(right[2]).forEach((param) => {\n      abi.outputs.push(parseParam(param));\n    });\n  }\n\n  if (abi.name === 'constructor') {\n    abi.type = 'constructor';\n\n    if (abi.outputs.length) {\n      throw new Error('constructor may not have outputs');\n    }\n\n    delete abi.name;\n    delete abi.outputs;\n  }\n\n  return abi;\n}\n\n// @TODO: Allow a second boolean to expose names and modifiers\n/** @hidden */\nexport function formatSignature(fragment: EventFragment | FunctionFragment): string {\n  return fragment.name + '(' + fragment.inputs.map((i) => formatParamType(i)).join(',') + ')';\n}\n\n/** @hidden */\nexport function parseSignature(fragment: string): EventFragment | FunctionFragment {\n  if (typeof fragment === 'string') {\n    // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n    fragment = fragment.replace(/\\s/g, ' ');\n    fragment = fragment\n      .replace(/\\(/g, ' (')\n      .replace(/\\)/g, ') ')\n      .replace(/\\s+/g, ' ');\n    fragment = fragment.trim();\n\n    if (fragment.substring(0, 6) === 'event ') {\n      return parseSignatureEvent(fragment.substring(6).trim());\n    } else {\n      if (fragment.substring(0, 9) === 'function ') {\n        fragment = fragment.substring(9);\n      }\n      return parseSignatureFunction(fragment.trim());\n    }\n  }\n\n  throw new Error('unknown signature');\n}\n\n///////////////////////////////////\n// Coders\n/** @hidden */\ninterface DecodedResult {\n  consumed: number;\n  value: any;\n}\n\n/** @hidden */\nabstract class Coder {\n  readonly coerceFunc: CoerceFunc;\n  readonly name: string;\n  readonly type: string;\n  readonly localName?: string;\n  readonly dynamic: boolean;\n  constructor(\n    coerceFunc: CoerceFunc,\n    name: string,\n    type: string,\n    localName: string | undefined,\n    dynamic: boolean,\n  ) {\n    this.coerceFunc = coerceFunc;\n    this.name = name;\n    this.type = type;\n    this.localName = localName;\n    this.dynamic = dynamic;\n  }\n\n  abstract encode(value: any): Uint8Array;\n  abstract decode(data: Uint8Array, offset: number): DecodedResult;\n}\n\n// Clones the functionality of an existing Coder, but without a localName\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nclass CoderAnonymous extends Coder {\n  private coder: Coder;\n  constructor(coder: Coder) {\n    super(coder.coerceFunc, coder.name, coder.type, undefined, coder.dynamic);\n    this.coder = coder;\n  }\n  encode(value: any): Uint8Array {\n    return this.coder.encode(value);\n  }\n  decode(data: Uint8Array, offset: number): DecodedResult {\n    return this.coder.decode(data, offset);\n  }\n}\n\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nclass CoderNull extends Coder {\n  constructor(coerceFunc: CoerceFunc, localName: string) {\n    super(coerceFunc, 'null', '', localName, false);\n  }\n\n  encode(value: any): Uint8Array {\n    const result = arrayify([]) || new Uint8Array();\n    return result;\n  }\n\n  decode(data: Uint8Array, offset: number): DecodedResult {\n    if (offset > data.length) {\n      throw new Error('invalid null');\n    }\n    return {\n      consumed: 0,\n      value: this.coerceFunc('null', undefined),\n    };\n  }\n}\n\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nclass CoderNumber extends Coder {\n  readonly size: number;\n  readonly signed: boolean;\n  constructor(coerceFunc: CoerceFunc, size: number, signed: boolean, localName: string) {\n    const name = (signed ? 'int' : 'uint') + size * 8;\n    super(coerceFunc, name, name, localName, false);\n\n    this.size = size;\n    this.signed = signed;\n  }\n\n  encode(value: BN | number | string): Uint8Array {\n    let result;\n    try {\n      let v = new BN(value);\n      if (this.signed) {\n        let bounds = MaxUint256.maskn(this.size * 8 - 1);\n        if (v.gt(bounds)) {\n          throw new Error('out-of-bounds');\n        }\n        bounds = bounds.add(One).mul(NegativeOne);\n        if (v.lt(bounds)) {\n          throw new Error('out-of-bounds');\n        }\n      } else if (v.lt(Zero) || v.gt(MaxUint256.maskn(this.size * 8))) {\n        throw new Error('out-of-bounds');\n      }\n\n      v = v.toTwos(this.size * 8).maskn(this.size * 8);\n      if (this.signed) {\n        v = v.fromTwos(this.size * 8).toTwos(256);\n      }\n      const vString = v.toString('hex');\n\n      result = padZeros(arrayify(`0x${vString}`) || new Uint8Array(), 32);\n    } catch (error) {\n      throwError('invalid number value', INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: this.name,\n        value,\n      });\n    }\n    return result || padZeros(new Uint8Array(), 32);\n  }\n\n  decode(data: Uint8Array, offset: number): DecodedResult {\n    if (data.length < offset + 32) {\n      throwError('insufficient data for ' + this.name + ' type', INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: this.name,\n        value: hexlify(data.slice(offset, offset + 32)),\n      });\n    }\n    const junkLength = 32 - this.size;\n    const dataValue = hexlify(data.slice(offset + junkLength, offset + 32));\n\n    let value = hexToBN(dataValue);\n    // tslint:disable-next-line: prefer-conditional-expression\n    if (this.signed) {\n      value = value.fromTwos(this.size * 8);\n    } else {\n      value = value.maskn(this.size * 8);\n    }\n\n    return {\n      consumed: 32,\n      value: this.coerceFunc(this.name, value),\n    };\n  }\n}\n\n/** @hidden */\nconst uint256Coder = new CoderNumber(\n  (type: string, value: any) => {\n    return value;\n  },\n  32,\n  false,\n  'none',\n);\n\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nclass CoderBoolean extends Coder {\n  constructor(coerceFunc: CoerceFunc, localName: string) {\n    super(coerceFunc, 'bool', 'bool', localName, false);\n  }\n\n  encode(value: boolean): Uint8Array {\n    return uint256Coder.encode(!!value ? new BN(1) : new BN(0));\n  }\n\n  decode(data: Uint8Array, offset: number): DecodedResult {\n    let result;\n    try {\n      result = uint256Coder.decode(data, offset);\n    } catch (error) {\n      if (error.reason === 'insufficient data for uint256 type') {\n        throwError('insufficient data for boolean type', INVALID_ARGUMENT, {\n          arg: this.localName,\n          coderType: 'boolean',\n          value: error.value,\n        });\n      }\n      throw error;\n    }\n    return {\n      consumed: result.consumed,\n      value: this.coerceFunc('bool', !result.value.isZero()),\n    };\n  }\n}\n\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nclass CoderFixedBytes extends Coder {\n  readonly length: number;\n  constructor(coerceFunc: CoerceFunc, length: number, localName: string) {\n    const name = 'bytes' + length;\n    super(coerceFunc, name, name, localName, false);\n    this.length = length;\n  }\n\n  encode(value: Arrayish): Uint8Array {\n    const result = new Uint8Array(this.length);\n\n    try {\n      const arrayied = arrayify(value);\n      let data = null;\n      if (arrayied !== null) {\n        const valueToByte = hexlify(arrayied);\n        data = arrayify(bytesPadRight(valueToByte, this.length));\n      } else {\n        throw new Error('cannot arraify data');\n      }\n\n      if (data === null || data.length !== this.length) {\n        throw new Error('incorrect data length');\n      }\n      result.set(data);\n    } catch (error) {\n      throwError('invalid ' + this.name + ' value', INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: this.name,\n        value: error.value || value,\n      });\n    }\n    return result;\n  }\n\n  decode(data: Uint8Array, offset: number): DecodedResult {\n    if (data.length < offset + 32) {\n      throwError('insufficient data for ' + name + ' type', INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: this.name,\n        value: hexlify(data.slice(offset, offset + 32)),\n      });\n    }\n\n    return {\n      consumed: 32,\n      value: this.coerceFunc(this.name, hexlify(data.slice(offset, offset + this.length))),\n    };\n  }\n}\n\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nclass CoderAddress extends Coder {\n  constructor(coerceFunc: CoerceFunc, localName: string) {\n    super(coerceFunc, 'address', 'address', localName, false);\n  }\n  encode(value: string): Uint8Array {\n    const result = new Uint8Array(32);\n    try {\n      const addr = arrayify(toChecksumAddress(value)) || new Uint8Array();\n      result.set(addr, 12);\n    } catch (error) {\n      throwError('invalid address', INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'address',\n        value,\n      });\n    }\n    return result;\n  }\n  decode(data: Uint8Array, offset: number): DecodedResult {\n    if (data.length < offset + 32) {\n      throwError('insufficuent data for address type', INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'address',\n        value: hexlify(data.slice(offset, offset + 32)),\n      });\n    }\n    return {\n      consumed: 32,\n      value: this.coerceFunc(\n        'address',\n        toChecksumAddress(hexlify(data.slice(offset + 12, offset + 32))),\n      ),\n    };\n  }\n}\n\n/** @hidden */\nfunction _encodeDynamicBytes(value: Uint8Array): Uint8Array {\n  const dataLength = 32 * Math.ceil(value.length / 32);\n  const padding = new Uint8Array(dataLength - value.length);\n\n  return concat([uint256Coder.encode(new BN(value.length)), value, padding]);\n}\n\n/** @hidden */\nfunction _decodeDynamicBytes(data: Uint8Array, offset: number, localName: string): DecodedResult {\n  if (data.length < offset + 32) {\n    throwError('insufficient data for dynamicBytes length', INVALID_ARGUMENT, {\n      arg: localName,\n      coderType: 'dynamicBytes',\n      value: hexlify(data.slice(offset, offset + 32)),\n    });\n  }\n\n  let length = uint256Coder.decode(data, offset).value;\n\n  try {\n    length = length.toNumber();\n  } catch (error) {\n    throwError('dynamic bytes count too large', INVALID_ARGUMENT, {\n      arg: localName,\n      coderType: 'dynamicBytes',\n      value: length.toString(),\n    });\n  }\n\n  if (data.length < offset + 32 + length) {\n    throwError('insufficient data for dynamicBytes type', INVALID_ARGUMENT, {\n      arg: localName,\n      coderType: 'dynamicBytes',\n      value: hexlify(data.slice(offset, offset + 32 + length)),\n    });\n  }\n\n  return {\n    consumed: 32 + 32 * Math.ceil(length / 32),\n    value: data.slice(offset + 32, offset + 32 + length),\n  };\n}\n\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nclass CoderDynamicBytes extends Coder {\n  constructor(coerceFunc: CoerceFunc, localName: string) {\n    super(coerceFunc, 'bytes', 'bytes', localName, true);\n  }\n  encode(value: Arrayish): Uint8Array {\n    let result = new Uint8Array();\n    try {\n      result = _encodeDynamicBytes(arrayify(value) || new Uint8Array());\n    } catch (error) {\n      throwError('invalid bytes value', INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'bytes',\n        value: error.value,\n      });\n    }\n    return result;\n  }\n\n  decode(data: Uint8Array, offset: number): DecodedResult {\n    const result = _decodeDynamicBytes(data, offset, this.localName || '');\n    result.value = this.coerceFunc('bytes', hexlify(result.value));\n    return result;\n  }\n}\n\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nclass CoderString extends Coder {\n  constructor(coerceFunc: CoerceFunc, localName: string) {\n    super(coerceFunc, 'string', 'string', localName, true);\n  }\n\n  encode(value: string): Uint8Array {\n    if (typeof value !== 'string') {\n      throwError('invalid string value', INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'string',\n        value,\n      });\n    }\n    return _encodeDynamicBytes(toUtf8Bytes(value));\n  }\n\n  decode(data: Uint8Array, offset: number): DecodedResult {\n    const result = _decodeDynamicBytes(data, offset, this.localName || '');\n    result.value = this.coerceFunc('string', toUtf8String(result.value));\n    return result;\n  }\n}\n\n/** @hidden */\nfunction alignSize(size: number): number {\n  return 32 * Math.ceil(size / 32);\n}\n\n/** @hidden */\nfunction pack(coders: Coder[], values: any[]): Uint8Array {\n  if (Array.isArray(values)) {\n    // do nothing\n  } else if (values && typeof values === 'object') {\n    const arrayValues: any[] = [];\n    coders.forEach((coder) => {\n      arrayValues.push((<any>values)[coder.localName || '']);\n    });\n    values = arrayValues;\n  } else {\n    throwError('invalid tuple value', INVALID_ARGUMENT, {\n      coderType: 'tuple',\n      value: values,\n    });\n  }\n\n  if (coders.length !== values.length) {\n    throwError('types/value length mismatch', INVALID_ARGUMENT, {\n      coderType: 'tuple',\n      value: values,\n    });\n  }\n\n  const parts: Array<{ dynamic: boolean; value: any }> = [];\n\n  coders.forEach((coder, index) => {\n    parts.push({ dynamic: coder.dynamic, value: coder.encode(values[index]) });\n  });\n\n  let staticSize = 0;\n  let dynamicSize = 0;\n  parts.forEach((part) => {\n    if (part.dynamic) {\n      staticSize += 32;\n      dynamicSize += alignSize(part.value.length);\n    } else {\n      staticSize += alignSize(part.value.length);\n      // todo : is it to be static size not alignSize?\n    }\n  });\n\n  let offset = 0;\n  let dynamicOffset = staticSize;\n  const data = new Uint8Array(staticSize + dynamicSize);\n\n  parts.forEach((part) => {\n    if (part.dynamic) {\n      // uint256Coder.encode(dynamicOffset).copy(data, offset);\n      data.set(uint256Coder.encode(new BN(dynamicOffset)), offset);\n      offset += 32;\n\n      // part.value.copy(data, dynamicOffset);  @TODO\n      data.set(part.value, dynamicOffset);\n      dynamicOffset += alignSize(part.value.length);\n    } else {\n      // part.value.copy(data, offset);  @TODO\n      data.set(part.value, offset);\n      offset += alignSize(part.value.length);\n    }\n  });\n\n  return data;\n}\n\n/** @hidden */\nfunction unpack(coders: Coder[], data: Uint8Array, offset: number): DecodedResult {\n  const baseOffset = offset;\n  let consumed = 0;\n  const value: any = [];\n  coders.forEach((coder) => {\n    let result: DecodedResult;\n    if (coder.dynamic) {\n      const dynamicOffset = uint256Coder.decode(data, offset);\n      result = coder.decode(data, baseOffset + dynamicOffset.value.toNumber());\n      // The dynamic part is leap-frogged somewhere else; doesn't count towards size\n      result.consumed = dynamicOffset.consumed;\n    } else {\n      result = coder.decode(data, offset);\n    }\n\n    if (result.value !== undefined) {\n      value.push(result.value);\n    }\n\n    offset += result.consumed;\n    consumed += result.consumed;\n  });\n\n  coders.forEach((coder: Coder, index: number) => {\n    let name: string | undefined = coder.localName;\n    if (!name) {\n      return;\n    }\n\n    if (name === 'length') {\n      name = '_length';\n    }\n\n    if (value[name] != null) {\n      return;\n    }\n\n    value[name] = value[index];\n  });\n\n  return {\n    value,\n    consumed,\n  };\n}\n\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nclass CoderArray extends Coder {\n  readonly coder: Coder;\n  readonly length: number;\n  constructor(coerceFunc: CoerceFunc, coder: Coder, length: number, localName: string) {\n    const type = coder.type + '[' + (length >= 0 ? length : '') + ']';\n    const dynamic = length === -1 || coder.dynamic;\n    super(coerceFunc, 'array', type, localName, dynamic);\n\n    this.coder = coder;\n    this.length = length;\n  }\n\n  encode(value: any[]): Uint8Array {\n    if (!Array.isArray(value)) {\n      throwError('expected array value', INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'array',\n        value,\n      });\n    }\n\n    let count = this.length;\n\n    let result = new Uint8Array(0);\n    if (count === -1) {\n      count = value.length;\n      result = uint256Coder.encode(new BN(count));\n    }\n\n    checkArgumentCount(\n      count,\n      value.length,\n      ' in coder array' + (this.localName ? ' ' + this.localName : ''),\n    );\n\n    const coders = [];\n    // tslint:disable-next-line: prefer-for-of\n    for (let i = 0; i < value.length; i++) {\n      coders.push(this.coder);\n    }\n\n    return concat([result, pack(coders, value)]);\n  }\n\n  decode(data: Uint8Array, offset: number) {\n    // @TODO:\n    // if (data.length < offset + length * 32) { throw new Error('invalid array'); }\n\n    let consumed = 0;\n\n    let count = this.length;\n\n    let decodedLength: DecodedResult = { consumed: 0, value: undefined };\n    if (count === -1) {\n      try {\n        decodedLength = uint256Coder.decode(data, offset);\n      } catch (error) {\n        throwError('insufficient data for dynamic array length', INVALID_ARGUMENT, {\n          arg: this.localName,\n          coderType: 'array',\n          value: error.value,\n        });\n      }\n      try {\n        count = decodedLength.value.toNumber();\n      } catch (error) {\n        throwError('array count too large', INVALID_ARGUMENT, {\n          arg: this.localName,\n          coderType: 'array',\n          value: decodedLength.value.toString(),\n        });\n      }\n      consumed += decodedLength.consumed;\n      offset += decodedLength.consumed;\n    }\n\n    const coders = [];\n    for (let i = 0; i < count; i++) {\n      coders.push(new CoderAnonymous(this.coder));\n    }\n\n    const result = unpack(coders, data, offset);\n    result.consumed += consumed;\n    result.value = this.coerceFunc(this.type, result.value);\n    return result;\n  }\n}\n\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nclass CoderTuple extends Coder {\n  readonly coders: Coder[];\n  constructor(coerceFunc: CoerceFunc, coders: Coder[], localName: string) {\n    let dynamic = false;\n    const types: string[] = [];\n    coders.forEach((coder) => {\n      if (coder.dynamic) {\n        dynamic = true;\n      }\n      types.push(coder.type);\n    });\n    const type = 'tuple(' + types.join(',') + ')';\n\n    super(coerceFunc, 'tuple', type, localName, dynamic);\n    this.coders = coders;\n  }\n\n  encode(value: any[]): Uint8Array {\n    return pack(this.coders, value);\n  }\n\n  decode(data: Uint8Array, offset: number): DecodedResult {\n    const result = unpack(this.coders, data, offset);\n    result.value = this.coerceFunc(this.type, result.value);\n\n    return result;\n  }\n}\n\n/** @hidden */\nfunction splitNesting(value: string): any[] {\n  value = value.trim();\n\n  const result = [];\n  let accum = '';\n  let depth = 0;\n\n  // tslint:disable-next-line: prefer-for-of\n  for (let offset = 0; offset < value.length; offset++) {\n    const c = value[offset];\n    if (c === ',' && depth === 0) {\n      result.push(accum);\n      accum = '';\n    } else {\n      accum += c;\n      if (c === '(') {\n        depth++;\n      } else if (c === ')') {\n        depth--;\n        if (depth === -1) {\n          throw new Error('unbalanced parenthsis');\n        }\n      }\n    }\n  }\n  if (accum) {\n    result.push(accum);\n  }\n\n  return result;\n}\n\n// @TODO: Is there a way to return \"class\"?\n/** @hidden */\nconst paramTypeSimple: { [key: string]: any } = {\n  address: CoderAddress,\n  bool: CoderBoolean,\n  string: CoderString,\n  bytes: CoderDynamicBytes,\n};\n\n/** @hidden */\nfunction getTupleParamCoder(\n  coerceFunc: CoerceFunc,\n  components: any[],\n  localName: string,\n): CoderTuple {\n  if (!components) {\n    components = [];\n  }\n  const coders: Coder[] = [];\n  components.forEach((component) => {\n    coders.push(getParamCoder(coerceFunc, component));\n  });\n\n  return new CoderTuple(coerceFunc, coders, localName);\n}\n\n/** @hidden */\nfunction getParamCoder(coerceFunc: CoerceFunc, param: ParamType | any): any {\n  const coder = paramTypeSimple[param.type];\n  if (coder) {\n    return new coder(coerceFunc, param.name);\n  }\n  const matcher = param.type.match(paramTypeNumber);\n  if (matcher) {\n    const size = parseInt(matcher[2] || '256', 10);\n    if (size === 0 || size > 256 || size % 8 !== 0) {\n      throwError('invalid ' + matcher[1] + ' bit length', INVALID_ARGUMENT, {\n        arg: 'param',\n        value: param,\n      });\n    }\n    return new CoderNumber(coerceFunc, size / 8, matcher[1] === 'int', param.name || '');\n  }\n\n  const matcher2 = param.type.match(paramTypeBytes);\n  if (matcher2) {\n    const size = parseInt(matcher2[1], 10);\n    if (size === 0 || size > 32) {\n      throwError('invalid bytes length', INVALID_ARGUMENT, {\n        arg: 'param',\n        value: param,\n      });\n    }\n    return new CoderFixedBytes(coerceFunc, size, param.name || '');\n  }\n\n  const matcher3 = param.type.match(paramTypeArray);\n  if (matcher3) {\n    const size = parseInt(matcher3[2] || '-1', 10);\n    param = shallowCopy(param);\n    param.type = matcher3[1];\n    param = deepCopy(param);\n    return new CoderArray(coerceFunc, getParamCoder(coerceFunc, param), size, param.name || '');\n  }\n\n  if (param.type.substring(0, 5) === 'tuple') {\n    return getTupleParamCoder(coerceFunc, param.components || [], param.name || '');\n  }\n\n  if (param.type === '') {\n    return new CoderNull(coerceFunc, param.name || '');\n  }\n\n  throwError('invalid type', INVALID_ARGUMENT, {\n    arg: 'type',\n    value: param.type,\n  });\n}\n\n/** @hidden */\nexport enum UnicodeNormalizationForm {\n  current = '',\n  NFC = 'NFC',\n  NFD = 'NFD',\n  NFKC = 'NFKC',\n  NFKD = 'NFKD',\n}\n\n/** @hidden */\nexport function toUtf8Bytes(\n  str: string,\n  form: UnicodeNormalizationForm = UnicodeNormalizationForm.current,\n): Uint8Array {\n  if (form !== UnicodeNormalizationForm.current) {\n    checkNormalize();\n    str = str.normalize(form);\n  }\n\n  const result = [];\n  for (let i = 0; i < str.length; i++) {\n    let c = str.charCodeAt(i);\n\n    if (c < 0x80) {\n      result.push(c);\n    } else if (c < 0x800) {\n      result.push((c >> 6) | 0xc0);\n      result.push((c & 0x3f) | 0x80);\n    } else if ((c & 0xfc00) === 0xd800) {\n      i++;\n      const c2 = str.charCodeAt(i);\n\n      if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n        throw new Error('invalid utf-8 string');\n      }\n\n      // Surrogate Pair\n      c = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n      result.push((c >> 18) | 0xf0);\n      result.push(((c >> 12) & 0x3f) | 0x80);\n      result.push(((c >> 6) & 0x3f) | 0x80);\n      result.push((c & 0x3f) | 0x80);\n    } else {\n      result.push((c >> 12) | 0xe0);\n      result.push(((c >> 6) & 0x3f) | 0x80);\n      result.push((c & 0x3f) | 0x80);\n    }\n  }\n\n  return arrayify(result) || new Uint8Array();\n}\n\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\n/** @hidden */\nexport function toUtf8String(bytes: Arrayish, ignoreErrors?: boolean): string {\n  bytes = arrayify(bytes) || new Uint8Array();\n\n  let result = '';\n  let i = 0;\n\n  // Invalid bytes are ignored\n  while (i < bytes.length) {\n    const c = bytes[i++];\n    // 0xxx xxxx\n    if (c >> 7 === 0) {\n      result += String.fromCharCode(c);\n      continue;\n    }\n\n    // Multibyte; how many bytes left for this character?\n    let extraLength = null;\n    let overlongMask = null;\n\n    // 110x xxxx 10xx xxxx\n    if ((c & 0xe0) === 0xc0) {\n      extraLength = 1;\n      overlongMask = 0x7f;\n\n      // 1110 xxxx 10xx xxxx 10xx xxxx\n    } else if ((c & 0xf0) === 0xe0) {\n      extraLength = 2;\n      overlongMask = 0x7ff;\n\n      // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n    } else if ((c & 0xf8) === 0xf0) {\n      extraLength = 3;\n      overlongMask = 0xffff;\n    } else {\n      if (!ignoreErrors) {\n        if ((c & 0xc0) === 0x80) {\n          throw new Error('invalid utf8 byte sequence; unexpected continuation byte');\n        }\n        throw new Error('invalid utf8 byte sequence; invalid prefix');\n      }\n      continue;\n    }\n\n    // Do we have enough bytes in our data?\n    if (i + extraLength > bytes.length) {\n      if (!ignoreErrors) {\n        throw new Error('invalid utf8 byte sequence; too short');\n      }\n\n      // If there is an invalid unprocessed byte, skip continuation bytes\n      for (; i < bytes.length; i++) {\n        if (bytes[i] >> 6 !== 0x02) {\n          break;\n        }\n      }\n\n      continue;\n    }\n\n    // Remove the length prefix from the char\n    let res: number | null = c & ((1 << (8 - extraLength - 1)) - 1);\n\n    for (let j = 0; j < extraLength; j++) {\n      const nextChar = bytes[i];\n\n      // Invalid continuation byte\n      if ((nextChar & 0xc0) !== 0x80) {\n        res = null;\n        break;\n      }\n\n      res = (res << 6) | (nextChar & 0x3f);\n      i++;\n    }\n\n    if (res === null) {\n      if (!ignoreErrors) {\n        throw new Error('invalid utf8 byte sequence; invalid continuation byte');\n      }\n      continue;\n    }\n\n    // Check for overlong seuences (more bytes than needed)\n    if (res <= overlongMask) {\n      if (!ignoreErrors) {\n        throw new Error('invalid utf8 byte sequence; overlong');\n      }\n      continue;\n    }\n\n    // Maximum code point\n    if (res > 0x10ffff) {\n      if (!ignoreErrors) {\n        throw new Error('invalid utf8 byte sequence; out-of-range');\n      }\n      continue;\n    }\n\n    // Reserved for UTF-16 surrogate halves\n    if (res >= 0xd800 && res <= 0xdfff) {\n      if (!ignoreErrors) {\n        throw new Error('invalid utf8 byte sequence; utf-16 surrogate');\n      }\n      continue;\n    }\n\n    if (res <= 0xffff) {\n      result += String.fromCharCode(res);\n      continue;\n    }\n\n    res -= 0x10000;\n    result += String.fromCharCode(((res >> 10) & 0x3ff) + 0xd800, (res & 0x3ff) + 0xdc00);\n  }\n\n  return result;\n}\n\n/** @hidden */\nexport function formatBytes32String(text: string): string {\n  // Get the bytes\n  const bytes = toUtf8Bytes(text);\n\n  // Check we have room for null-termination\n  if (bytes.length > 31) {\n    throw new Error('bytes32 string must be less than 32 bytes');\n  }\n\n  // Zero-pad (implicitly null-terminates)\n  return hexlify(concat([bytes, HashZero]).slice(0, 32));\n}\n\n/** @hidden */\nexport function parseBytes32String(bytes: Arrayish): string {\n  const data = arrayify(bytes) || new Uint8Array();\n\n  // Must be 32 bytes with a null-termination\n  if (data.length !== 32) {\n    throw new Error('invalid bytes32 - not 32 bytes long');\n  }\n  if (data[31] !== 0) {\n    throw new Error('invalid bytes32 sdtring - no null terminator');\n  }\n\n  // Find the null termination\n  let length = 31;\n  while (data[length - 1] === 0) {\n    length--;\n  }\n\n  // Determine the string value\n  return toUtf8String(data.slice(0, length));\n}\n\n/** @hidden */\nexport function isType(object: any, type: string): boolean {\n  return object && object._ethersType === type;\n}\n\n/** @hidden */\nexport function shallowCopy(object: any): any {\n  const result: any = {};\n  // tslint:disable-next-line: forin\n  for (const key in object) {\n    result[key] = object[key];\n  }\n  return result;\n}\n\n/** @hidden */\nconst opaque: { [key: string]: boolean } = {\n  boolean: true,\n  number: true,\n  string: true,\n};\n\n/** @hidden */\nexport function deepCopy(object: any, frozen?: boolean): any {\n  // Opaque objects are not mutable, so safe to copy by assignment\n  if (object === undefined || object === null || opaque[typeof object]) {\n    return object;\n  }\n\n  // Arrays are mutable, so we need to create a copy\n  if (Array.isArray(object)) {\n    const result = object.map((item) => deepCopy(item, frozen));\n    if (frozen) {\n      Object.freeze(result);\n    }\n    return result;\n  }\n\n  if (typeof object === 'object') {\n    // Some internal objects, which are already immutable\n    if (isType(object, 'BigNumber')) {\n      return object;\n    }\n    if (isType(object, 'Description')) {\n      return object;\n    }\n    if (isType(object, 'Indexed')) {\n      return object;\n    }\n\n    const result: { [key: string]: any } = {};\n    // tslint:disable-next-line: forin\n    for (const key in object) {\n      const value = object[key];\n      if (value === undefined) {\n        continue;\n      }\n      defineReadOnly(result, key, deepCopy(value, frozen));\n    }\n\n    if (frozen) {\n      Object.freeze(result);\n    }\n\n    return result;\n  }\n\n  // The function type is also immutable, so safe to copy by assignment\n  if (typeof object === 'function') {\n    return object;\n  }\n\n  throw new Error('Cannot deepCopy ' + typeof object);\n}\n\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nexport class AbiCoder {\n  coerceFunc: CoerceFunc;\n  constructor(coerceFunc?: CoerceFunc) {\n    checkNew(this, AbiCoder);\n\n    if (!coerceFunc) {\n      coerceFunc = defaultCoerceFunc;\n    }\n    this.coerceFunc = coerceFunc;\n  }\n\n  encode(types: Array<string | ParamType>, values: any[]): string {\n    if (types.length !== values.length) {\n      throwError('types/values length mismatch', INVALID_ARGUMENT, {\n        count: { types: types.length, values: values.length },\n        value: { types, values },\n      });\n    }\n\n    const coders: Coder[] = [];\n    types.forEach((type) => {\n      // Convert types to type objects\n      //   - \"uint foo\" => { type: \"uint\", name: \"foo\" }\n      //   - \"tuple(uint, uint)\" => { type: \"tuple\", components: [ { type: \"uint\" }, { type: \"uint\" }, ] }\n\n      let typeObject: ParamType | null = null;\n      // tslint:disable-next-line: prefer-conditional-expression\n      if (typeof type === 'string') {\n        typeObject = parseParam(type);\n      } else {\n        typeObject = type;\n      }\n\n      coders.push(getParamCoder(this.coerceFunc, typeObject));\n    }, this);\n    const encodedArray = new CoderTuple(this.coerceFunc, coders, '_').encode(values);\n    return hexlify(encodedArray);\n  }\n\n  decode(types: Array<string | ParamType>, data: Arrayish): any {\n    const coders: Coder[] = [];\n    types.forEach((type) => {\n      // See encode for details\n      let typeObject: ParamType | null = null;\n      // tslint:disable-next-line: prefer-conditional-expression\n      if (typeof type === 'string') {\n        typeObject = parseParam(type);\n      } else {\n        typeObject = deepCopy(type);\n      }\n\n      coders.push(getParamCoder(this.coerceFunc, typeObject));\n    }, this);\n    const result = new CoderTuple(this.coerceFunc, coders, '_').decode(\n      arrayify(data) || new Uint8Array(),\n      0,\n    ).value;\n    return result;\n  }\n}\n\n/** @hidden */\nexport const defaultAbiCoder: AbiCoder = new AbiCoder();\n"]}},"error":null,"hash":"ce4e7defb666e6aad00aa0d8f63df079","cacheData":{"env":{}}}