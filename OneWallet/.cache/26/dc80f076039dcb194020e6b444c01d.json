{"id":"../node_modules/@harmony-js/crypto/dist/bytes.js","dependencies":[{"name":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/crypto/dist/bytes.js.map","includedInParent":true,"mtime":499162500000},{"name":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/crypto/src/bytes.ts","includedInParent":true,"mtime":499162500000},{"name":"/home/rachit/Projects/demo/web/package.json","includedInParent":true,"mtime":1605273881149},{"name":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/crypto/package.json","includedInParent":true,"mtime":1605232158322},{"name":"tslib","loc":{"line":9,"column":22},"parent":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/crypto/dist/bytes.js","resolved":"/home/rachit/Projects/demo/node_modules/tslib/tslib.es6.js"},{"name":"./errors","loc":{"line":12,"column":42},"parent":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/crypto/dist/bytes.js","resolved":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/crypto/dist/errors.js"}],"generated":{"js":"\"use strict\";\n/**\n * @packageDocumentation\n * @module harmony-crypto\n * @hidden\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isHex = exports.hexToIntArray = exports.hexToByteArray = exports.joinSignature = exports.splitSignature = exports.isSignature = exports.bytesPadRight = exports.bytesPadLeft = exports.hexZeroPad = exports.hexStripZeros = exports.hexDataSlice = exports.hexDataLength = exports.hexlify = exports.isHexString = exports.padZeros = exports.stripZeros = exports.concat = exports.arrayify = exports.isArrayish = exports.isHexable = void 0;\nvar tslib_1 = require(\"tslib\");\n// This file is ported from ether.js/src.ts/utils/bytes.ts\n// and done some fixes\nvar errors = tslib_1.__importStar(require(\"./errors\"));\n///////////////////////////////\nfunction isHexable(value) {\n    return !!value.toHexString;\n}\nexports.isHexable = isHexable;\nfunction addSlice(array) {\n    if (typeof array === 'object' && typeof array.slice === 'function') {\n        return array;\n    }\n    // tslint:disable-next-line: only-arrow-functions\n    array.slice = function () {\n        var args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, [args[0], args[1]])));\n    };\n    return array;\n}\nfunction isArrayish(value) {\n    if (!value ||\n        // tslint:disable-next-line: radix\n        parseInt(String(value.length)) !== value.length ||\n        typeof value === 'string') {\n        return false;\n    }\n    // tslint:disable-next-line: prefer-for-of\n    for (var i = 0; i < value.length; i++) {\n        var v = value[i];\n        // tslint:disable-next-line: radix\n        if (v < 0 || v >= 256 || parseInt(String(v)) !== v) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isArrayish = isArrayish;\nfunction arrayify(value) {\n    if (value == null) {\n        errors.throwError('cannot convert null value to array', errors.INVALID_ARGUMENT, {\n            arg: 'value',\n            value: value,\n        });\n    }\n    if (isHexable(value)) {\n        value = value.toHexString();\n    }\n    if (typeof value === 'string') {\n        var match = value.match(/^(0x)?[0-9a-fA-F]*$/);\n        if (!match) {\n            errors.throwError('invalid hexidecimal string', errors.INVALID_ARGUMENT, {\n                arg: 'value',\n                value: value,\n            });\n        }\n        if (match !== null && match[1] !== '0x') {\n            errors.throwError('hex string must have 0x prefix', errors.INVALID_ARGUMENT, {\n                arg: 'value',\n                value: value,\n            });\n        }\n        value = value.substring(2);\n        if (value.length % 2) {\n            value = '0' + value;\n        }\n        var result = [];\n        for (var i = 0; i < value.length; i += 2) {\n            result.push(parseInt(value.substr(i, 2), 16));\n        }\n        return addSlice(new Uint8Array(result));\n    }\n    if (isArrayish(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n    errors.throwError('invalid arrayify value', null, {\n        arg: 'value',\n        value: value,\n        type: typeof value,\n    });\n    return null;\n}\nexports.arrayify = arrayify;\nfunction concat(objects) {\n    if (objects === null) {\n        throw new Error(\"concat objects is null\");\n    }\n    var arrays = [];\n    var length = 0;\n    // tslint:disable-next-line: prefer-for-of\n    for (var i = 0; i < objects.length; i++) {\n        var object = arrayify(objects[i]);\n        if (object == null) {\n            throw new Error('arrayify failed');\n        }\n        arrays.push(object);\n        length += object.length;\n    }\n    var result = new Uint8Array(length);\n    var offset = 0;\n    // tslint:disable-next-line: prefer-for-of\n    for (var i = 0; i < arrays.length; i++) {\n        result.set(arrays[i], offset);\n        offset += arrays[i].length;\n    }\n    return addSlice(result);\n}\nexports.concat = concat;\nfunction stripZeros(value) {\n    var result = arrayify(value);\n    if (result === null) {\n        throw new Error('arrayify failed');\n    }\n    if (result.length === 0) {\n        return result;\n    }\n    // Find the first non-zero entry\n    var start = 0;\n    while (result[start] === 0) {\n        start++;\n    }\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n    return result;\n}\nexports.stripZeros = stripZeros;\nfunction padZeros(value, length) {\n    var arrayifyValue = arrayify(value);\n    if (arrayifyValue === null) {\n        throw new Error('arrayify failed');\n    }\n    if (length < arrayifyValue.length) {\n        throw new Error('cannot pad');\n    }\n    var result = new Uint8Array(length);\n    result.set(arrayifyValue, length - arrayifyValue.length);\n    return addSlice(result);\n}\nexports.padZeros = padZeros;\nfunction isHexString(value, length) {\n    if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false;\n    }\n    if (length && value.length !== 2 + 2 * length) {\n        return false;\n    }\n    return true;\n}\nexports.isHexString = isHexString;\nvar HexCharacters = '0123456789abcdef';\nfunction hexlify(value) {\n    if (isHexable(value)) {\n        return value.toHexString();\n    }\n    if (typeof value === 'number') {\n        if (value < 0) {\n            errors.throwError('cannot hexlify negative value', errors.INVALID_ARGUMENT, {\n                arg: 'value',\n                value: value,\n            });\n        }\n        // @TODO: Roll this into the above error as a numeric fault (overflow); next version, not backward compatible\n        // We can about (value == MAX_INT) to as well, since that may indicate we underflowed already\n        if (value >= 9007199254740991) {\n            errors.throwError('out-of-range', errors.NUMERIC_FAULT, {\n                operartion: 'hexlify',\n                fault: 'out-of-safe-range',\n            });\n        }\n        var hex = '';\n        while (value) {\n            hex = HexCharacters[value & 0x0f] + hex;\n            value = Math.floor(value / 16);\n        }\n        if (hex.length) {\n            if (hex.length % 2) {\n                hex = '0' + hex;\n            }\n            return '0x' + hex;\n        }\n        return '0x00';\n    }\n    if (typeof value === 'string') {\n        var match = value.match(/^(0x)?[0-9a-fA-F]*$/);\n        if (!match) {\n            errors.throwError('invalid hexidecimal string', errors.INVALID_ARGUMENT, {\n                arg: 'value',\n                value: value,\n            });\n        }\n        if (match !== null && match[1] !== '0x') {\n            errors.throwError('hex string must have 0x prefix', errors.INVALID_ARGUMENT, {\n                arg: 'value',\n                value: value,\n            });\n        }\n        if (value.length % 2) {\n            value = '0x0' + value.substring(2);\n        }\n        return value;\n    }\n    if (isArrayish(value)) {\n        var result = [];\n        // tslint:disable-next-line: prefer-for-of\n        for (var i = 0; i < value.length; i++) {\n            var v = value[i];\n            result.push(HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f]);\n        }\n        return '0x' + result.join('');\n    }\n    errors.throwError('invalid hexlify value', null, {\n        arg: 'value',\n        value: value,\n    });\n    return 'never';\n}\nexports.hexlify = hexlify;\nfunction hexDataLength(data) {\n    if (!isHexString(data) || data.length % 2 !== 0) {\n        return null;\n    }\n    return (data.length - 2) / 2;\n}\nexports.hexDataLength = hexDataLength;\nfunction hexDataSlice(data, offset, endOffset) {\n    if (!isHexString(data)) {\n        errors.throwError('invalid hex data', errors.INVALID_ARGUMENT, {\n            arg: 'value',\n            value: data,\n        });\n    }\n    if (data.length % 2 !== 0) {\n        errors.throwError('hex data length must be even', errors.INVALID_ARGUMENT, {\n            arg: 'value',\n            value: data,\n        });\n    }\n    offset = 2 + 2 * offset;\n    if (endOffset != null) {\n        return '0x' + data.substring(offset, 2 + 2 * endOffset);\n    }\n    return '0x' + data.substring(offset);\n}\nexports.hexDataSlice = hexDataSlice;\nfunction hexStripZeros(value) {\n    if (!isHexString(value)) {\n        errors.throwError('invalid hex string', errors.INVALID_ARGUMENT, {\n            arg: 'value',\n            value: value,\n        });\n    }\n    while (value.length > 3 && value.substring(0, 3) === '0x0') {\n        value = '0x' + value.substring(3);\n    }\n    return value;\n}\nexports.hexStripZeros = hexStripZeros;\nfunction hexZeroPad(value, length) {\n    if (!isHexString(value)) {\n        errors.throwError('invalid hex string', errors.INVALID_ARGUMENT, {\n            arg: 'value',\n            value: value,\n        });\n    }\n    while (value.length < 2 * length + 2) {\n        value = '0x0' + value.substring(2);\n    }\n    return value;\n}\nexports.hexZeroPad = hexZeroPad;\nfunction bytesPadLeft(value, byteLength) {\n    if (!isHexString(value)) {\n        errors.throwError('invalid hex string', errors.INVALID_ARGUMENT, {\n            arg: 'value',\n            value: value,\n        });\n    }\n    var striped = value.substring(2);\n    if (striped.length > byteLength * 2) {\n        throw new Error(\"hex string length = \" + striped.length + \" beyond byteLength=\" + byteLength);\n    }\n    var padLength = byteLength * 2 - striped.length;\n    var returnValue = '0x' + '0'.repeat(padLength) + striped;\n    return returnValue;\n}\nexports.bytesPadLeft = bytesPadLeft;\nfunction bytesPadRight(value, byteLength) {\n    if (!isHexString(value)) {\n        errors.throwError('invalid hex string', errors.INVALID_ARGUMENT, {\n            arg: 'value',\n            value: value,\n        });\n    }\n    var striped = value.substring(2);\n    if (striped.length > byteLength * 2) {\n        throw new Error(\"hex string length = \" + striped.length + \" beyond byteLength=\" + byteLength);\n    }\n    var padLength = byteLength * 2 - striped.length;\n    var returnValue = '0x' + striped + '0'.repeat(padLength);\n    return returnValue;\n}\nexports.bytesPadRight = bytesPadRight;\nfunction isSignature(value) {\n    return value && value.r != null && value.s != null;\n}\nexports.isSignature = isSignature;\nfunction splitSignature(signature) {\n    if (signature !== undefined) {\n        var v = 0;\n        var r = '0x';\n        var s = '0x';\n        if (isSignature(signature)) {\n            if (signature.v == null && signature.recoveryParam == null) {\n                errors.throwError('at least on of recoveryParam or v must be specified', errors.INVALID_ARGUMENT, { argument: 'signature', value: signature });\n            }\n            r = hexZeroPad(signature.r, 32);\n            s = hexZeroPad(signature.s, 32);\n            v = signature.v || 0;\n            if (typeof v === 'string') {\n                v = parseInt(v, 16);\n            }\n            var recoveryParam = signature.recoveryParam || 0;\n            if (recoveryParam == null && signature.v != null) {\n                recoveryParam = 1 - (v % 2);\n            }\n            v = 27 + recoveryParam;\n        }\n        else {\n            var bytes = arrayify(signature) || new Uint8Array();\n            if (bytes.length !== 65) {\n                throw new Error('invalid signature');\n            }\n            r = hexlify(bytes.slice(0, 32));\n            s = hexlify(bytes.slice(32, 64));\n            v = bytes[64];\n            if (v !== 27 && v !== 28) {\n                v = 27 + (v % 2);\n            }\n        }\n        return {\n            r: r,\n            s: s,\n            recoveryParam: v - 27,\n            v: v,\n        };\n    }\n    else {\n        throw new Error('signature is not found');\n    }\n}\nexports.splitSignature = splitSignature;\nfunction joinSignature(signature) {\n    signature = splitSignature(signature);\n    return hexlify(concat([signature.r, signature.s, signature.recoveryParam ? '0x1c' : '0x1b']));\n}\nexports.joinSignature = joinSignature;\n/**\n * hexToByteArray\n *\n * Convers a hex string to a Uint8Array\n *\n * @param {string} hex\n * @returns {Uint8Array}\n */\nexports.hexToByteArray = function (hex) {\n    var res = new Uint8Array(hex.length / 2);\n    for (var i = 0; i < hex.length; i += 2) {\n        res[i / 2] = parseInt(hex.substring(i, i + 2), 16);\n    }\n    return res;\n};\n/**\n * hexToIntArray\n *\n * @param {string} hex\n * @returns {number[]}\n */\nexports.hexToIntArray = function (hex) {\n    if (!hex || !exports.isHex(hex)) {\n        return [];\n    }\n    var res = [];\n    for (var i = 0; i < hex.length; i++) {\n        var c = hex.charCodeAt(i);\n        var hi = c >> 8;\n        var lo = c & 0xff;\n        hi ? res.push(hi, lo) : res.push(lo);\n    }\n    return res;\n};\n/**\n * isHex\n *\n * @param {string} str - string to be tested\n * @returns {boolean}\n */\nexports.isHex = function (str) {\n    var plain = str.replace('0x', '');\n    return /[0-9a-f]*$/i.test(plain);\n};\n"},"sourceMaps":{"js":{"version":3,"file":"bytes.js","sourceRoot":"","sources":["../src/bytes.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @packageDocumentation\n * @module harmony-crypto\n * @hidden\n */\n\n// This file is ported from ether.js/src.ts/utils/bytes.ts\n// and done some fixes\n\nimport * as errors from './errors';\n\nexport type Arrayish = string | ArrayLike<number>;\n\nexport interface Hexable {\n  toHexString(): string;\n}\n\nexport interface Signature {\n  r: string;\n  s: string;\n\n  /* At least one of the following MUST be specified; the other will be derived */\n  recoveryParam?: number;\n  v?: number;\n}\n\n///////////////////////////////\n\nexport function isHexable(value: any): value is Hexable {\n  return !!value.toHexString;\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n  if (typeof array === 'object' && typeof array.slice === 'function') {\n    return array;\n  }\n\n  // tslint:disable-next-line: only-arrow-functions\n  array.slice = function() {\n    const args = Array.prototype.slice.call(arguments);\n    return addSlice(new Uint8Array(Array.prototype.slice.apply(array, [args[0], args[1]])));\n  };\n\n  return array;\n}\n\nexport function isArrayish(value: any): value is Arrayish {\n  if (\n    !value ||\n    // tslint:disable-next-line: radix\n    parseInt(String(value.length)) !== value.length ||\n    typeof value === 'string'\n  ) {\n    return false;\n  }\n\n  // tslint:disable-next-line: prefer-for-of\n  for (let i = 0; i < value.length; i++) {\n    const v = value[i];\n    // tslint:disable-next-line: radix\n    if (v < 0 || v >= 256 || parseInt(String(v)) !== v) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function arrayify(value: Arrayish | Hexable): Uint8Array | null {\n  if (value == null) {\n    errors.throwError('cannot convert null value to array', errors.INVALID_ARGUMENT, {\n      arg: 'value',\n      value,\n    });\n  }\n\n  if (isHexable(value)) {\n    value = value.toHexString();\n  }\n\n  if (typeof value === 'string') {\n    const match = value.match(/^(0x)?[0-9a-fA-F]*$/);\n\n    if (!match) {\n      errors.throwError('invalid hexidecimal string', errors.INVALID_ARGUMENT, {\n        arg: 'value',\n        value,\n      });\n    }\n\n    if (match !== null && match[1] !== '0x') {\n      errors.throwError('hex string must have 0x prefix', errors.INVALID_ARGUMENT, {\n        arg: 'value',\n        value,\n      });\n    }\n\n    value = value.substring(2);\n    if (value.length % 2) {\n      value = '0' + value;\n    }\n\n    const result = [];\n    for (let i = 0; i < value.length; i += 2) {\n      result.push(parseInt(value.substr(i, 2), 16));\n    }\n\n    return addSlice(new Uint8Array(result));\n  }\n\n  if (isArrayish(value)) {\n    return addSlice(new Uint8Array(value));\n  }\n\n  errors.throwError('invalid arrayify value', null, {\n    arg: 'value',\n    value,\n    type: typeof value,\n  });\n  return null;\n}\n\nexport function concat(objects: Arrayish[]): Uint8Array {\n  if (objects === null) {\n    throw new Error(`concat objects is null`);\n  }\n  const arrays = [];\n  let length = 0;\n  // tslint:disable-next-line: prefer-for-of\n  for (let i = 0; i < objects.length; i++) {\n    const object = arrayify(objects[i]);\n    if (object == null) {\n      throw new Error('arrayify failed');\n    }\n    arrays.push(object);\n    length += object.length;\n  }\n\n  const result = new Uint8Array(length);\n  let offset = 0;\n  // tslint:disable-next-line: prefer-for-of\n  for (let i = 0; i < arrays.length; i++) {\n    result.set(arrays[i], offset);\n    offset += arrays[i].length;\n  }\n\n  return addSlice(result);\n}\n\nexport function stripZeros(value: Arrayish): Uint8Array {\n  let result: Uint8Array | null = arrayify(value);\n\n  if (result === null) {\n    throw new Error('arrayify failed');\n  }\n\n  if (result.length === 0) {\n    return result;\n  }\n\n  // Find the first non-zero entry\n  let start = 0;\n  while (result[start] === 0) {\n    start++;\n  }\n\n  // If we started with zeros, strip them\n  if (start) {\n    result = result.slice(start);\n  }\n\n  return result;\n}\n\nexport function padZeros(value: Arrayish, length: number): Uint8Array {\n  const arrayifyValue = arrayify(value);\n  if (arrayifyValue === null) {\n    throw new Error('arrayify failed');\n  }\n  if (length < arrayifyValue.length) {\n    throw new Error('cannot pad');\n  }\n\n  const result = new Uint8Array(length);\n  result.set(arrayifyValue, length - arrayifyValue.length);\n  return addSlice(result);\n}\n\nexport function isHexString(value: any, length?: number): boolean {\n  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n    return false;\n  }\n  if (length && value.length !== 2 + 2 * length) {\n    return false;\n  }\n  return true;\n}\n\nconst HexCharacters: string = '0123456789abcdef';\n\nexport function hexlify(value: Arrayish | Hexable | number): string {\n  if (isHexable(value)) {\n    return value.toHexString();\n  }\n\n  if (typeof value === 'number') {\n    if (value < 0) {\n      errors.throwError('cannot hexlify negative value', errors.INVALID_ARGUMENT, {\n        arg: 'value',\n        value,\n      });\n    }\n\n    // @TODO: Roll this into the above error as a numeric fault (overflow); next version, not backward compatible\n    // We can about (value == MAX_INT) to as well, since that may indicate we underflowed already\n    if (value >= 9007199254740991) {\n      errors.throwError('out-of-range', errors.NUMERIC_FAULT, {\n        operartion: 'hexlify',\n        fault: 'out-of-safe-range',\n      });\n    }\n\n    let hex = '';\n    while (value) {\n      hex = HexCharacters[value & 0x0f] + hex;\n      value = Math.floor(value / 16);\n    }\n\n    if (hex.length) {\n      if (hex.length % 2) {\n        hex = '0' + hex;\n      }\n      return '0x' + hex;\n    }\n\n    return '0x00';\n  }\n\n  if (typeof value === 'string') {\n    const match = value.match(/^(0x)?[0-9a-fA-F]*$/);\n\n    if (!match) {\n      errors.throwError('invalid hexidecimal string', errors.INVALID_ARGUMENT, {\n        arg: 'value',\n        value,\n      });\n    }\n\n    if (match !== null && match[1] !== '0x') {\n      errors.throwError('hex string must have 0x prefix', errors.INVALID_ARGUMENT, {\n        arg: 'value',\n        value,\n      });\n    }\n\n    if (value.length % 2) {\n      value = '0x0' + value.substring(2);\n    }\n    return value;\n  }\n\n  if (isArrayish(value)) {\n    const result = [];\n    // tslint:disable-next-line: prefer-for-of\n    for (let i = 0; i < value.length; i++) {\n      const v = value[i];\n      result.push(HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f]);\n    }\n    return '0x' + result.join('');\n  }\n\n  errors.throwError('invalid hexlify value', null, {\n    arg: 'value',\n    value,\n  });\n  return 'never';\n}\n\nexport function hexDataLength(data: string) {\n  if (!isHexString(data) || data.length % 2 !== 0) {\n    return null;\n  }\n  return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: string, offset: number, endOffset?: number): string {\n  if (!isHexString(data)) {\n    errors.throwError('invalid hex data', errors.INVALID_ARGUMENT, {\n      arg: 'value',\n      value: data,\n    });\n  }\n  if (data.length % 2 !== 0) {\n    errors.throwError('hex data length must be even', errors.INVALID_ARGUMENT, {\n      arg: 'value',\n      value: data,\n    });\n  }\n  offset = 2 + 2 * offset;\n\n  if (endOffset != null) {\n    return '0x' + data.substring(offset, 2 + 2 * endOffset);\n  }\n\n  return '0x' + data.substring(offset);\n}\n\nexport function hexStripZeros(value: string): string {\n  if (!isHexString(value)) {\n    errors.throwError('invalid hex string', errors.INVALID_ARGUMENT, {\n      arg: 'value',\n      value,\n    });\n  }\n  while (value.length > 3 && value.substring(0, 3) === '0x0') {\n    value = '0x' + value.substring(3);\n  }\n  return value;\n}\n\nexport function hexZeroPad(value: string, length: number): string {\n  if (!isHexString(value)) {\n    errors.throwError('invalid hex string', errors.INVALID_ARGUMENT, {\n      arg: 'value',\n      value,\n    });\n  }\n\n  while (value.length < 2 * length + 2) {\n    value = '0x0' + value.substring(2);\n  }\n  return value;\n}\n\nexport function bytesPadLeft(value: string, byteLength: number): string {\n  if (!isHexString(value)) {\n    errors.throwError('invalid hex string', errors.INVALID_ARGUMENT, {\n      arg: 'value',\n      value,\n    });\n  }\n\n  const striped = value.substring(2);\n  if (striped.length > byteLength * 2) {\n    throw new Error(`hex string length = ${striped.length} beyond byteLength=${byteLength}`);\n  }\n  const padLength = byteLength * 2 - striped.length;\n  const returnValue = '0x' + '0'.repeat(padLength) + striped;\n  return returnValue;\n}\nexport function bytesPadRight(value: string, byteLength: number): string {\n  if (!isHexString(value)) {\n    errors.throwError('invalid hex string', errors.INVALID_ARGUMENT, {\n      arg: 'value',\n      value,\n    });\n  }\n\n  const striped = value.substring(2);\n  if (striped.length > byteLength * 2) {\n    throw new Error(`hex string length = ${striped.length} beyond byteLength=${byteLength}`);\n  }\n  const padLength = byteLength * 2 - striped.length;\n  const returnValue = '0x' + striped + '0'.repeat(padLength);\n  return returnValue;\n}\n\nexport function isSignature(value: any): value is Signature {\n  return value && value.r != null && value.s != null;\n}\n\nexport function splitSignature(signature: Arrayish | Signature): Signature {\n  if (signature !== undefined) {\n    let v = 0;\n    let r = '0x';\n    let s = '0x';\n\n    if (isSignature(signature)) {\n      if (signature.v == null && signature.recoveryParam == null) {\n        errors.throwError(\n          'at least on of recoveryParam or v must be specified',\n          errors.INVALID_ARGUMENT,\n          { argument: 'signature', value: signature },\n        );\n      }\n      r = hexZeroPad(signature.r, 32);\n      s = hexZeroPad(signature.s, 32);\n\n      v = signature.v || 0;\n      if (typeof v === 'string') {\n        v = parseInt(v, 16);\n      }\n\n      let recoveryParam = signature.recoveryParam || 0;\n      if (recoveryParam == null && signature.v != null) {\n        recoveryParam = 1 - (v % 2);\n      }\n      v = 27 + recoveryParam;\n    } else {\n      const bytes: Uint8Array = arrayify(signature) || new Uint8Array();\n      if (bytes.length !== 65) {\n        throw new Error('invalid signature');\n      }\n      r = hexlify(bytes.slice(0, 32));\n      s = hexlify(bytes.slice(32, 64));\n\n      v = bytes[64];\n      if (v !== 27 && v !== 28) {\n        v = 27 + (v % 2);\n      }\n    }\n\n    return {\n      r,\n      s,\n      recoveryParam: v - 27,\n      v,\n    };\n  } else {\n    throw new Error('signature is not found');\n  }\n}\n\nexport function joinSignature(signature: Signature): string {\n  signature = splitSignature(signature);\n\n  return hexlify(concat([signature.r, signature.s, signature.recoveryParam ? '0x1c' : '0x1b']));\n}\n\n/**\n * hexToByteArray\n *\n * Convers a hex string to a Uint8Array\n *\n * @param {string} hex\n * @returns {Uint8Array}\n */\nexport const hexToByteArray = (hex: string): Uint8Array => {\n  const res = new Uint8Array(hex.length / 2);\n\n  for (let i = 0; i < hex.length; i += 2) {\n    res[i / 2] = parseInt(hex.substring(i, i + 2), 16);\n  }\n\n  return res;\n};\n\n/**\n * hexToIntArray\n *\n * @param {string} hex\n * @returns {number[]}\n */\nexport const hexToIntArray = (hex: string): number[] => {\n  if (!hex || !isHex(hex)) {\n    return [];\n  }\n\n  const res = [];\n\n  for (let i = 0; i < hex.length; i++) {\n    const c = hex.charCodeAt(i);\n    const hi = c >> 8;\n    const lo = c & 0xff;\n\n    hi ? res.push(hi, lo) : res.push(lo);\n  }\n\n  return res;\n};\n\n/**\n * isHex\n *\n * @param {string} str - string to be tested\n * @returns {boolean}\n */\nexport const isHex = (str: string): boolean => {\n  const plain = str.replace('0x', '');\n  return /[0-9a-f]*$/i.test(plain);\n};\n"]}},"error":null,"hash":"2ea43ec2ff66b3a03c0e42e957ed611b","cacheData":{"env":{}}}