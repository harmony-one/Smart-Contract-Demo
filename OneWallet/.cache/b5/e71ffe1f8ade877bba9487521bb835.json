{"id":"../node_modules/@harmony-js/contract/dist/utils/mapper.js","dependencies":[{"name":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/contract/dist/utils/mapper.js.map","includedInParent":true,"mtime":499162500000},{"name":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/contract/src/utils/mapper.ts","includedInParent":true,"mtime":499162500000},{"name":"/home/rachit/Projects/demo/web/package.json","includedInParent":true,"mtime":1605273881149},{"name":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/contract/package.json","includedInParent":true,"mtime":1605275414276},{"name":"@harmony-js/utils","loc":{"line":9,"column":22},"parent":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/contract/dist/utils/mapper.js","resolved":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/utils/dist/index.js"},{"name":"../models/AbiItemModel","loc":{"line":10,"column":29},"parent":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/contract/dist/utils/mapper.js","resolved":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/contract/dist/models/AbiItemModel.js"},{"name":"../models/AbiModel","loc":{"line":11,"column":25},"parent":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/contract/dist/utils/mapper.js","resolved":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/contract/dist/models/AbiModel.js"},{"name":"../abi/utils","loc":{"line":12,"column":22},"parent":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/contract/dist/utils/mapper.js","resolved":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/contract/dist/abi/utils.js"}],"generated":{"js":"\"use strict\";\n/**\n * @packageDocumentation\n * @module harmony-contract\n * @hidden\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isPayable = exports.isConstant = exports.abiMapper = void 0;\nvar utils_1 = require(\"@harmony-js/utils\");\nvar AbiItemModel_1 = require(\"../models/AbiItemModel\");\nvar AbiModel_1 = require(\"../models/AbiModel\");\nvar utils_2 = require(\"../abi/utils\");\nexports.abiMapper = function (abi, abiCoder) {\n    var mappedAbiItems = {\n        methods: {},\n        events: {},\n    };\n    var hasConstructor = false;\n    abi.forEach(function (abiItem) {\n        abiItem.constant = exports.isConstant(abiItem);\n        abiItem.payable = exports.isPayable(abiItem);\n        if (abiItem.name) {\n            abiItem.funcName = utils_2.jsonInterfaceMethodToString(abiItem);\n        }\n        var abiItemModel;\n        if (abiItem.type === 'function') {\n            abiItem.signature = abiCoder.encodeFunctionSignature(abiItem.funcName);\n            abiItemModel = new AbiItemModel_1.AbiItem(abiItem);\n            // Check if an method already exists with this name and if it exists than create an array and push this abiItem\n            // into it. This will be used if there are methods with the same name but with different arguments.\n            if (!mappedAbiItems.methods[abiItem.name]) {\n                mappedAbiItems.methods[abiItem.name] = abiItemModel;\n            }\n            else {\n                if (utils_1.isArray(mappedAbiItems.methods[abiItem.name])) {\n                    mappedAbiItems.methods[abiItem.name].push(abiItemModel);\n                }\n                else {\n                    mappedAbiItems.methods[abiItem.name] = [\n                        mappedAbiItems.methods[abiItem.name],\n                        abiItemModel,\n                    ];\n                }\n            }\n            mappedAbiItems.methods[abiItem.signature] = abiItemModel;\n            mappedAbiItems.methods[abiItem.funcName] = abiItemModel;\n            return;\n        }\n        if (abiItem.type === 'event') {\n            abiItem.signature = abiCoder.encodeEventSignature(abiItem.funcName);\n            abiItemModel = new AbiItemModel_1.AbiItem(abiItem);\n            if (!mappedAbiItems.events[abiItem.name] ||\n                mappedAbiItems.events[abiItem.name].name === 'bound ') {\n                mappedAbiItems.events[abiItem.name] = abiItemModel;\n            }\n            mappedAbiItems.events[abiItem.signature] = abiItemModel;\n            mappedAbiItems.events[abiItem.funcName] = abiItemModel;\n        }\n        if (abiItem.type === 'constructor') {\n            abiItem.signature = abiItem.type;\n            // tslint:disable-next-line: no-string-literal\n            mappedAbiItems.methods['contractConstructor'] = new AbiItemModel_1.AbiItem(abiItem);\n            hasConstructor = true;\n        }\n    });\n    if (!hasConstructor) {\n        // tslint:disable-next-line: no-string-literal\n        mappedAbiItems.methods['contractConstructor'] = new AbiItemModel_1.AbiItem({\n            inputs: [],\n            payable: false,\n            constant: false,\n            type: 'constructor',\n        });\n    }\n    return new AbiModel_1.AbiModel(mappedAbiItems);\n};\nexports.isConstant = function (abiItem) {\n    return (abiItem.stateMutability === 'view' || abiItem.stateMutability === 'pure' || abiItem.constant);\n};\nexports.isPayable = function (abiItem) {\n    return abiItem.stateMutability === 'payable' || abiItem.payable;\n};\n"},"sourceMaps":{"js":{"version":3,"file":"mapper.js","sourceRoot":"","sources":["../../src/utils/mapper.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @packageDocumentation\n * @module harmony-contract\n * @hidden\n */\n\nimport { isArray } from '@harmony-js/utils';\nimport { AbiItem } from '../models/AbiItemModel';\nimport { AbiModel } from '../models/AbiModel';\nimport { AbiItemModel } from '../models/types';\nimport { jsonInterfaceMethodToString } from '../abi/utils';\nimport { AbiCoderClass } from '../abi/api';\n\nexport const abiMapper = (abi: any[], abiCoder: AbiCoderClass): AbiModel => {\n  const mappedAbiItems: any = {\n    methods: {},\n    events: {},\n  };\n  let hasConstructor = false;\n\n  abi.forEach((abiItem: AbiItemModel) => {\n    abiItem.constant = isConstant(abiItem);\n    abiItem.payable = isPayable(abiItem);\n\n    if (abiItem.name) {\n      abiItem.funcName = jsonInterfaceMethodToString(abiItem);\n    }\n\n    let abiItemModel;\n\n    if (abiItem.type === 'function') {\n      abiItem.signature = abiCoder.encodeFunctionSignature(abiItem.funcName);\n\n      abiItemModel = new AbiItem(abiItem);\n\n      // Check if an method already exists with this name and if it exists than create an array and push this abiItem\n      // into it. This will be used if there are methods with the same name but with different arguments.\n      if (!mappedAbiItems.methods[abiItem.name]) {\n        mappedAbiItems.methods[abiItem.name] = abiItemModel;\n      } else {\n        if (isArray(mappedAbiItems.methods[abiItem.name])) {\n          mappedAbiItems.methods[abiItem.name].push(abiItemModel);\n        } else {\n          mappedAbiItems.methods[abiItem.name] = [\n            mappedAbiItems.methods[abiItem.name],\n            abiItemModel,\n          ];\n        }\n      }\n\n      mappedAbiItems.methods[abiItem.signature] = abiItemModel;\n      mappedAbiItems.methods[abiItem.funcName] = abiItemModel;\n\n      return;\n    }\n\n    if (abiItem.type === 'event') {\n      abiItem.signature = abiCoder.encodeEventSignature(abiItem.funcName);\n\n      abiItemModel = new AbiItem(abiItem);\n\n      if (\n        !mappedAbiItems.events[abiItem.name] ||\n        mappedAbiItems.events[abiItem.name].name === 'bound '\n      ) {\n        mappedAbiItems.events[abiItem.name] = abiItemModel;\n      }\n\n      mappedAbiItems.events[abiItem.signature] = abiItemModel;\n      mappedAbiItems.events[abiItem.funcName] = abiItemModel;\n    }\n\n    if (abiItem.type === 'constructor') {\n      abiItem.signature = abiItem.type;\n      // tslint:disable-next-line: no-string-literal\n      mappedAbiItems.methods['contractConstructor'] = new AbiItem(abiItem);\n\n      hasConstructor = true;\n    }\n  });\n  if (!hasConstructor) {\n    // tslint:disable-next-line: no-string-literal\n    mappedAbiItems.methods['contractConstructor'] = new AbiItem({\n      inputs: [],\n      payable: false,\n      constant: false,\n      type: 'constructor',\n    });\n  }\n  return new AbiModel(mappedAbiItems);\n};\n\nexport const isConstant = (abiItem: AbiItemModel) => {\n  return (\n    abiItem.stateMutability === 'view' || abiItem.stateMutability === 'pure' || abiItem.constant\n  );\n};\n\nexport const isPayable = (abiItem: AbiItemModel) => {\n  return abiItem.stateMutability === 'payable' || abiItem.payable;\n};\n"]}},"error":null,"hash":"0d18b7c4e4fd533aa39eac10b6ecd0a7","cacheData":{"env":{}}}