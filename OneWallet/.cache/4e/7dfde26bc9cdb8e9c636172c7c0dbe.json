{"id":"../node_modules/@harmony-js/crypto/dist/keyTool.js","dependencies":[{"name":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/crypto/dist/keyTool.js.map","includedInParent":true,"mtime":499162500000},{"name":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/crypto/src/keyTool.ts","includedInParent":true,"mtime":499162500000},{"name":"/home/rachit/Projects/demo/web/package.json","includedInParent":true,"mtime":1605273881149},{"name":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/crypto/package.json","includedInParent":true,"mtime":1605232158322},{"name":"tslib","loc":{"line":8,"column":22},"parent":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/crypto/dist/keyTool.js","resolved":"/home/rachit/Projects/demo/node_modules/tslib/tslib.es6.js"},{"name":"elliptic","loc":{"line":9,"column":49},"parent":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/crypto/dist/keyTool.js","resolved":"/home/rachit/Projects/demo/web/node_modules/elliptic/lib/elliptic.js"},{"name":"./bytes","loc":{"line":10,"column":41},"parent":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/crypto/dist/keyTool.js","resolved":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/crypto/dist/bytes.js"},{"name":"./errors","loc":{"line":11,"column":42},"parent":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/crypto/dist/keyTool.js","resolved":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/crypto/dist/errors.js"},{"name":"./keccak256","loc":{"line":12,"column":26},"parent":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/crypto/dist/keyTool.js","resolved":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/crypto/dist/keccak256.js"},{"name":"./random","loc":{"line":13,"column":23},"parent":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/crypto/dist/keyTool.js","resolved":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/crypto/dist/random.js"},{"name":"@harmony-js/utils","loc":{"line":14,"column":22},"parent":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/crypto/dist/keyTool.js","resolved":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/utils/dist/index.js"},{"name":"./bech32","loc":{"line":15,"column":23},"parent":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/crypto/dist/keyTool.js","resolved":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/crypto/dist/bech32.js"},{"name":"./rlp","loc":{"line":16,"column":20},"parent":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/crypto/dist/keyTool.js","resolved":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/crypto/dist/rlp.js"}],"generated":{"js":"\"use strict\";\n/**\n * @packageDocumentation\n * @module harmony-crypto\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validatePrivateKey = exports.isValidChecksumAddress = exports.recoverAddress = exports.recoverPublicKey = exports.verifySignature = exports.getContractAddress = exports.sign = exports.toChecksumAddress = exports.getAddressFromPublicKey = exports.getPublic = exports.getAddressFromPrivateKey = exports.getPubkeyFromPrivateKey = exports.generatePrivateKey = void 0;\nvar tslib_1 = require(\"tslib\");\nvar elliptic_1 = tslib_1.__importDefault(require(\"elliptic\"));\nvar bytes = tslib_1.__importStar(require(\"./bytes\"));\nvar errors = tslib_1.__importStar(require(\"./errors\"));\nvar keccak256_1 = require(\"./keccak256\");\nvar random_1 = require(\"./random\");\nvar utils_1 = require(\"@harmony-js/utils\");\nvar bech32_1 = require(\"./bech32\");\nvar rlp_1 = require(\"./rlp\");\nvar secp256k1 = elliptic_1.default.ec('secp256k1');\n/**\n * @function generatePrivateKey\n * @description generatePrivate key using `eth-lib` settings\n * @return {string}\n */\nexports.generatePrivateKey = function () {\n    var entropy = '0x' + random_1.randomBytes(16);\n    var innerHex = keccak256_1.keccak256(bytes.concat(['0x' + random_1.randomBytes(32), entropy || '0x' + random_1.randomBytes(32)]));\n    var middleHex = bytes.concat([\n        bytes.concat(['0x' + random_1.randomBytes(32), innerHex]),\n        '0x' + random_1.randomBytes(32),\n    ]);\n    var outerHex = keccak256_1.keccak256(middleHex);\n    return outerHex;\n};\n/**\n * @function getPubkeyFromPrivateKey\n * @param  {string} privateKey - private key String\n * @return {string}\n */\nexports.getPubkeyFromPrivateKey = function (privateKey) {\n    return '0x' + exports.getPublic(privateKey, true);\n};\n/**\n * @function getAddressFromPrivateKey\n * @param  {string} privateKey - private key string\n * @return {string} address with `length = 40`\n */\nexports.getAddressFromPrivateKey = function (privateKey) {\n    var publicHash = '0x' + exports.getPublic(privateKey).slice(2);\n    var publicKey = keccak256_1.keccak256(publicHash);\n    var address = '0x' + publicKey.slice(-40);\n    return address;\n};\nexports.getPublic = function (privateKey, compress) {\n    if (!utils_1.isPrivateKey(privateKey) || !exports.validatePrivateKey(privateKey)) {\n        throw new Error(privateKey + \" is not PrivateKey\");\n    }\n    var ecKey = secp256k1.keyFromPrivate(utils_1.strip0x(privateKey), 'hex');\n    return ecKey.getPublic(compress || false, 'hex');\n};\n/**\n * @function getAddressFromPublicKey\n * @param  {string} publicKey - public key string\n * @return {string} address with `length = 40`\n */\nexports.getAddressFromPublicKey = function (publicKey) {\n    var ecKey = secp256k1.keyFromPublic(publicKey.slice(2), 'hex');\n    var publicHash = ecKey.getPublic(false, 'hex');\n    var address = '0x' + keccak256_1.keccak256('0x' + publicHash.slice(2)).slice(-40);\n    return address;\n};\n/**\n * @function toChecksumAddress\n * @param  {string} address - raw address\n * @return {string} checksumed address\n */\nexports.toChecksumAddress = function (address) {\n    if (typeof address === 'string' && utils_1.isBech32Address(address)) {\n        address = bech32_1.fromBech32(address);\n    }\n    if (typeof address !== 'string' || !address.match(/^0x[0-9A-Fa-f]{40}$/)) {\n        errors.throwError('invalid address', errors.INVALID_ARGUMENT, {\n            arg: 'address',\n            value: address,\n        });\n    }\n    address = address.toLowerCase();\n    var chars = address.substring(2).split('');\n    var hashed = new Uint8Array(40);\n    for (var i = 0; i < 40; i++) {\n        hashed[i] = chars[i].charCodeAt(0);\n    }\n    hashed = bytes.arrayify(keccak256_1.keccak256(hashed)) || hashed;\n    for (var i = 0; i < 40; i += 2) {\n        if (hashed[i >> 1] >> 4 >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n    return '0x' + chars.join('');\n};\nexports.sign = function (digest, privateKey) {\n    if (!utils_1.isPrivateKey(privateKey)) {\n        throw new Error(privateKey + \" is not PrivateKey\");\n    }\n    var keyPair = secp256k1.keyFromPrivate(utils_1.strip0x(privateKey), 'hex');\n    var signature = keyPair.sign(bytes.arrayify(digest), { canonical: true });\n    var publicKey = '0x' + keyPair.getPublic(true, 'hex');\n    var result = {\n        recoveryParam: signature.recoveryParam,\n        r: bytes.hexZeroPad('0x' + signature.r.toString(16), 32),\n        s: bytes.hexZeroPad('0x' + signature.s.toString(16), 32),\n        v: 27 + signature.recoveryParam,\n    };\n    if (verifySignature(digest, result, publicKey)) {\n        return result;\n    }\n    else {\n        throw new Error('signing process failed');\n    }\n};\nfunction getContractAddress(from, nonce) {\n    if (!from) {\n        throw new Error('missing from address');\n    }\n    var addr = keccak256_1.keccak256(rlp_1.encode([from, bytes.stripZeros(bytes.hexlify(nonce))]));\n    return '0x' + addr.substring(26);\n}\nexports.getContractAddress = getContractAddress;\nfunction verifySignature(digest, signature, publicKey) {\n    return recoverPublicKey(digest, signature) === publicKey;\n}\nexports.verifySignature = verifySignature;\nfunction recoverPublicKey(digest, signature) {\n    var sig = bytes.splitSignature(signature);\n    var rs = { r: bytes.arrayify(sig.r), s: bytes.arrayify(sig.s) };\n    ////\n    var recovered = secp256k1.recoverPubKey(bytes.arrayify(digest), rs, sig.recoveryParam);\n    var key = recovered.encode('hex', false);\n    var ecKey = secp256k1.keyFromPublic(key, 'hex');\n    var publicKey = '0x' + ecKey.getPublic(true, 'hex');\n    ///\n    return publicKey;\n}\nexports.recoverPublicKey = recoverPublicKey;\nfunction recoverAddress(digest, signature) {\n    return exports.getAddressFromPublicKey(recoverPublicKey(bytes.arrayify(digest) || new Uint8Array(), signature));\n}\nexports.recoverAddress = recoverAddress;\n/**\n * isValidChecksumAddress\n *\n * takes hex-encoded string and returns boolean if address is checksumed\n *\n * @param {string} address\n * @returns {boolean}\n */\nexports.isValidChecksumAddress = function (address) {\n    return utils_1.isAddress(address.replace('0x', '')) && exports.toChecksumAddress(address) === address;\n};\nexports.validatePrivateKey = function (privateKey) {\n    var ecKey = secp256k1.keyFromPrivate(utils_1.strip0x(privateKey), 'hex');\n    var result = ecKey.validate().result;\n    return result;\n};\n"},"sourceMaps":{"js":{"version":3,"file":"keyTool.js","sourceRoot":"","sources":["../src/keyTool.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @packageDocumentation\n * @module harmony-crypto\n */\n\nimport elliptic from 'elliptic';\nimport * as bytes from './bytes';\nimport * as errors from './errors';\n\nimport { keccak256 } from './keccak256';\nimport { randomBytes } from './random';\nimport { isPrivateKey, strip0x, isAddress, isBech32Address } from '@harmony-js/utils';\nimport { fromBech32 } from './bech32';\nimport { encode } from './rlp';\n\nconst secp256k1 = elliptic.ec('secp256k1');\n\n/**\n * @function generatePrivateKey\n * @description generatePrivate key using `eth-lib` settings\n * @return {string}\n */\nexport const generatePrivateKey = (): string => {\n  const entropy: string = '0x' + randomBytes(16);\n\n  const innerHex: string = keccak256(\n    bytes.concat(['0x' + randomBytes(32), entropy || '0x' + randomBytes(32)]),\n  );\n  const middleHex: Uint8Array = bytes.concat([\n    bytes.concat(['0x' + randomBytes(32), innerHex]),\n    '0x' + randomBytes(32),\n  ]);\n  const outerHex: string = keccak256(middleHex);\n  return outerHex;\n};\n\n/**\n * @function getPubkeyFromPrivateKey\n * @param  {string} privateKey - private key String\n * @return {string}\n */\nexport const getPubkeyFromPrivateKey = (privateKey: string): string => {\n  return '0x' + getPublic(privateKey, true);\n};\n\n/**\n * @function getAddressFromPrivateKey\n * @param  {string} privateKey - private key string\n * @return {string} address with `length = 40`\n */\nexport const getAddressFromPrivateKey = (privateKey: string): string => {\n  const publicHash = '0x' + getPublic(privateKey).slice(2);\n  const publicKey = keccak256(publicHash);\n  const address = '0x' + publicKey.slice(-40);\n  return address;\n};\n\nexport const getPublic = (privateKey: string, compress?: boolean): string => {\n  if (!isPrivateKey(privateKey) || !validatePrivateKey(privateKey)) {\n    throw new Error(`${privateKey} is not PrivateKey`);\n  }\n  const ecKey = secp256k1.keyFromPrivate(strip0x(privateKey), 'hex');\n\n  return ecKey.getPublic(compress || false, 'hex');\n};\n\n/**\n * @function getAddressFromPublicKey\n * @param  {string} publicKey - public key string\n * @return {string} address with `length = 40`\n */\nexport const getAddressFromPublicKey = (publicKey: string): string => {\n  const ecKey = secp256k1.keyFromPublic(publicKey.slice(2), 'hex');\n  const publicHash = ecKey.getPublic(false, 'hex');\n  const address = '0x' + keccak256('0x' + publicHash.slice(2)).slice(-40);\n  return address;\n};\n\n/**\n * @function toChecksumAddress\n * @param  {string} address - raw address\n * @return {string} checksumed address\n */\nexport const toChecksumAddress = (address: string): string => {\n  if (typeof address === 'string' && isBech32Address(address)) {\n    address = fromBech32(address);\n  }\n  if (typeof address !== 'string' || !address.match(/^0x[0-9A-Fa-f]{40}$/)) {\n    errors.throwError('invalid address', errors.INVALID_ARGUMENT, {\n      arg: 'address',\n      value: address,\n    });\n  }\n\n  address = address.toLowerCase();\n\n  const chars = address.substring(2).split('');\n\n  let hashed = new Uint8Array(40);\n  for (let i = 0; i < 40; i++) {\n    hashed[i] = chars[i].charCodeAt(0);\n  }\n  hashed = bytes.arrayify(keccak256(hashed)) || hashed;\n\n  for (let i = 0; i < 40; i += 2) {\n    if (hashed[i >> 1] >> 4 >= 8) {\n      chars[i] = chars[i].toUpperCase();\n    }\n    if ((hashed[i >> 1] & 0x0f) >= 8) {\n      chars[i + 1] = chars[i + 1].toUpperCase();\n    }\n  }\n\n  return '0x' + chars.join('');\n};\n\nexport const sign = (digest: bytes.Arrayish | string, privateKey: string): bytes.Signature => {\n  if (!isPrivateKey(privateKey)) {\n    throw new Error(`${privateKey} is not PrivateKey`);\n  }\n\n  const keyPair = secp256k1.keyFromPrivate(strip0x(privateKey), 'hex');\n  const signature = keyPair.sign(bytes.arrayify(digest), { canonical: true });\n  const publicKey = '0x' + keyPair.getPublic(true, 'hex');\n  const result = {\n    recoveryParam: signature.recoveryParam,\n    r: bytes.hexZeroPad('0x' + signature.r.toString(16), 32),\n    s: bytes.hexZeroPad('0x' + signature.s.toString(16), 32),\n    v: 27 + signature.recoveryParam,\n  };\n\n  if (verifySignature(digest, result, publicKey)) {\n    return result;\n  } else {\n    throw new Error('signing process failed');\n  }\n};\n\nexport function getContractAddress(from: string, nonce: number): string {\n  if (!from) {\n    throw new Error('missing from address');\n  }\n\n  const addr = keccak256(encode([from, bytes.stripZeros(bytes.hexlify(nonce))]));\n  return '0x' + addr.substring(26);\n}\n\nexport function verifySignature(\n  digest: bytes.Arrayish,\n  signature: bytes.Signature,\n  publicKey: string,\n): boolean {\n  return recoverPublicKey(digest, signature) === publicKey;\n}\n\nexport function recoverPublicKey(\n  digest: bytes.Arrayish | string,\n  signature: bytes.Signature | string,\n): string {\n  const sig = bytes.splitSignature(signature);\n  const rs = { r: bytes.arrayify(sig.r), s: bytes.arrayify(sig.s) };\n\n  ////\n  const recovered = secp256k1.recoverPubKey(bytes.arrayify(digest), rs, sig.recoveryParam);\n\n  const key = recovered.encode('hex', false);\n  const ecKey = secp256k1.keyFromPublic(key, 'hex');\n  const publicKey = '0x' + ecKey.getPublic(true, 'hex');\n\n  ///\n\n  return publicKey;\n}\n\nexport function recoverAddress(\n  digest: bytes.Arrayish | string,\n  signature: bytes.Signature | string,\n): string {\n  return getAddressFromPublicKey(\n    recoverPublicKey(bytes.arrayify(digest) || new Uint8Array(), signature),\n  );\n}\n\n/**\n * isValidChecksumAddress\n *\n * takes hex-encoded string and returns boolean if address is checksumed\n *\n * @param {string} address\n * @returns {boolean}\n */\nexport const isValidChecksumAddress = (address: string): boolean => {\n  return isAddress(address.replace('0x', '')) && toChecksumAddress(address) === address;\n};\n\nexport const validatePrivateKey = (privateKey: string): boolean => {\n  const ecKey = secp256k1.keyFromPrivate(strip0x(privateKey), 'hex');\n  const { result } = ecKey.validate();\n  return result;\n};\n"]}},"error":null,"hash":"d2ba7e7b3ffbbfd2d6cd8ade739c5f8a","cacheData":{"env":{}}}