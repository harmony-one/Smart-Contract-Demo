{"id":"../node_modules/@harmony-js/utils/dist/utils.js","dependencies":[{"name":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/utils/dist/utils.js.map","includedInParent":true,"mtime":499162500000},{"name":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/utils/src/utils.ts","includedInParent":true,"mtime":499162500000},{"name":"/home/rachit/Projects/demo/web/package.json","includedInParent":true,"mtime":1605273881149},{"name":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/utils/package.json","includedInParent":true,"mtime":1605232158218},{"name":"./validators","loc":{"line":8,"column":27},"parent":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/utils/dist/utils.js","resolved":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/utils/dist/validators.js"}],"generated":{"js":"\"use strict\";\n/**\n * @packageDocumentation\n * @module harmony-utils\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.assertObject = exports.generateValidateObjects = exports.validateArgs = exports.validatorArray = exports.AssertType = void 0;\nvar validators_1 = require(\"./validators\");\n/** @hidden */\nvar AssertType;\n(function (AssertType) {\n    AssertType[\"required\"] = \"required\";\n    AssertType[\"optional\"] = \"optional\";\n})(AssertType = exports.AssertType || (exports.AssertType = {}));\n/** @hidden */\nexports.validatorArray = {\n    isNumber: [validators_1.isNumber],\n    isString: [validators_1.isString],\n    isBoolean: [validators_1.isBoolean],\n    isArray: [validators_1.isArray],\n    isJsonString: [validators_1.isJsonString],\n    isObject: [validators_1.isObject],\n    isFunction: [validators_1.isFunction],\n    isHex: [validators_1.isHex],\n    isPublicKey: [validators_1.isPublicKey],\n    isPrivateKey: [validators_1.isPrivateKey],\n    isAddress: [validators_1.isAddress],\n    isHash: [validators_1.isHash],\n    isBlockNumber: [validators_1.isBlockNumber],\n    isBech32Address: [validators_1.isBech32Address],\n    isBech32TestNetAddress: [validators_1.isBech32TestNetAddress],\n    isValidAddress: [validators_1.isValidAddress],\n};\nfunction validateArgs(args, requiredArgs, optionalArgs) {\n    for (var key in requiredArgs) {\n        if (args[key] !== undefined) {\n            // tslint:disable-next-line: prefer-for-of\n            for (var i = 0; i < requiredArgs[key].length; i += 1) {\n                if (typeof requiredArgs[key][i] !== 'function') {\n                    throw new Error('Validator is not a function');\n                }\n                if (!requiredArgs[key][i](args[key])) {\n                    throw new Error(\"Validation failed for \" + key + \",should be validated by \" + requiredArgs[key][i].validator);\n                }\n            }\n        }\n        else {\n            throw new Error(\"Key not found: \" + key);\n        }\n    }\n    for (var key in optionalArgs) {\n        if (args[key]) {\n            // tslint:disable-next-line: prefer-for-of\n            for (var i = 0; i < optionalArgs[key].length; i += 1) {\n                if (typeof optionalArgs[key][i] !== 'function') {\n                    throw new Error('Validator is not a function');\n                }\n                if (!optionalArgs[key][i](args[key])) {\n                    throw new Error(\"Validation failed for \" + key + \",should be validated by \" + optionalArgs[key][i].validator);\n                }\n            }\n        }\n    }\n    return true;\n}\nexports.validateArgs = validateArgs;\nfunction generateValidateObjects(validatorObject) {\n    var requiredArgs = {};\n    var optionalArgs = {};\n    for (var index in validatorObject) {\n        if (index !== undefined) {\n            var newObjectKey = index;\n            var newObjectValid = validatorObject[index][0];\n            var isRequired = validatorObject[index][1];\n            if (isRequired === AssertType.required) {\n                requiredArgs[newObjectKey] = exports.validatorArray[newObjectValid];\n            }\n            else {\n                optionalArgs[newObjectKey] = exports.validatorArray[newObjectValid];\n            }\n        }\n    }\n    return { requiredArgs: requiredArgs, optionalArgs: optionalArgs };\n}\nexports.generateValidateObjects = generateValidateObjects;\nvar assertObject = function (input) { return function (target, key, descriptor) {\n    var _a = generateValidateObjects(input), requiredArgs = _a.requiredArgs, optionalArgs = _a.optionalArgs;\n    var original = descriptor.value;\n    function interceptor() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        validateArgs(args[0], requiredArgs, optionalArgs);\n        return original.apply(this, args);\n    }\n    descriptor.value = interceptor;\n    return descriptor;\n}; };\nexports.assertObject = assertObject;\n"},"sourceMaps":{"js":{"version":3,"file":"utils.js","sourceRoot":"","sources":["../src/utils.ts"],"names":[],"mappings":";AAAA;;;GAGG;;;AAEH,2CAiBsB;AAEtB,cAAc;AACd,IAAY,UAGX;AAHD,WAAY,UAAU;IACpB,mCAAqB,CAAA;IACrB,mCAAqB,CAAA;AACvB,CAAC,EAHW,UAAU,GAAV,kBAAU,KAAV,kBAAU,QAGrB;AAED,cAAc;AACD,QAAA,cAAc,GAAQ;IACjC,QAAQ,EAAE,CAAC,qBAAQ,CAAC;IACpB,QAAQ,EAAE,CAAC,qBAAQ,CAAC;IACpB,SAAS,EAAE,CAAC,sBAAS,CAAC;IACtB,OAAO,EAAE,CAAC,oBAAO,CAAC;IAClB,YAAY,EAAE,CAAC,yBAAY,CAAC;IAC5B,QAAQ,EAAE,CAAC,qBAAQ,CAAC;IACpB,UAAU,EAAE,CAAC,uBAAU,CAAC;IACxB,KAAK,EAAE,CAAC,kBAAK,CAAC;IACd,WAAW,EAAE,CAAC,wBAAW,CAAC;IAC1B,YAAY,EAAE,CAAC,yBAAY,CAAC;IAC5B,SAAS,EAAE,CAAC,sBAAS,CAAC;IACtB,MAAM,EAAE,CAAC,mBAAM,CAAC;IAChB,aAAa,EAAE,CAAC,0BAAa,CAAC;IAC9B,eAAe,EAAE,CAAC,4BAAe,CAAC;IAClC,sBAAsB,EAAE,CAAC,mCAAsB,CAAC;IAChD,cAAc,EAAE,CAAC,2BAAc,CAAC;CACjC,CAAC;AAEF,SAAgB,YAAY,CAAC,IAAS,EAAE,YAAiB,EAAE,YAAiB;IAC1E,KAAK,IAAM,GAAG,IAAI,YAAY,EAAE;QAC9B,IAAI,IAAI,CAAC,GAAG,CAAC,KAAK,SAAS,EAAE;YAC3B,0CAA0C;YAC1C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,EAAE;gBACpD,IAAI,OAAO,YAAY,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;oBAC9C,MAAM,IAAI,KAAK,CAAC,6BAA6B,CAAC,CAAC;iBAChD;gBAED,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE;oBACpC,MAAM,IAAI,KAAK,CACb,2BAAyB,GAAG,gCAA2B,YAAY,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,SAAW,CACxF,CAAC;iBACH;aACF;SACF;aAAM;YACL,MAAM,IAAI,KAAK,CAAC,oBAAkB,GAAK,CAAC,CAAC;SAC1C;KACF;IAED,KAAK,IAAM,GAAG,IAAI,YAAY,EAAE;QAC9B,IAAI,IAAI,CAAC,GAAG,CAAC,EAAE;YACb,0CAA0C;YAC1C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,EAAE;gBACpD,IAAI,OAAO,YAAY,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;oBAC9C,MAAM,IAAI,KAAK,CAAC,6BAA6B,CAAC,CAAC;iBAChD;gBAED,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE;oBACpC,MAAM,IAAI,KAAK,CACb,2BAAyB,GAAG,gCAA2B,YAAY,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,SAAW,CACxF,CAAC;iBACH;aACF;SACF;KACF;IACD,OAAO,IAAI,CAAC;AACd,CAAC;AArCD,oCAqCC;AAED,SAAgB,uBAAuB,CAAC,eAAuC;IAC7E,IAAM,YAAY,GAAQ,EAAE,CAAC;IAC7B,IAAM,YAAY,GAAQ,EAAE,CAAC;IAC7B,KAAK,IAAM,KAAK,IAAI,eAAe,EAAE;QACnC,IAAI,KAAK,KAAK,SAAS,EAAE;YACvB,IAAM,YAAY,GAAG,KAAK,CAAC;YAC3B,IAAM,cAAc,GAAG,eAAe,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;YACjD,IAAM,UAAU,GAAG,eAAe,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;YAC7C,IAAI,UAAU,KAAK,UAAU,CAAC,QAAQ,EAAE;gBACtC,YAAY,CAAC,YAAY,CAAC,GAAG,sBAAc,CAAC,cAAc,CAAC,CAAC;aAC7D;iBAAM;gBACL,YAAY,CAAC,YAAY,CAAC,GAAG,sBAAc,CAAC,cAAc,CAAC,CAAC;aAC7D;SACF;KACF;IACD,OAAO,EAAE,YAAY,cAAA,EAAE,YAAY,cAAA,EAAE,CAAC;AACxC,CAAC;AAhBD,0DAgBC;AAED,IAAM,YAAY,GAAG,UAAC,KAAU,IAAK,OAAA,UAAC,MAAW,EAAE,GAAQ,EAAE,UAA8B;IACnF,IAAA,KAAiC,uBAAuB,CAAC,KAAK,CAAC,EAA7D,YAAY,kBAAA,EAAE,YAAY,kBAAmC,CAAC;IACtE,IAAM,QAAQ,GAAG,UAAU,CAAC,KAAK,CAAC;IAClC,SAAS,WAAW;QAAY,cAAc;aAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;YAAd,yBAAc;;QAC5C,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,YAAY,EAAE,YAAY,CAAC,CAAC;QAClD,OAAO,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;IACpC,CAAC;IACD,UAAU,CAAC,KAAK,GAAG,WAAW,CAAC;IAC/B,OAAO,UAAU,CAAC;AACpB,CAAC,EAToC,CASpC,CAAC;AAEO,oCAAY","sourcesContent":["/**\n * @packageDocumentation\n * @module harmony-utils\n */\n\nimport {\n  isNumber,\n  isString,\n  isBoolean,\n  isArray,\n  isJsonString,\n  isHex,\n  isObject,\n  isFunction,\n  isPublicKey,\n  isPrivateKey,\n  isAddress,\n  isBech32Address,\n  isBech32TestNetAddress,\n  isValidAddress,\n  isHash,\n  isBlockNumber,\n} from './validators';\n\n/** @hidden */\nexport enum AssertType {\n  required = 'required',\n  optional = 'optional',\n}\n\n/** @hidden */\nexport const validatorArray: any = {\n  isNumber: [isNumber],\n  isString: [isString],\n  isBoolean: [isBoolean],\n  isArray: [isArray],\n  isJsonString: [isJsonString],\n  isObject: [isObject],\n  isFunction: [isFunction],\n  isHex: [isHex],\n  isPublicKey: [isPublicKey],\n  isPrivateKey: [isPrivateKey],\n  isAddress: [isAddress],\n  isHash: [isHash],\n  isBlockNumber: [isBlockNumber],\n  isBech32Address: [isBech32Address],\n  isBech32TestNetAddress: [isBech32TestNetAddress],\n  isValidAddress: [isValidAddress],\n};\n\nexport function validateArgs(args: any, requiredArgs: any, optionalArgs: any): boolean {\n  for (const key in requiredArgs) {\n    if (args[key] !== undefined) {\n      // tslint:disable-next-line: prefer-for-of\n      for (let i = 0; i < requiredArgs[key].length; i += 1) {\n        if (typeof requiredArgs[key][i] !== 'function') {\n          throw new Error('Validator is not a function');\n        }\n\n        if (!requiredArgs[key][i](args[key])) {\n          throw new Error(\n            `Validation failed for ${key},should be validated by ${requiredArgs[key][i].validator}`,\n          );\n        }\n      }\n    } else {\n      throw new Error(`Key not found: ${key}`);\n    }\n  }\n\n  for (const key in optionalArgs) {\n    if (args[key]) {\n      // tslint:disable-next-line: prefer-for-of\n      for (let i = 0; i < optionalArgs[key].length; i += 1) {\n        if (typeof optionalArgs[key][i] !== 'function') {\n          throw new Error('Validator is not a function');\n        }\n\n        if (!optionalArgs[key][i](args[key])) {\n          throw new Error(\n            `Validation failed for ${key},should be validated by ${optionalArgs[key][i].validator}`,\n          );\n        }\n      }\n    }\n  }\n  return true;\n}\n\nexport function generateValidateObjects(validatorObject: { [x: string]: any[] }) {\n  const requiredArgs: any = {};\n  const optionalArgs: any = {};\n  for (const index in validatorObject) {\n    if (index !== undefined) {\n      const newObjectKey = index;\n      const newObjectValid = validatorObject[index][0];\n      const isRequired = validatorObject[index][1];\n      if (isRequired === AssertType.required) {\n        requiredArgs[newObjectKey] = validatorArray[newObjectValid];\n      } else {\n        optionalArgs[newObjectKey] = validatorArray[newObjectValid];\n      }\n    }\n  }\n  return { requiredArgs, optionalArgs };\n}\n\nconst assertObject = (input: any) => (target: any, key: any, descriptor: PropertyDescriptor) => {\n  const { requiredArgs, optionalArgs } = generateValidateObjects(input);\n  const original = descriptor.value;\n  function interceptor(this: any, ...args: any[]) {\n    validateArgs(args[0], requiredArgs, optionalArgs);\n    return original.apply(this, args);\n  }\n  descriptor.value = interceptor;\n  return descriptor;\n};\n\nexport { assertObject };\n"]}},"error":null,"hash":"a68bd475a7ed9f705f1f14f294ad393b","cacheData":{"env":{}}}