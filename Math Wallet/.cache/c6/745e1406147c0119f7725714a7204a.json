{"id":"../node_modules/@harmony-js/transaction/dist/transactionBase.js","dependencies":[{"name":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/transaction/dist/transactionBase.js.map","includedInParent":true,"mtime":499162500000},{"name":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/transaction/src/transactionBase.ts","includedInParent":true,"mtime":499162500000},{"name":"/home/rachit/Projects/demo/web Math Wallet/package.json","includedInParent":true,"mtime":1605273881149},{"name":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/transaction/package.json","includedInParent":true,"mtime":1605232158322},{"name":"tslib","loc":{"line":9,"column":22},"parent":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/transaction/dist/transactionBase.js","resolved":"/home/rachit/Projects/demo/node_modules/tslib/tslib.es6.js"},{"name":"@harmony-js/crypto","loc":{"line":10,"column":23},"parent":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/transaction/dist/transactionBase.js","resolved":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/crypto/dist/index.js"},{"name":"@harmony-js/utils","loc":{"line":11,"column":22},"parent":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/transaction/dist/transactionBase.js","resolved":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/utils/dist/index.js"},{"name":"@harmony-js/network","loc":{"line":12,"column":24},"parent":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/transaction/dist/transactionBase.js","resolved":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/network/dist/index.js"},{"name":"./types","loc":{"line":13,"column":22},"parent":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/transaction/dist/transactionBase.js","resolved":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/transaction/dist/types.js"},{"name":"./utils","loc":{"line":14,"column":22},"parent":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/transaction/dist/transactionBase.js","resolved":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/transaction/dist/utils.js"}],"generated":{"js":"\"use strict\";\n/**\n * @packageDocumentation\n * @module harmony-transaction\n * @hidden\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TransactionBase = void 0;\nvar tslib_1 = require(\"tslib\");\nvar crypto_1 = require(\"@harmony-js/crypto\");\nvar utils_1 = require(\"@harmony-js/utils\");\nvar network_1 = require(\"@harmony-js/network\");\nvar types_1 = require(\"./types\");\nvar utils_2 = require(\"./utils\");\nvar TransactionBase = /** @class */ (function () {\n    function TransactionBase(messenger, txStatus) {\n        this.blockNumbers = [];\n        this.confirmations = 0;\n        this.confirmationCheck = 0;\n        this.cxStatus = types_1.TxStatus.INTIALIZED;\n        this.cxBlockNumbers = [];\n        this.cxConfirmations = 0;\n        this.cxConfirmationCheck = 0;\n        this.messenger = messenger;\n        this.txStatus = txStatus;\n        this.emitter = new network_1.Emitter();\n        this.id = '0x';\n        this.shardID = this.messenger.currentShard;\n    }\n    TransactionBase.normalizeAddress = function (address) {\n        if (address === '0x') {\n            return '0x';\n        }\n        else if (crypto_1.HarmonyAddress.isValidChecksum(address) ||\n            crypto_1.HarmonyAddress.isValidBech32(address) ||\n            crypto_1.HarmonyAddress.isValidBech32TestNet(address)) {\n            return crypto_1.getAddress(address).checksum;\n        }\n        else {\n            throw new Error(\"Address format is not supported\");\n        }\n    };\n    TransactionBase.prototype.setMessenger = function (messenger) {\n        this.messenger = messenger;\n    };\n    TransactionBase.prototype.setTxStatus = function (txStatus) {\n        this.txStatus = txStatus;\n    };\n    TransactionBase.prototype.getTxStatus = function () {\n        return this.txStatus;\n    };\n    TransactionBase.prototype.setCxStatus = function (cxStatus) {\n        this.cxStatus = cxStatus;\n    };\n    TransactionBase.prototype.getCxStatus = function () {\n        return this.cxStatus;\n    };\n    // get status\n    TransactionBase.prototype.isInitialized = function () {\n        return this.getTxStatus() === types_1.TxStatus.INTIALIZED;\n    };\n    TransactionBase.prototype.isSigned = function () {\n        return this.getTxStatus() === types_1.TxStatus.SIGNED;\n    };\n    TransactionBase.prototype.isPending = function () {\n        return this.getTxStatus() === types_1.TxStatus.PENDING;\n    };\n    TransactionBase.prototype.isRejected = function () {\n        return this.getTxStatus() === types_1.TxStatus.REJECTED;\n    };\n    TransactionBase.prototype.isConfirmed = function () {\n        return this.getTxStatus() === types_1.TxStatus.CONFIRMED;\n    };\n    TransactionBase.prototype.isCxPending = function () {\n        return this.getCxStatus() === types_1.TxStatus.PENDING;\n    };\n    TransactionBase.prototype.isCxRejected = function () {\n        return this.getCxStatus() === types_1.TxStatus.REJECTED;\n    };\n    TransactionBase.prototype.isCxConfirmed = function () {\n        return this.getCxStatus() === types_1.TxStatus.CONFIRMED;\n    };\n    TransactionBase.prototype.observed = function () {\n        return this.emitter;\n    };\n    TransactionBase.prototype.trackTx = function (txHash, shardID) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var res, currentBlock, currentBlock;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this.messenger) {\n                            throw new Error('Messenger not found');\n                        }\n                        return [4 /*yield*/, this.messenger.send(network_1.RPCMethod.GetTransactionReceipt, txHash, this.messenger.chainType, typeof shardID === 'string' ? Number.parseInt(shardID, 10) : shardID)];\n                    case 1:\n                        res = _a.sent();\n                        if (!(res.isResult() && res.result !== null)) return [3 /*break*/, 5];\n                        this.receipt = res.result;\n                        this.emitReceipt(this.receipt);\n                        this.id = res.result.transactionHash;\n                        this.confirmations += 1;\n                        if (!this.receipt) return [3 /*break*/, 2];\n                        if (this.receipt.status && this.receipt.status === '0x1') {\n                            this.receipt.byzantium = true;\n                            this.txStatus = types_1.TxStatus.CONFIRMED;\n                        }\n                        else if (this.receipt.status && this.receipt.status === '0x0') {\n                            this.receipt.byzantium = true;\n                            this.txStatus = types_1.TxStatus.REJECTED;\n                        }\n                        else if (this.receipt.status === undefined && this.receipt.root) {\n                            this.receipt.byzantium = false;\n                            this.txStatus = types_1.TxStatus.CONFIRMED;\n                        }\n                        return [2 /*return*/, true];\n                    case 2:\n                        this.txStatus = types_1.TxStatus.PENDING;\n                        return [4 /*yield*/, this.getBlockNumber(shardID)];\n                    case 3:\n                        currentBlock = _a.sent();\n                        this.blockNumbers.push('0x' + currentBlock.toString('hex'));\n                        this.confirmationCheck += 1;\n                        return [2 /*return*/, false];\n                    case 4: return [3 /*break*/, 7];\n                    case 5:\n                        this.txStatus = types_1.TxStatus.PENDING;\n                        return [4 /*yield*/, this.getBlockNumber(shardID)];\n                    case 6:\n                        currentBlock = _a.sent();\n                        this.blockNumbers.push('0x' + currentBlock.toString('hex'));\n                        this.confirmationCheck += 1;\n                        return [2 /*return*/, false];\n                    case 7: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    TransactionBase.prototype.txConfirm = function (txHash, maxAttempts, interval, shardID) {\n        if (maxAttempts === void 0) { maxAttempts = 20; }\n        if (interval === void 0) { interval = 1000; }\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var oldBlock, checkBlock, attempt, newBlock, nextBlock, err_1, result, error_1;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!(this.messenger.provider instanceof network_1.HttpProvider)) return [3 /*break*/, 13];\n                        this.txStatus = types_1.TxStatus.PENDING;\n                        return [4 /*yield*/, this.getBlockNumber(shardID)];\n                    case 1:\n                        oldBlock = _a.sent();\n                        checkBlock = oldBlock;\n                        attempt = 0;\n                        _a.label = 2;\n                    case 2:\n                        if (!(attempt < maxAttempts)) return [3 /*break*/, 12];\n                        _a.label = 3;\n                    case 3:\n                        _a.trys.push([3, 8, , 9]);\n                        return [4 /*yield*/, this.getBlockNumber(shardID)];\n                    case 4:\n                        newBlock = _a.sent();\n                        nextBlock = checkBlock.add(new crypto_1.BN(attempt === 0 ? attempt : 1));\n                        if (!newBlock.gte(nextBlock)) return [3 /*break*/, 6];\n                        checkBlock = newBlock;\n                        this.emitTrack({\n                            txHash: txHash,\n                            attempt: attempt,\n                            currentBlock: checkBlock.toString(),\n                            shardID: shardID,\n                        });\n                        return [4 /*yield*/, this.trackTx(txHash, shardID)];\n                    case 5:\n                        if (_a.sent()) {\n                            this.emitConfirm(this.txStatus);\n                            return [2 /*return*/, this];\n                        }\n                        return [3 /*break*/, 7];\n                    case 6:\n                        attempt = attempt - 1 >= 0 ? attempt - 1 : 0;\n                        _a.label = 7;\n                    case 7: return [3 /*break*/, 9];\n                    case 8:\n                        err_1 = _a.sent();\n                        this.txStatus = types_1.TxStatus.REJECTED;\n                        this.emitConfirm(this.txStatus);\n                        throw err_1;\n                    case 9:\n                        if (!(attempt + 1 < maxAttempts)) return [3 /*break*/, 11];\n                        // await sleep(interval * attempt);\n                        return [4 /*yield*/, utils_2.sleep(interval)];\n                    case 10:\n                        // await sleep(interval * attempt);\n                        _a.sent();\n                        _a.label = 11;\n                    case 11:\n                        attempt += 1;\n                        return [3 /*break*/, 2];\n                    case 12:\n                        this.txStatus = types_1.TxStatus.REJECTED;\n                        this.emitConfirm(this.txStatus);\n                        throw new Error(\"The transaction is still not confirmed after \" + maxAttempts + \" attempts.\");\n                    case 13:\n                        _a.trys.push([13, 18, , 19]);\n                        return [4 /*yield*/, this.trackTx(txHash, shardID)];\n                    case 14:\n                        if (!_a.sent()) return [3 /*break*/, 15];\n                        this.emitConfirm(this.txStatus);\n                        return [2 /*return*/, this];\n                    case 15: return [4 /*yield*/, this.socketConfirm(txHash, maxAttempts, shardID)];\n                    case 16:\n                        result = _a.sent();\n                        return [2 /*return*/, result];\n                    case 17: return [3 /*break*/, 19];\n                    case 18:\n                        error_1 = _a.sent();\n                        this.txStatus = types_1.TxStatus.REJECTED;\n                        this.emitConfirm(this.txStatus);\n                        throw new Error(\"The transaction is still not confirmed after \" + maxAttempts * interval + \" mil seconds.\");\n                    case 19: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    TransactionBase.prototype.socketConfirm = function (txHash, maxAttempts, shardID) {\n        var _this = this;\n        if (maxAttempts === void 0) { maxAttempts = 20; }\n        return new Promise(function (resolve, reject) {\n            var newHeads = Promise.resolve(new network_1.NewHeaders(_this.messenger, typeof shardID === 'string' ? Number.parseInt(shardID, 10) : shardID));\n            newHeads.then(function (p) {\n                p.onData(function (data) { return tslib_1.__awaiter(_this, void 0, void 0, function () {\n                    var blockNumber;\n                    return tslib_1.__generator(this, function (_a) {\n                        switch (_a.label) {\n                            case 0:\n                                blockNumber = this.messenger.chainPrefix === 'hmy'\n                                    ? data.params.result.Header.number\n                                    : data.params.result.number;\n                                this.emitTrack({\n                                    txHash: txHash,\n                                    attempt: this.confirmationCheck,\n                                    currentBlock: utils_1.hexToNumber(blockNumber),\n                                    shardID: shardID,\n                                });\n                                if (!!this.blockNumbers.includes(blockNumber)) return [3 /*break*/, 5];\n                                return [4 /*yield*/, this.trackTx(txHash, shardID)];\n                            case 1:\n                                if (!_a.sent()) return [3 /*break*/, 3];\n                                this.emitConfirm(this.txStatus);\n                                return [4 /*yield*/, p.unsubscribe()];\n                            case 2:\n                                _a.sent();\n                                resolve(this);\n                                return [3 /*break*/, 5];\n                            case 3:\n                                if (!(this.confirmationCheck === maxAttempts)) return [3 /*break*/, 5];\n                                this.txStatus = types_1.TxStatus.REJECTED;\n                                this.emitConfirm(this.txStatus);\n                                return [4 /*yield*/, p.unsubscribe()];\n                            case 4:\n                                _a.sent();\n                                resolve(this);\n                                _a.label = 5;\n                            case 5: return [2 /*return*/];\n                        }\n                    });\n                }); }).onError(function (error) { return tslib_1.__awaiter(_this, void 0, void 0, function () {\n                    return tslib_1.__generator(this, function (_a) {\n                        switch (_a.label) {\n                            case 0:\n                                this.txStatus = types_1.TxStatus.REJECTED;\n                                this.emitConfirm(this.txStatus);\n                                this.emitError(error);\n                                return [4 /*yield*/, p.unsubscribe()];\n                            case 1:\n                                _a.sent();\n                                reject(error);\n                                return [2 /*return*/];\n                        }\n                    });\n                }); });\n            });\n        });\n    };\n    TransactionBase.prototype.emitTransactionHash = function (transactionHash) {\n        this.emitter.emit(utils_2.TransactionEvents.transactionHash, transactionHash);\n    };\n    TransactionBase.prototype.emitReceipt = function (receipt) {\n        this.emitter.emit(utils_2.TransactionEvents.receipt, receipt);\n    };\n    TransactionBase.prototype.emitError = function (error) {\n        this.emitter.emit(utils_2.TransactionEvents.error, error);\n    };\n    TransactionBase.prototype.emitConfirm = function (data) {\n        this.emitter.emit(utils_2.TransactionEvents.confirmation, data);\n    };\n    TransactionBase.prototype.emitTrack = function (data) {\n        this.emitter.emit(utils_2.TransactionEvents.track, data);\n    };\n    TransactionBase.prototype.emitCxReceipt = function (receipt) {\n        this.emitter.emit(utils_2.TransactionEvents.cxReceipt, receipt);\n    };\n    TransactionBase.prototype.emitCxConfirm = function (data) {\n        this.emitter.emit(utils_2.TransactionEvents.cxConfirmation, data);\n    };\n    TransactionBase.prototype.emitCxTrack = function (data) {\n        this.emitter.emit(utils_2.TransactionEvents.cxTrack, data);\n    };\n    TransactionBase.prototype.getBlockNumber = function (shardID) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var currentBlock, error_2;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, this.messenger.send(network_1.RPCMethod.BlockNumber, [], this.messenger.chainPrefix, typeof shardID === 'string' ? Number.parseInt(shardID, 10) : shardID)];\n                    case 1:\n                        currentBlock = _a.sent();\n                        if (currentBlock.isError()) {\n                            throw currentBlock.message;\n                        }\n                        return [2 /*return*/, new crypto_1.BN(currentBlock.result.replace('0x', ''), 'hex')];\n                    case 2:\n                        error_2 = _a.sent();\n                        throw error_2;\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    TransactionBase.prototype.getBlockByNumber = function (blockNumber) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var block, error_3;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, this.messenger.send(network_1.RPCMethod.GetBlockByNumber, [blockNumber, true], this.messenger.chainPrefix, typeof this.shardID === 'string' ? Number.parseInt(this.shardID, 10) : this.shardID)];\n                    case 1:\n                        block = _a.sent();\n                        if (block.isError()) {\n                            throw block.message;\n                        }\n                        return [2 /*return*/, block.result];\n                    case 2:\n                        error_3 = _a.sent();\n                        throw error_3;\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    TransactionBase.prototype.cxConfirm = function (txHash, maxAttempts, interval, toShardID) {\n        if (maxAttempts === void 0) { maxAttempts = 20; }\n        if (interval === void 0) { interval = 1000; }\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var oldBlock, checkBlock, attempt, newBlock, nextBlock, err_2, result, error_4;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!(this.messenger.provider instanceof network_1.HttpProvider)) return [3 /*break*/, 13];\n                        return [4 /*yield*/, this.getBlockNumber(toShardID)];\n                    case 1:\n                        oldBlock = _a.sent();\n                        checkBlock = oldBlock;\n                        attempt = 0;\n                        _a.label = 2;\n                    case 2:\n                        if (!(attempt < maxAttempts)) return [3 /*break*/, 12];\n                        _a.label = 3;\n                    case 3:\n                        _a.trys.push([3, 8, , 9]);\n                        return [4 /*yield*/, this.getBlockNumber(toShardID)];\n                    case 4:\n                        newBlock = _a.sent();\n                        nextBlock = checkBlock.add(new crypto_1.BN(attempt === 0 ? attempt : 1));\n                        if (!newBlock.gte(nextBlock)) return [3 /*break*/, 6];\n                        checkBlock = newBlock;\n                        this.emitCxTrack({\n                            txHash: txHash,\n                            attempt: attempt,\n                            currentBlock: checkBlock.toString(),\n                            toShardID: toShardID,\n                        });\n                        return [4 /*yield*/, this.trackCx(txHash, toShardID)];\n                    case 5:\n                        if (_a.sent()) {\n                            this.emitCxConfirm(this.cxStatus);\n                            return [2 /*return*/, this];\n                        }\n                        return [3 /*break*/, 7];\n                    case 6:\n                        attempt = attempt - 1 >= 0 ? attempt - 1 : 0;\n                        _a.label = 7;\n                    case 7: return [3 /*break*/, 9];\n                    case 8:\n                        err_2 = _a.sent();\n                        this.cxStatus = types_1.TxStatus.REJECTED;\n                        this.emitCxConfirm(this.cxStatus);\n                        throw err_2;\n                    case 9:\n                        if (!(attempt + 1 < maxAttempts)) return [3 /*break*/, 11];\n                        return [4 /*yield*/, utils_2.sleep(interval)];\n                    case 10:\n                        _a.sent();\n                        _a.label = 11;\n                    case 11:\n                        attempt += 1;\n                        return [3 /*break*/, 2];\n                    case 12:\n                        this.cxStatus = types_1.TxStatus.REJECTED;\n                        this.emitCxConfirm(this.cxStatus);\n                        throw new Error(\"The transaction is still not confirmed after \" + maxAttempts + \" attempts.\");\n                    case 13:\n                        _a.trys.push([13, 18, , 19]);\n                        return [4 /*yield*/, this.trackCx(txHash, toShardID)];\n                    case 14:\n                        if (!_a.sent()) return [3 /*break*/, 15];\n                        this.emitCxConfirm(this.cxStatus);\n                        return [2 /*return*/, this];\n                    case 15: return [4 /*yield*/, this.socketCxConfirm(txHash, maxAttempts, toShardID)];\n                    case 16:\n                        result = _a.sent();\n                        return [2 /*return*/, result];\n                    case 17: return [3 /*break*/, 19];\n                    case 18:\n                        error_4 = _a.sent();\n                        this.cxStatus = types_1.TxStatus.REJECTED;\n                        this.emitCxConfirm(this.cxStatus);\n                        throw new Error(\"The transaction is still not confirmed after \" + maxAttempts * interval + \" mil seconds.\");\n                    case 19: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    TransactionBase.prototype.trackCx = function (txHash, toShardID) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var res, currentBlock;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this.messenger) {\n                            throw new Error('Messenger not found');\n                        }\n                        return [4 /*yield*/, this.messenger.send(network_1.RPCMethod.GetCXReceiptByHash, txHash, this.messenger.chainPrefix, typeof toShardID === 'string' ? Number.parseInt(toShardID, 10) : toShardID)];\n                    case 1:\n                        res = _a.sent();\n                        if (!(res.isResult() && res.result !== null)) return [3 /*break*/, 2];\n                        this.emitCxReceipt(res.result);\n                        this.cxStatus = types_1.TxStatus.CONFIRMED;\n                        return [2 /*return*/, true];\n                    case 2: return [4 /*yield*/, this.getBlockNumber(toShardID)];\n                    case 3:\n                        currentBlock = _a.sent();\n                        this.cxBlockNumbers.push('0x' + currentBlock.toString('hex'));\n                        this.cxConfirmationCheck += 1;\n                        this.cxStatus = types_1.TxStatus.PENDING;\n                        return [2 /*return*/, false];\n                }\n            });\n        });\n    };\n    TransactionBase.prototype.socketCxConfirm = function (txHash, maxAttempts, toShardID) {\n        var _this = this;\n        if (maxAttempts === void 0) { maxAttempts = 20; }\n        return new Promise(function (resolve, reject) {\n            var newHeads = Promise.resolve(new network_1.NewHeaders(_this.messenger, typeof toShardID === 'string' ? Number.parseInt(toShardID, 10) : toShardID));\n            newHeads.then(function (p) {\n                p.onData(function (data) { return tslib_1.__awaiter(_this, void 0, void 0, function () {\n                    var blockNumber;\n                    return tslib_1.__generator(this, function (_a) {\n                        switch (_a.label) {\n                            case 0:\n                                blockNumber = this.messenger.chainPrefix === 'hmy'\n                                    ? data.params.result.Header.number\n                                    : data.params.result.number;\n                                this.emitCxTrack({\n                                    txHash: txHash,\n                                    attempt: this.cxConfirmationCheck,\n                                    currentBlock: utils_1.hexToNumber(blockNumber),\n                                    toShardID: toShardID,\n                                });\n                                if (!!this.blockNumbers.includes(blockNumber)) return [3 /*break*/, 5];\n                                return [4 /*yield*/, this.trackCx(txHash, toShardID)];\n                            case 1:\n                                if (!_a.sent()) return [3 /*break*/, 3];\n                                this.emitCxConfirm(this.cxStatus);\n                                return [4 /*yield*/, p.unsubscribe()];\n                            case 2:\n                                _a.sent();\n                                resolve(this);\n                                return [3 /*break*/, 5];\n                            case 3:\n                                if (!(this.cxConfirmationCheck === maxAttempts)) return [3 /*break*/, 5];\n                                this.cxStatus = types_1.TxStatus.REJECTED;\n                                this.emitCxConfirm(this.cxStatus);\n                                return [4 /*yield*/, p.unsubscribe()];\n                            case 4:\n                                _a.sent();\n                                resolve(this);\n                                _a.label = 5;\n                            case 5: return [2 /*return*/];\n                        }\n                    });\n                }); }).onError(function (error) { return tslib_1.__awaiter(_this, void 0, void 0, function () {\n                    return tslib_1.__generator(this, function (_a) {\n                        switch (_a.label) {\n                            case 0:\n                                this.cxStatus = types_1.TxStatus.REJECTED;\n                                this.emitCxConfirm(this.cxStatus);\n                                this.emitError(error);\n                                return [4 /*yield*/, p.unsubscribe()];\n                            case 1:\n                                _a.sent();\n                                reject(error);\n                                return [2 /*return*/];\n                        }\n                    });\n                }); });\n            });\n        });\n    };\n    return TransactionBase;\n}());\nexports.TransactionBase = TransactionBase;\n"},"sourceMaps":{"js":{"version":3,"file":"transactionBase.js","sourceRoot":"","sources":["../src/transactionBase.ts"],"names":[],"mappings":";AAAA;;;;GAIG;;;;AAEH,6CAAoE;AACpE,2CAAgD;AAChD,+CAA8F;AAC9F,iCAAwD;AACxD,iCAAmD;AAGnD;IA6BE,yBAAY,SAAoB,EAAE,QAAkB;QAZpD,iBAAY,GAAa,EAAE,CAAC;QAC5B,kBAAa,GAAW,CAAC,CAAC;QAC1B,sBAAiB,GAAW,CAAC,CAAC;QAC9B,aAAQ,GAAa,gBAAQ,CAAC,UAAU,CAAC;QACzC,mBAAc,GAAa,EAAE,CAAC;QAC9B,oBAAe,GAAW,CAAC,CAAC;QAC5B,wBAAmB,GAAW,CAAC,CAAC;QAO9B,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;QAC3B,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,OAAO,GAAG,IAAI,iBAAO,EAAE,CAAC;QAC7B,IAAI,CAAC,EAAE,GAAG,IAAI,CAAC;QACf,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC;IAC7C,CAAC;IAlCM,gCAAgB,GAAvB,UAAwB,OAAe;QACrC,IAAI,OAAO,KAAK,IAAI,EAAE;YACpB,OAAO,IAAI,CAAC;SACb;aAAM,IACL,uBAAc,CAAC,eAAe,CAAC,OAAO,CAAC;YACvC,uBAAc,CAAC,aAAa,CAAC,OAAO,CAAC;YACrC,uBAAc,CAAC,oBAAoB,CAAC,OAAO,CAAC,EAC5C;YACA,OAAO,mBAAU,CAAC,OAAO,CAAC,CAAC,QAAQ,CAAC;SACrC;aAAM;YACL,MAAM,IAAI,KAAK,CAAC,iCAAiC,CAAC,CAAC;SACpD;IACH,CAAC;IAwBD,sCAAY,GAAZ,UAAa,SAAoB;QAC/B,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;IAC7B,CAAC;IAED,qCAAW,GAAX,UAAY,QAAkB;QAC5B,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;IAC3B,CAAC;IAED,qCAAW,GAAX;QACE,OAAO,IAAI,CAAC,QAAQ,CAAC;IACvB,CAAC;IACD,qCAAW,GAAX,UAAY,QAAkB;QAC5B,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;IAC3B,CAAC;IAED,qCAAW,GAAX;QACE,OAAO,IAAI,CAAC,QAAQ,CAAC;IACvB,CAAC;IAED,aAAa;IACb,uCAAa,GAAb;QACE,OAAO,IAAI,CAAC,WAAW,EAAE,KAAK,gBAAQ,CAAC,UAAU,CAAC;IACpD,CAAC;IACD,kCAAQ,GAAR;QACE,OAAO,IAAI,CAAC,WAAW,EAAE,KAAK,gBAAQ,CAAC,MAAM,CAAC;IAChD,CAAC;IACD,mCAAS,GAAT;QACE,OAAO,IAAI,CAAC,WAAW,EAAE,KAAK,gBAAQ,CAAC,OAAO,CAAC;IACjD,CAAC;IACD,oCAAU,GAAV;QACE,OAAO,IAAI,CAAC,WAAW,EAAE,KAAK,gBAAQ,CAAC,QAAQ,CAAC;IAClD,CAAC;IACD,qCAAW,GAAX;QACE,OAAO,IAAI,CAAC,WAAW,EAAE,KAAK,gBAAQ,CAAC,SAAS,CAAC;IACnD,CAAC;IACD,qCAAW,GAAX;QACE,OAAO,IAAI,CAAC,WAAW,EAAE,KAAK,gBAAQ,CAAC,OAAO,CAAC;IACjD,CAAC;IACD,sCAAY,GAAZ;QACE,OAAO,IAAI,CAAC,WAAW,EAAE,KAAK,gBAAQ,CAAC,QAAQ,CAAC;IAClD,CAAC;IACD,uCAAa,GAAb;QACE,OAAO,IAAI,CAAC,WAAW,EAAE,KAAK,gBAAQ,CAAC,SAAS,CAAC;IACnD,CAAC;IACD,kCAAQ,GAAR;QACE,OAAO,IAAI,CAAC,OAAO,CAAC;IACtB,CAAC;IAEK,iCAAO,GAAb,UAAc,MAAc,EAAE,OAAwB;;;;;;wBACpD,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;4BACnB,MAAM,IAAI,KAAK,CAAC,qBAAqB,CAAC,CAAC;yBACxC;wBAEW,qBAAM,IAAI,CAAC,SAAS,CAAC,IAAI,CACnC,mBAAS,CAAC,qBAAqB,EAC/B,MAAM,EACN,IAAI,CAAC,SAAS,CAAC,SAAS,EACxB,OAAO,OAAO,KAAK,QAAQ,CAAC,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,OAAO,CACrE,EAAA;;wBALK,GAAG,GAAG,SAKX;6BACG,CAAA,GAAG,CAAC,QAAQ,EAAE,IAAI,GAAG,CAAC,MAAM,KAAK,IAAI,CAAA,EAArC,wBAAqC;wBACvC,IAAI,CAAC,OAAO,GAAG,GAAG,CAAC,MAAM,CAAC;wBAC1B,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;wBAC/B,IAAI,CAAC,EAAE,GAAG,GAAG,CAAC,MAAM,CAAC,eAAe,CAAC;wBACrC,IAAI,CAAC,aAAa,IAAI,CAAC,CAAC;6BAEpB,IAAI,CAAC,OAAO,EAAZ,wBAAY;wBACd,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,KAAK,KAAK,EAAE;4BACxD,IAAI,CAAC,OAAO,CAAC,SAAS,GAAG,IAAI,CAAC;4BAC9B,IAAI,CAAC,QAAQ,GAAG,gBAAQ,CAAC,SAAS,CAAC;yBACpC;6BAAM,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,KAAK,KAAK,EAAE;4BAC/D,IAAI,CAAC,OAAO,CAAC,SAAS,GAAG,IAAI,CAAC;4BAC9B,IAAI,CAAC,QAAQ,GAAG,gBAAQ,CAAC,QAAQ,CAAC;yBACnC;6BAAM,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,KAAK,SAAS,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE;4BACjE,IAAI,CAAC,OAAO,CAAC,SAAS,GAAG,KAAK,CAAC;4BAC/B,IAAI,CAAC,QAAQ,GAAG,gBAAQ,CAAC,SAAS,CAAC;yBACpC;wBACD,sBAAO,IAAI,EAAC;;wBAEZ,IAAI,CAAC,QAAQ,GAAG,gBAAQ,CAAC,OAAO,CAAC;wBACZ,qBAAM,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,EAAA;;wBAAjD,YAAY,GAAG,SAAkC;wBAEvD,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,GAAG,YAAY,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC;wBAE5D,IAAI,CAAC,iBAAiB,IAAI,CAAC,CAAC;wBAC5B,sBAAO,KAAK,EAAC;;;wBAGf,IAAI,CAAC,QAAQ,GAAG,gBAAQ,CAAC,OAAO,CAAC;wBACZ,qBAAM,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,EAAA;;wBAAjD,YAAY,GAAG,SAAkC;wBACvD,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,GAAG,YAAY,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC;wBAC5D,IAAI,CAAC,iBAAiB,IAAI,CAAC,CAAC;wBAC5B,sBAAO,KAAK,EAAC;;;;;KAEhB;IAEK,mCAAS,GAAf,UACE,MAAc,EACd,WAAwB,EACxB,QAAuB,EACvB,OAAwB;QAFxB,4BAAA,EAAA,gBAAwB;QACxB,yBAAA,EAAA,eAAuB;;;;;;6BAGnB,CAAA,IAAI,CAAC,SAAS,CAAC,QAAQ,YAAY,sBAAY,CAAA,EAA/C,yBAA+C;wBACjD,IAAI,CAAC,QAAQ,GAAG,gBAAQ,CAAC,OAAO,CAAC;wBAChB,qBAAM,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,EAAA;;wBAA7C,QAAQ,GAAG,SAAkC;wBAC/C,UAAU,GAAG,QAAQ,CAAC;wBAEjB,OAAO,GAAG,CAAC;;;6BAAE,CAAA,OAAO,GAAG,WAAW,CAAA;;;;wBAEtB,qBAAM,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,EAAA;;wBAA7C,QAAQ,GAAG,SAAkC;wBAE7C,SAAS,GAAG,UAAU,CAAC,GAAG,CAAC,IAAI,WAAE,CAAC,OAAO,KAAK,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;6BAElE,QAAQ,CAAC,GAAG,CAAC,SAAS,CAAC,EAAvB,wBAAuB;wBACzB,UAAU,GAAG,QAAQ,CAAC;wBACtB,IAAI,CAAC,SAAS,CAAC;4BACb,MAAM,QAAA;4BACN,OAAO,SAAA;4BACP,YAAY,EAAE,UAAU,CAAC,QAAQ,EAAE;4BACnC,OAAO,SAAA;yBACR,CAAC,CAAC;wBAEC,qBAAM,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,OAAO,CAAC,EAAA;;wBAAvC,IAAI,SAAmC,EAAE;4BACvC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;4BAChC,sBAAO,IAAI,EAAC;yBACb;;;wBAED,OAAO,GAAG,OAAO,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;;;;;wBAG/C,IAAI,CAAC,QAAQ,GAAG,gBAAQ,CAAC,QAAQ,CAAC;wBAClC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;wBAChC,MAAM,KAAG,CAAC;;6BAGR,CAAA,OAAO,GAAG,CAAC,GAAG,WAAW,CAAA,EAAzB,yBAAyB;wBAC3B,mCAAmC;wBACnC,qBAAM,aAAK,CAAC,QAAQ,CAAC,EAAA;;wBADrB,mCAAmC;wBACnC,SAAqB,CAAC;;;wBA9BmB,OAAO,IAAI,CAAC,CAAA;;;wBAiCzD,IAAI,CAAC,QAAQ,GAAG,gBAAQ,CAAC,QAAQ,CAAC;wBAClC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;wBAChC,MAAM,IAAI,KAAK,CAAC,kDAAgD,WAAW,eAAY,CAAC,CAAC;;;wBAGnF,qBAAM,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,OAAO,CAAC,EAAA;;6BAAnC,SAAmC,EAAnC,yBAAmC;wBACrC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;wBAChC,sBAAO,IAAI,EAAC;6BAEG,qBAAM,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE,WAAW,EAAE,OAAO,CAAC,EAAA;;wBAA/D,MAAM,GAAG,SAAsD;wBACrE,sBAAO,MAAM,EAAC;;;;wBAGhB,IAAI,CAAC,QAAQ,GAAG,gBAAQ,CAAC,QAAQ,CAAC;wBAClC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;wBAChC,MAAM,IAAI,KAAK,CACb,kDAAgD,WAAW,GAAG,QAAQ,kBAAe,CACtF,CAAC;;;;;KAGP;IAED,uCAAa,GAAb,UACE,MAAc,EACd,WAAwB,EACxB,OAAwB;QAH1B,iBA+CC;QA7CC,4BAAA,EAAA,gBAAwB;QAGxB,OAAO,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;YACjC,IAAM,QAAQ,GAAG,OAAO,CAAC,OAAO,CAC9B,IAAI,oBAAU,CACZ,KAAI,CAAC,SAAS,EACd,OAAO,OAAO,KAAK,QAAQ,CAAC,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,OAAO,CACrE,CACF,CAAC;YACF,QAAQ,CAAC,IAAI,CAAC,UAAC,CAAC;gBACd,CAAC,CAAC,MAAM,CAAC,UAAO,IAAS;;;;;gCACjB,WAAW,GACf,IAAI,CAAC,SAAS,CAAC,WAAW,KAAK,KAAK;oCAClC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM;oCAClC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC;gCAChC,IAAI,CAAC,SAAS,CAAC;oCACb,MAAM,QAAA;oCACN,OAAO,EAAE,IAAI,CAAC,iBAAiB;oCAC/B,YAAY,EAAE,mBAAW,CAAC,WAAW,CAAC;oCACtC,OAAO,SAAA;iCACR,CAAC,CAAC;qCACC,CAAC,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,WAAW,CAAC,EAAxC,wBAAwC;gCACtC,qBAAM,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,OAAO,CAAC,EAAA;;qCAAnC,SAAmC,EAAnC,wBAAmC;gCACrC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;gCAChC,qBAAM,CAAC,CAAC,WAAW,EAAE,EAAA;;gCAArB,SAAqB,CAAC;gCACtB,OAAO,CAAC,IAAI,CAAC,CAAC;;;qCAEV,CAAA,IAAI,CAAC,iBAAiB,KAAK,WAAW,CAAA,EAAtC,wBAAsC;gCACxC,IAAI,CAAC,QAAQ,GAAG,gBAAQ,CAAC,QAAQ,CAAC;gCAClC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;gCAChC,qBAAM,CAAC,CAAC,WAAW,EAAE,EAAA;;gCAArB,SAAqB,CAAC;gCACtB,OAAO,CAAC,IAAI,CAAC,CAAC;;;;;qBAIrB,CAAC,CAAC,OAAO,CAAC,UAAO,KAAU;;;;gCAC1B,IAAI,CAAC,QAAQ,GAAG,gBAAQ,CAAC,QAAQ,CAAC;gCAClC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;gCAChC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;gCACtB,qBAAM,CAAC,CAAC,WAAW,EAAE,EAAA;;gCAArB,SAAqB,CAAC;gCACtB,MAAM,CAAC,KAAK,CAAC,CAAC;;;;qBACf,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC;IAED,6CAAmB,GAAnB,UAAoB,eAAuB;QACzC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,yBAAiB,CAAC,eAAe,EAAE,eAAe,CAAC,CAAC;IACxE,CAAC;IACD,qCAAW,GAAX,UAAY,OAAY;QACtB,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,yBAAiB,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;IACxD,CAAC;IACD,mCAAS,GAAT,UAAU,KAAU;QAClB,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,yBAAiB,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;IACpD,CAAC;IACD,qCAAW,GAAX,UAAY,IAAS;QACnB,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,yBAAiB,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;IAC1D,CAAC;IACD,mCAAS,GAAT,UAAU,IAAS;QACjB,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,yBAAiB,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;IACnD,CAAC;IACD,uCAAa,GAAb,UAAc,OAAY;QACxB,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,yBAAiB,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;IAC1D,CAAC;IACD,uCAAa,GAAb,UAAc,IAAS;QACrB,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,yBAAiB,CAAC,cAAc,EAAE,IAAI,CAAC,CAAC;IAC5D,CAAC;IACD,qCAAW,GAAX,UAAY,IAAS;QACnB,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,yBAAiB,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;IACrD,CAAC;IAEK,wCAAc,GAApB,UAAqB,OAAwB;;;;;;;wBAEpB,qBAAM,IAAI,CAAC,SAAS,CAAC,IAAI,CAC5C,mBAAS,CAAC,WAAW,EACrB,EAAE,EACF,IAAI,CAAC,SAAS,CAAC,WAAW,EAC1B,OAAO,OAAO,KAAK,QAAQ,CAAC,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,OAAO,CACrE,EAAA;;wBALK,YAAY,GAAG,SAKpB;wBACD,IAAI,YAAY,CAAC,OAAO,EAAE,EAAE;4BAC1B,MAAM,YAAY,CAAC,OAAO,CAAC;yBAC5B;wBACD,sBAAO,IAAI,WAAE,CAAC,YAAY,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,EAAE,KAAK,CAAC,EAAC;;;wBAE5D,MAAM,OAAK,CAAC;;;;;KAEf;IACK,0CAAgB,GAAtB,UAAuB,WAAmB;;;;;;;wBAExB,qBAAM,IAAI,CAAC,SAAS,CAAC,IAAI,CACrC,mBAAS,CAAC,gBAAgB,EAC1B,CAAC,WAAW,EAAE,IAAI,CAAC,EACnB,IAAI,CAAC,SAAS,CAAC,WAAW,EAC1B,OAAO,IAAI,CAAC,OAAO,KAAK,QAAQ,CAAC,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,OAAO,CACpF,EAAA;;wBALK,KAAK,GAAG,SAKb;wBACD,IAAI,KAAK,CAAC,OAAO,EAAE,EAAE;4BACnB,MAAM,KAAK,CAAC,OAAO,CAAC;yBACrB;wBACD,sBAAO,KAAK,CAAC,MAAM,EAAC;;;wBAEpB,MAAM,OAAK,CAAC;;;;;KAEf;IAEK,mCAAS,GAAf,UACE,MAAc,EACd,WAAwB,EACxB,QAAuB,EACvB,SAA0B;QAF1B,4BAAA,EAAA,gBAAwB;QACxB,yBAAA,EAAA,eAAuB;;;;;;6BAGnB,CAAA,IAAI,CAAC,SAAS,CAAC,QAAQ,YAAY,sBAAY,CAAA,EAA/C,yBAA+C;wBAChC,qBAAM,IAAI,CAAC,cAAc,CAAC,SAAS,CAAC,EAAA;;wBAA/C,QAAQ,GAAG,SAAoC;wBACjD,UAAU,GAAG,QAAQ,CAAC;wBAEjB,OAAO,GAAG,CAAC;;;6BAAE,CAAA,OAAO,GAAG,WAAW,CAAA;;;;wBAEtB,qBAAM,IAAI,CAAC,cAAc,CAAC,SAAS,CAAC,EAAA;;wBAA/C,QAAQ,GAAG,SAAoC;wBAE/C,SAAS,GAAG,UAAU,CAAC,GAAG,CAAC,IAAI,WAAE,CAAC,OAAO,KAAK,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;6BAElE,QAAQ,CAAC,GAAG,CAAC,SAAS,CAAC,EAAvB,wBAAuB;wBACzB,UAAU,GAAG,QAAQ,CAAC;wBACtB,IAAI,CAAC,WAAW,CAAC;4BACf,MAAM,QAAA;4BACN,OAAO,SAAA;4BACP,YAAY,EAAE,UAAU,CAAC,QAAQ,EAAE;4BACnC,SAAS,WAAA;yBACV,CAAC,CAAC;wBAEC,qBAAM,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,SAAS,CAAC,EAAA;;wBAAzC,IAAI,SAAqC,EAAE;4BACzC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;4BAClC,sBAAO,IAAI,EAAC;yBACb;;;wBAED,OAAO,GAAG,OAAO,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;;;;;wBAG/C,IAAI,CAAC,QAAQ,GAAG,gBAAQ,CAAC,QAAQ,CAAC;wBAClC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;wBAClC,MAAM,KAAG,CAAC;;6BAER,CAAA,OAAO,GAAG,CAAC,GAAG,WAAW,CAAA,EAAzB,yBAAyB;wBAC3B,qBAAM,aAAK,CAAC,QAAQ,CAAC,EAAA;;wBAArB,SAAqB,CAAC;;;wBA5BmB,OAAO,IAAI,CAAC,CAAA;;;wBA+BzD,IAAI,CAAC,QAAQ,GAAG,gBAAQ,CAAC,QAAQ,CAAC;wBAClC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;wBAClC,MAAM,IAAI,KAAK,CAAC,kDAAgD,WAAW,eAAY,CAAC,CAAC;;;wBAGnF,qBAAM,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,SAAS,CAAC,EAAA;;6BAArC,SAAqC,EAArC,yBAAqC;wBACvC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;wBAClC,sBAAO,IAAI,EAAC;6BAEG,qBAAM,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE,WAAW,EAAE,SAAS,CAAC,EAAA;;wBAAnE,MAAM,GAAG,SAA0D;wBACzE,sBAAO,MAAM,EAAC;;;;wBAGhB,IAAI,CAAC,QAAQ,GAAG,gBAAQ,CAAC,QAAQ,CAAC;wBAClC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;wBAClC,MAAM,IAAI,KAAK,CACb,kDAAgD,WAAW,GAAG,QAAQ,kBAAe,CACtF,CAAC;;;;;KAGP;IAEK,iCAAO,GAAb,UAAc,MAAc,EAAE,SAA0B;;;;;;wBACtD,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;4BACnB,MAAM,IAAI,KAAK,CAAC,qBAAqB,CAAC,CAAC;yBACxC;wBAEW,qBAAM,IAAI,CAAC,SAAS,CAAC,IAAI,CACnC,mBAAS,CAAC,kBAAkB,EAC5B,MAAM,EACN,IAAI,CAAC,SAAS,CAAC,WAAW,EAC1B,OAAO,SAAS,KAAK,QAAQ,CAAC,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,SAAS,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,SAAS,CAC3E,EAAA;;wBALK,GAAG,GAAG,SAKX;6BACG,CAAA,GAAG,CAAC,QAAQ,EAAE,IAAI,GAAG,CAAC,MAAM,KAAK,IAAI,CAAA,EAArC,wBAAqC;wBACvC,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;wBAC/B,IAAI,CAAC,QAAQ,GAAG,gBAAQ,CAAC,SAAS,CAAC;wBACnC,sBAAO,IAAI,EAAC;4BAES,qBAAM,IAAI,CAAC,cAAc,CAAC,SAAS,CAAC,EAAA;;wBAAnD,YAAY,GAAG,SAAoC;wBACzD,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,GAAG,YAAY,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC;wBAC9D,IAAI,CAAC,mBAAmB,IAAI,CAAC,CAAC;wBAC9B,IAAI,CAAC,QAAQ,GAAG,gBAAQ,CAAC,OAAO,CAAC;wBACjC,sBAAO,KAAK,EAAC;;;;KAEhB;IAED,yCAAe,GAAf,UACE,MAAc,EACd,WAAwB,EACxB,SAA0B;QAH5B,iBA+CC;QA7CC,4BAAA,EAAA,gBAAwB;QAGxB,OAAO,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;YACjC,IAAM,QAAQ,GAAG,OAAO,CAAC,OAAO,CAC9B,IAAI,oBAAU,CACZ,KAAI,CAAC,SAAS,EACd,OAAO,SAAS,KAAK,QAAQ,CAAC,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,SAAS,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,SAAS,CAC3E,CACF,CAAC;YACF,QAAQ,CAAC,IAAI,CAAC,UAAC,CAAC;gBACd,CAAC,CAAC,MAAM,CAAC,UAAO,IAAS;;;;;gCACjB,WAAW,GACf,IAAI,CAAC,SAAS,CAAC,WAAW,KAAK,KAAK;oCAClC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM;oCAClC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC;gCAChC,IAAI,CAAC,WAAW,CAAC;oCACf,MAAM,QAAA;oCACN,OAAO,EAAE,IAAI,CAAC,mBAAmB;oCACjC,YAAY,EAAE,mBAAW,CAAC,WAAW,CAAC;oCACtC,SAAS,WAAA;iCACV,CAAC,CAAC;qCACC,CAAC,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,WAAW,CAAC,EAAxC,wBAAwC;gCACtC,qBAAM,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,SAAS,CAAC,EAAA;;qCAArC,SAAqC,EAArC,wBAAqC;gCACvC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;gCAClC,qBAAM,CAAC,CAAC,WAAW,EAAE,EAAA;;gCAArB,SAAqB,CAAC;gCACtB,OAAO,CAAC,IAAI,CAAC,CAAC;;;qCAEV,CAAA,IAAI,CAAC,mBAAmB,KAAK,WAAW,CAAA,EAAxC,wBAAwC;gCAC1C,IAAI,CAAC,QAAQ,GAAG,gBAAQ,CAAC,QAAQ,CAAC;gCAClC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;gCAClC,qBAAM,CAAC,CAAC,WAAW,EAAE,EAAA;;gCAArB,SAAqB,CAAC;gCACtB,OAAO,CAAC,IAAI,CAAC,CAAC;;;;;qBAIrB,CAAC,CAAC,OAAO,CAAC,UAAO,KAAU;;;;gCAC1B,IAAI,CAAC,QAAQ,GAAG,gBAAQ,CAAC,QAAQ,CAAC;gCAClC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;gCAClC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;gCACtB,qBAAM,CAAC,CAAC,WAAW,EAAE,EAAA;;gCAArB,SAAqB,CAAC;gCACtB,MAAM,CAAC,KAAK,CAAC,CAAC;;;;qBACf,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC;IACH,sBAAC;AAAD,CAAC,AAxbD,IAwbC;AAxbY,0CAAe","sourcesContent":["/**\n * @packageDocumentation\n * @module harmony-transaction\n * @hidden\n */\n\nimport { BN, getAddress, HarmonyAddress } from '@harmony-js/crypto';\nimport { hexToNumber } from '@harmony-js/utils';\nimport { Messenger, RPCMethod, Emitter, HttpProvider, NewHeaders } from '@harmony-js/network';\nimport { TxStatus, TransasctionReceipt } from './types';\nimport { sleep, TransactionEvents } from './utils';\nimport { AbstractTransaction } from './abstractTransaction';\n\nexport class TransactionBase implements AbstractTransaction {\n  static normalizeAddress(address: string) {\n    if (address === '0x') {\n      return '0x';\n    } else if (\n      HarmonyAddress.isValidChecksum(address) ||\n      HarmonyAddress.isValidBech32(address) ||\n      HarmonyAddress.isValidBech32TestNet(address)\n    ) {\n      return getAddress(address).checksum;\n    } else {\n      throw new Error(`Address format is not supported`);\n    }\n  }\n  emitter: Emitter;\n  messenger: Messenger;\n  txStatus: TxStatus;\n  blockNumbers: string[] = [];\n  confirmations: number = 0;\n  confirmationCheck: number = 0;\n  cxStatus: TxStatus = TxStatus.INTIALIZED;\n  cxBlockNumbers: string[] = [];\n  cxConfirmations: number = 0;\n  cxConfirmationCheck: number = 0;\n  receipt?: TransasctionReceipt;\n\n  id: string;\n  shardID: number | string;\n\n  constructor(messenger: Messenger, txStatus: TxStatus) {\n    this.messenger = messenger;\n    this.txStatus = txStatus;\n    this.emitter = new Emitter();\n    this.id = '0x';\n    this.shardID = this.messenger.currentShard;\n  }\n\n  setMessenger(messenger: Messenger) {\n    this.messenger = messenger;\n  }\n\n  setTxStatus(txStatus: TxStatus): void {\n    this.txStatus = txStatus;\n  }\n\n  getTxStatus(): TxStatus {\n    return this.txStatus;\n  }\n  setCxStatus(cxStatus: TxStatus): void {\n    this.cxStatus = cxStatus;\n  }\n\n  getCxStatus(): TxStatus {\n    return this.cxStatus;\n  }\n\n  // get status\n  isInitialized(): boolean {\n    return this.getTxStatus() === TxStatus.INTIALIZED;\n  }\n  isSigned(): boolean {\n    return this.getTxStatus() === TxStatus.SIGNED;\n  }\n  isPending(): boolean {\n    return this.getTxStatus() === TxStatus.PENDING;\n  }\n  isRejected(): boolean {\n    return this.getTxStatus() === TxStatus.REJECTED;\n  }\n  isConfirmed(): boolean {\n    return this.getTxStatus() === TxStatus.CONFIRMED;\n  }\n  isCxPending(): boolean {\n    return this.getCxStatus() === TxStatus.PENDING;\n  }\n  isCxRejected(): boolean {\n    return this.getCxStatus() === TxStatus.REJECTED;\n  }\n  isCxConfirmed(): boolean {\n    return this.getCxStatus() === TxStatus.CONFIRMED;\n  }\n  observed() {\n    return this.emitter;\n  }\n\n  async trackTx(txHash: string, shardID: number | string) {\n    if (!this.messenger) {\n      throw new Error('Messenger not found');\n    }\n    // TODO: regex validation for txHash so we don't get garbage\n    const res = await this.messenger.send(\n      RPCMethod.GetTransactionReceipt,\n      txHash,\n      this.messenger.chainType,\n      typeof shardID === 'string' ? Number.parseInt(shardID, 10) : shardID,\n    );\n    if (res.isResult() && res.result !== null) {\n      this.receipt = res.result;\n      this.emitReceipt(this.receipt);\n      this.id = res.result.transactionHash;\n      this.confirmations += 1;\n\n      if (this.receipt) {\n        if (this.receipt.status && this.receipt.status === '0x1') {\n          this.receipt.byzantium = true;\n          this.txStatus = TxStatus.CONFIRMED;\n        } else if (this.receipt.status && this.receipt.status === '0x0') {\n          this.receipt.byzantium = true;\n          this.txStatus = TxStatus.REJECTED;\n        } else if (this.receipt.status === undefined && this.receipt.root) {\n          this.receipt.byzantium = false;\n          this.txStatus = TxStatus.CONFIRMED;\n        }\n        return true;\n      } else {\n        this.txStatus = TxStatus.PENDING;\n        const currentBlock = await this.getBlockNumber(shardID);\n\n        this.blockNumbers.push('0x' + currentBlock.toString('hex'));\n\n        this.confirmationCheck += 1;\n        return false;\n      }\n    } else {\n      this.txStatus = TxStatus.PENDING;\n      const currentBlock = await this.getBlockNumber(shardID);\n      this.blockNumbers.push('0x' + currentBlock.toString('hex'));\n      this.confirmationCheck += 1;\n      return false;\n    }\n  }\n\n  async txConfirm(\n    txHash: string,\n    maxAttempts: number = 20,\n    interval: number = 1000,\n    shardID: number | string,\n  ) {\n    if (this.messenger.provider instanceof HttpProvider) {\n      this.txStatus = TxStatus.PENDING;\n      const oldBlock = await this.getBlockNumber(shardID);\n      let checkBlock = oldBlock;\n\n      for (let attempt = 0; attempt < maxAttempts; attempt += 1) {\n        try {\n          const newBlock = await this.getBlockNumber(shardID);\n          // TODO: this is super ugly, must be a better way doing this\n          const nextBlock = checkBlock.add(new BN(attempt === 0 ? attempt : 1));\n\n          if (newBlock.gte(nextBlock)) {\n            checkBlock = newBlock;\n            this.emitTrack({\n              txHash,\n              attempt,\n              currentBlock: checkBlock.toString(),\n              shardID,\n            });\n\n            if (await this.trackTx(txHash, shardID)) {\n              this.emitConfirm(this.txStatus);\n              return this;\n            }\n          } else {\n            attempt = attempt - 1 >= 0 ? attempt - 1 : 0;\n          }\n        } catch (err) {\n          this.txStatus = TxStatus.REJECTED;\n          this.emitConfirm(this.txStatus);\n          throw err;\n        }\n\n        if (attempt + 1 < maxAttempts) {\n          // await sleep(interval * attempt);\n          await sleep(interval);\n        }\n      }\n      this.txStatus = TxStatus.REJECTED;\n      this.emitConfirm(this.txStatus);\n      throw new Error(`The transaction is still not confirmed after ${maxAttempts} attempts.`);\n    } else {\n      try {\n        if (await this.trackTx(txHash, shardID)) {\n          this.emitConfirm(this.txStatus);\n          return this;\n        } else {\n          const result = await this.socketConfirm(txHash, maxAttempts, shardID);\n          return result;\n        }\n      } catch (error) {\n        this.txStatus = TxStatus.REJECTED;\n        this.emitConfirm(this.txStatus);\n        throw new Error(\n          `The transaction is still not confirmed after ${maxAttempts * interval} mil seconds.`,\n        );\n      }\n    }\n  }\n\n  socketConfirm(\n    txHash: string,\n    maxAttempts: number = 20,\n    shardID: number | string,\n  ): Promise<TransactionBase> {\n    return new Promise((resolve, reject) => {\n      const newHeads = Promise.resolve(\n        new NewHeaders(\n          this.messenger,\n          typeof shardID === 'string' ? Number.parseInt(shardID, 10) : shardID,\n        ),\n      );\n      newHeads.then((p) => {\n        p.onData(async (data: any) => {\n          const blockNumber =\n            this.messenger.chainPrefix === 'hmy'\n              ? data.params.result.Header.number\n              : data.params.result.number;\n          this.emitTrack({\n            txHash,\n            attempt: this.confirmationCheck,\n            currentBlock: hexToNumber(blockNumber),\n            shardID,\n          });\n          if (!this.blockNumbers.includes(blockNumber)) {\n            if (await this.trackTx(txHash, shardID)) {\n              this.emitConfirm(this.txStatus);\n              await p.unsubscribe();\n              resolve(this);\n            } else {\n              if (this.confirmationCheck === maxAttempts) {\n                this.txStatus = TxStatus.REJECTED;\n                this.emitConfirm(this.txStatus);\n                await p.unsubscribe();\n                resolve(this);\n              }\n            }\n          }\n        }).onError(async (error: any) => {\n          this.txStatus = TxStatus.REJECTED;\n          this.emitConfirm(this.txStatus);\n          this.emitError(error);\n          await p.unsubscribe();\n          reject(error);\n        });\n      });\n    });\n  }\n\n  emitTransactionHash(transactionHash: string) {\n    this.emitter.emit(TransactionEvents.transactionHash, transactionHash);\n  }\n  emitReceipt(receipt: any) {\n    this.emitter.emit(TransactionEvents.receipt, receipt);\n  }\n  emitError(error: any) {\n    this.emitter.emit(TransactionEvents.error, error);\n  }\n  emitConfirm(data: any) {\n    this.emitter.emit(TransactionEvents.confirmation, data);\n  }\n  emitTrack(data: any) {\n    this.emitter.emit(TransactionEvents.track, data);\n  }\n  emitCxReceipt(receipt: any) {\n    this.emitter.emit(TransactionEvents.cxReceipt, receipt);\n  }\n  emitCxConfirm(data: any) {\n    this.emitter.emit(TransactionEvents.cxConfirmation, data);\n  }\n  emitCxTrack(data: any) {\n    this.emitter.emit(TransactionEvents.cxTrack, data);\n  }\n\n  async getBlockNumber(shardID: number | string): Promise<BN> {\n    try {\n      const currentBlock = await this.messenger.send(\n        RPCMethod.BlockNumber,\n        [],\n        this.messenger.chainPrefix,\n        typeof shardID === 'string' ? Number.parseInt(shardID, 10) : shardID,\n      );\n      if (currentBlock.isError()) {\n        throw currentBlock.message;\n      }\n      return new BN(currentBlock.result.replace('0x', ''), 'hex');\n    } catch (error) {\n      throw error;\n    }\n  }\n  async getBlockByNumber(blockNumber: string) {\n    try {\n      const block = await this.messenger.send(\n        RPCMethod.GetBlockByNumber,\n        [blockNumber, true],\n        this.messenger.chainPrefix,\n        typeof this.shardID === 'string' ? Number.parseInt(this.shardID, 10) : this.shardID,\n      );\n      if (block.isError()) {\n        throw block.message;\n      }\n      return block.result;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async cxConfirm(\n    txHash: string,\n    maxAttempts: number = 20,\n    interval: number = 1000,\n    toShardID: number | string,\n  ) {\n    if (this.messenger.provider instanceof HttpProvider) {\n      const oldBlock = await this.getBlockNumber(toShardID);\n      let checkBlock = oldBlock;\n\n      for (let attempt = 0; attempt < maxAttempts; attempt += 1) {\n        try {\n          const newBlock = await this.getBlockNumber(toShardID);\n          // TODO: this is super ugly, must be a better way doing this\n          const nextBlock = checkBlock.add(new BN(attempt === 0 ? attempt : 1));\n\n          if (newBlock.gte(nextBlock)) {\n            checkBlock = newBlock;\n            this.emitCxTrack({\n              txHash,\n              attempt,\n              currentBlock: checkBlock.toString(),\n              toShardID,\n            });\n\n            if (await this.trackCx(txHash, toShardID)) {\n              this.emitCxConfirm(this.cxStatus);\n              return this;\n            }\n          } else {\n            attempt = attempt - 1 >= 0 ? attempt - 1 : 0;\n          }\n        } catch (err) {\n          this.cxStatus = TxStatus.REJECTED;\n          this.emitCxConfirm(this.cxStatus);\n          throw err;\n        }\n        if (attempt + 1 < maxAttempts) {\n          await sleep(interval);\n        }\n      }\n      this.cxStatus = TxStatus.REJECTED;\n      this.emitCxConfirm(this.cxStatus);\n      throw new Error(`The transaction is still not confirmed after ${maxAttempts} attempts.`);\n    } else {\n      try {\n        if (await this.trackCx(txHash, toShardID)) {\n          this.emitCxConfirm(this.cxStatus);\n          return this;\n        } else {\n          const result = await this.socketCxConfirm(txHash, maxAttempts, toShardID);\n          return result;\n        }\n      } catch (error) {\n        this.cxStatus = TxStatus.REJECTED;\n        this.emitCxConfirm(this.cxStatus);\n        throw new Error(\n          `The transaction is still not confirmed after ${maxAttempts * interval} mil seconds.`,\n        );\n      }\n    }\n  }\n\n  async trackCx(txHash: string, toShardID: number | string) {\n    if (!this.messenger) {\n      throw new Error('Messenger not found');\n    }\n    // TODO: regex validation for txHash so we don't get garbage\n    const res = await this.messenger.send(\n      RPCMethod.GetCXReceiptByHash,\n      txHash,\n      this.messenger.chainPrefix,\n      typeof toShardID === 'string' ? Number.parseInt(toShardID, 10) : toShardID,\n    );\n    if (res.isResult() && res.result !== null) {\n      this.emitCxReceipt(res.result);\n      this.cxStatus = TxStatus.CONFIRMED;\n      return true;\n    } else {\n      const currentBlock = await this.getBlockNumber(toShardID);\n      this.cxBlockNumbers.push('0x' + currentBlock.toString('hex'));\n      this.cxConfirmationCheck += 1;\n      this.cxStatus = TxStatus.PENDING;\n      return false;\n    }\n  }\n\n  socketCxConfirm(\n    txHash: string,\n    maxAttempts: number = 20,\n    toShardID: number | string,\n  ): Promise<TransactionBase> {\n    return new Promise((resolve, reject) => {\n      const newHeads = Promise.resolve(\n        new NewHeaders(\n          this.messenger,\n          typeof toShardID === 'string' ? Number.parseInt(toShardID, 10) : toShardID,\n        ),\n      );\n      newHeads.then((p) => {\n        p.onData(async (data: any) => {\n          const blockNumber =\n            this.messenger.chainPrefix === 'hmy'\n              ? data.params.result.Header.number\n              : data.params.result.number;\n          this.emitCxTrack({\n            txHash,\n            attempt: this.cxConfirmationCheck,\n            currentBlock: hexToNumber(blockNumber),\n            toShardID,\n          });\n          if (!this.blockNumbers.includes(blockNumber)) {\n            if (await this.trackCx(txHash, toShardID)) {\n              this.emitCxConfirm(this.cxStatus);\n              await p.unsubscribe();\n              resolve(this);\n            } else {\n              if (this.cxConfirmationCheck === maxAttempts) {\n                this.cxStatus = TxStatus.REJECTED;\n                this.emitCxConfirm(this.cxStatus);\n                await p.unsubscribe();\n                resolve(this);\n              }\n            }\n          }\n        }).onError(async (error: any) => {\n          this.cxStatus = TxStatus.REJECTED;\n          this.emitCxConfirm(this.cxStatus);\n          this.emitError(error);\n          await p.unsubscribe();\n          reject(error);\n        });\n      });\n    });\n  }\n}\n"]}},"error":null,"hash":"1841d68fce80dbbab92a70acf7d1c4bb","cacheData":{"env":{}}}