{"id":"../node_modules/@harmony-js/network/dist/tracker/baseTracker.js","dependencies":[{"name":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/network/dist/tracker/baseTracker.js.map","includedInParent":true,"mtime":499162500000},{"name":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/network/src/tracker/baseTracker.ts","includedInParent":true,"mtime":499162500000},{"name":"/home/rachit/Projects/demo/web Math Wallet/package.json","includedInParent":true,"mtime":1605273881149},{"name":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/network/package.json","includedInParent":true,"mtime":1605232158322},{"name":"tslib","loc":{"line":9,"column":22},"parent":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/network/dist/tracker/baseTracker.js","resolved":"/home/rachit/Projects/demo/node_modules/tslib/tslib.es6.js"},{"name":"@harmony-js/utils","loc":{"line":10,"column":22},"parent":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/network/dist/tracker/baseTracker.js","resolved":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/utils/dist/index.js"},{"name":"../providers/emitter","loc":{"line":11,"column":24},"parent":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/network/dist/tracker/baseTracker.js","resolved":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/network/dist/providers/emitter.js"}],"generated":{"js":"\"use strict\";\n/**\n * @packageDocumentation\n * @module harmony-network\n * @hidden\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BaseBlockTracker = void 0;\nvar tslib_1 = require(\"tslib\");\nvar utils_1 = require(\"@harmony-js/utils\");\nvar emitter_1 = require(\"../providers/emitter\");\nvar sec = 1000;\nvar calculateSum = function (accumulator, currentValue) { return accumulator + currentValue; };\nvar blockTrackerEvents = ['sync', 'latest'];\nvar BaseBlockTracker = /** @class */ (function (_super) {\n    tslib_1.__extends(BaseBlockTracker, _super);\n    function BaseBlockTracker(opts) {\n        if (opts === void 0) { opts = {\n            blockResetDuration: undefined,\n            retryTimeout: undefined,\n            keepEventLoopActive: undefined,\n            setSkipCacheFlag: false,\n        }; }\n        var _this = _super.call(this) || this;\n        // config\n        _this._blockResetDuration = opts.blockResetDuration || 20 * sec;\n        // state\n        // tslint:disable-next-line: no-unused-expression\n        _this._blockResetTimeout;\n        _this._currentBlock = null;\n        _this._isRunning = false;\n        // bind functions for internal use\n        // this._onNewListener = this._onNewListener.bind(this);\n        // this._onRemoveListener = this._onRemoveListener.bind(this);\n        // this._resetCurrentBlock = this._resetCurrentBlock.bind(this);\n        // listen for handler changes\n        // this._setupInternalEvents();\n        _this._maybeStart();\n        return _this;\n    }\n    BaseBlockTracker.prototype.isRunning = function () {\n        return this._isRunning;\n    };\n    BaseBlockTracker.prototype.getCurrentBlock = function () {\n        return this._currentBlock;\n    };\n    BaseBlockTracker.prototype.getLatestBlock = function () {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var latestBlock;\n            var _this = this;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        // return if available\n                        if (this._currentBlock) {\n                            return [2 /*return*/, this._currentBlock];\n                        }\n                        return [4 /*yield*/, new Promise(function (resolve) { return _this.once('latest', resolve); })];\n                    case 1:\n                        latestBlock = _a.sent();\n                        // return newly set current block\n                        return [2 /*return*/, latestBlock];\n                }\n            });\n        });\n    };\n    // dont allow module consumer to remove our internal event listeners\n    BaseBlockTracker.prototype.removeAllListeners = function (eventName) {\n        // perform default behavior, preserve fn arity\n        if (eventName) {\n            _super.prototype.removeEventListener.call(this, eventName);\n        }\n        else {\n            _super.prototype.removeEventListener.call(this, '*');\n        }\n        // re-add internal events\n        this._setupInternalEvents();\n        // trigger stop check just in case\n        this._onRemoveListener('*');\n    };\n    //\n    // to be implemented in subclass\n    //\n    BaseBlockTracker.prototype._start = function () {\n        // default behavior is noop\n    };\n    BaseBlockTracker.prototype._end = function () {\n        // default behavior is noop\n    };\n    //\n    // private\n    //\n    BaseBlockTracker.prototype._setupInternalEvents = function () {\n        // first remove listeners for idempotence\n        this.removeEventListener('newListener', this._onNewListener);\n        this.removeEventListener('removeListener', this._onRemoveListener);\n        // then add them\n        this.on('newListener', this._onNewListener);\n        this.on('removeListener', this._onRemoveListener);\n    };\n    BaseBlockTracker.prototype._onNewListener = function (eventName, handler) {\n        // `newListener` is called *before* the listener is added\n        if (!blockTrackerEvents.includes(eventName)) {\n            return;\n        }\n        this._maybeStart();\n    };\n    BaseBlockTracker.prototype._onRemoveListener = function (eventName, handler) {\n        // `removeListener` is called *after* the listener is removed\n        if (this._getBlockTrackerEventCount() > 0) {\n            return;\n        }\n        this._maybeEnd();\n    };\n    BaseBlockTracker.prototype._maybeStart = function () {\n        if (this._isRunning) {\n            return;\n        }\n        this._isRunning = true;\n        // cancel setting latest block to stale\n        this._cancelBlockResetTimeout();\n        this._start();\n    };\n    BaseBlockTracker.prototype._maybeEnd = function () {\n        if (!this._isRunning) {\n            return;\n        }\n        this._isRunning = false;\n        this._setupBlockResetTimeout();\n        this._end();\n    };\n    BaseBlockTracker.prototype._getBlockTrackerEventCount = function () {\n        var _this = this;\n        return blockTrackerEvents\n            .map(function (eventName) { return _this.listenerCount(eventName); })\n            .reduce(calculateSum);\n    };\n    BaseBlockTracker.prototype._newPotentialLatest = function (newBlock) {\n        var currentBlock = this._currentBlock;\n        // only update if blok number is higher\n        if (currentBlock &&\n            utils_1.isHex(currentBlock) &&\n            utils_1.isHex(newBlock) &&\n            utils_1.hexToNumber(newBlock) <= utils_1.hexToNumber(currentBlock)) {\n            return;\n        }\n        this._setCurrentBlock(newBlock);\n    };\n    BaseBlockTracker.prototype._setCurrentBlock = function (newBlock) {\n        var oldBlock = this._currentBlock;\n        this._currentBlock = newBlock;\n        this.emit('latest', newBlock);\n        this.emit('sync', { oldBlock: oldBlock, newBlock: newBlock });\n    };\n    BaseBlockTracker.prototype._setupBlockResetTimeout = function () {\n        // clear any existing timeout\n        this._cancelBlockResetTimeout();\n        // clear latest block when stale\n        this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this._blockResetDuration);\n        // nodejs - dont hold process open\n        if (this._blockResetTimeout.unref) {\n            this._blockResetTimeout.unref();\n        }\n    };\n    BaseBlockTracker.prototype._cancelBlockResetTimeout = function () {\n        clearTimeout(this._blockResetTimeout);\n    };\n    BaseBlockTracker.prototype._resetCurrentBlock = function () {\n        this._currentBlock = null;\n    };\n    return BaseBlockTracker;\n}(emitter_1.Emitter));\nexports.BaseBlockTracker = BaseBlockTracker;\n"},"sourceMaps":{"js":{"version":3,"file":"baseTracker.js","sourceRoot":"","sources":["../../src/tracker/baseTracker.ts"],"names":[],"mappings":";AAAA;;;;GAIG;;;;AAEH,2CAAuD;AACvD,gDAA+C;AAE/C,IAAM,GAAG,GAAG,IAAI,CAAC;AAEjB,IAAM,YAAY,GAAG,UAAC,WAAmB,EAAE,YAAoB,IAAK,OAAA,WAAW,GAAG,YAAY,EAA1B,CAA0B,CAAC;AAC/F,IAAM,kBAAkB,GAAG,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;AAE9C;IAAsC,4CAAO;IAS3C,0BACE,IAKC;QALD,qBAAA,EAAA;YACE,kBAAkB,EAAE,SAAS;YAC7B,YAAY,EAAE,SAAS;YACvB,mBAAmB,EAAE,SAAS;YAC9B,gBAAgB,EAAE,KAAK;SACxB;QANH,YAQE,iBAAO,SAeR;QAdC,SAAS;QACT,KAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC,kBAAkB,IAAI,EAAE,GAAG,GAAG,CAAC;QAC/D,QAAQ;QACR,iDAAiD;QACjD,KAAI,CAAC,kBAAkB,CAAC;QACxB,KAAI,CAAC,aAAa,GAAG,IAAI,CAAC;QAC1B,KAAI,CAAC,UAAU,GAAG,KAAK,CAAC;QACxB,kCAAkC;QAClC,wDAAwD;QACxD,8DAA8D;QAC9D,gEAAgE;QAChE,6BAA6B;QAC7B,+BAA+B;QAC/B,KAAI,CAAC,WAAW,EAAE,CAAC;;IACrB,CAAC;IAED,oCAAS,GAAT;QACE,OAAO,IAAI,CAAC,UAAU,CAAC;IACzB,CAAC;IAED,0CAAe,GAAf;QACE,OAAO,IAAI,CAAC,aAAa,CAAC;IAC5B,CAAC;IAEK,yCAAc,GAApB;;;;;;;wBACE,sBAAsB;wBACtB,IAAI,IAAI,CAAC,aAAa,EAAE;4BACtB,sBAAO,IAAI,CAAC,aAAa,EAAC;yBAC3B;wBAEmB,qBAAM,IAAI,OAAO,CAAC,UAAC,OAAO,IAAK,OAAA,KAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,OAAO,CAAC,EAA5B,CAA4B,CAAC,EAAA;;wBAA1E,WAAW,GAAG,SAA4D;wBAChF,iCAAiC;wBACjC,sBAAO,WAAW,EAAC;;;;KACpB;IAED,oEAAoE;IACpE,6CAAkB,GAAlB,UAAmB,SAAiB;QAClC,8CAA8C;QAC9C,IAAI,SAAS,EAAE;YACb,iBAAM,mBAAmB,YAAC,SAAS,CAAC,CAAC;SACtC;aAAM;YACL,iBAAM,mBAAmB,YAAC,GAAG,CAAC,CAAC;SAChC;QACD,yBAAyB;QACzB,IAAI,CAAC,oBAAoB,EAAE,CAAC;QAC5B,kCAAkC;QAClC,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,CAAC;IAC9B,CAAC;IAED,EAAE;IACF,gCAAgC;IAChC,EAAE;IAEF,iCAAM,GAAN;QACE,2BAA2B;IAC7B,CAAC;IAED,+BAAI,GAAJ;QACE,2BAA2B;IAC7B,CAAC;IAED,EAAE;IACF,UAAU;IACV,EAAE;IAEF,+CAAoB,GAApB;QACE,yCAAyC;QACzC,IAAI,CAAC,mBAAmB,CAAC,aAAa,EAAE,IAAI,CAAC,cAAc,CAAC,CAAC;QAC7D,IAAI,CAAC,mBAAmB,CAAC,gBAAgB,EAAE,IAAI,CAAC,iBAAiB,CAAC,CAAC;QACnE,gBAAgB;QAEhB,IAAI,CAAC,EAAE,CAAC,aAAa,EAAE,IAAI,CAAC,cAAc,CAAC,CAAC;QAC5C,IAAI,CAAC,EAAE,CAAC,gBAAgB,EAAE,IAAI,CAAC,iBAAiB,CAAC,CAAC;IACpD,CAAC;IAED,yCAAc,GAAd,UAAe,SAAiB,EAAE,OAAsB;QACtD,yDAAyD;QACzD,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,SAAS,CAAC,EAAE;YAC3C,OAAO;SACR;QAED,IAAI,CAAC,WAAW,EAAE,CAAC;IACrB,CAAC;IAED,4CAAiB,GAAjB,UAAkB,SAAiB,EAAE,OAAsB;QACzD,6DAA6D;QAC7D,IAAI,IAAI,CAAC,0BAA0B,EAAE,GAAG,CAAC,EAAE;YACzC,OAAO;SACR;QACD,IAAI,CAAC,SAAS,EAAE,CAAC;IACnB,CAAC;IAED,sCAAW,GAAX;QACE,IAAI,IAAI,CAAC,UAAU,EAAE;YACnB,OAAO;SACR;QACD,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;QACvB,uCAAuC;QACvC,IAAI,CAAC,wBAAwB,EAAE,CAAC;QAChC,IAAI,CAAC,MAAM,EAAE,CAAC;IAChB,CAAC;IAED,oCAAS,GAAT;QACE,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;YACpB,OAAO;SACR;QACD,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;QACxB,IAAI,CAAC,uBAAuB,EAAE,CAAC;QAC/B,IAAI,CAAC,IAAI,EAAE,CAAC;IACd,CAAC;IAED,qDAA0B,GAA1B;QAAA,iBAIC;QAHC,OAAO,kBAAkB;aACtB,GAAG,CAAC,UAAC,SAAS,IAAK,OAAA,KAAI,CAAC,aAAa,CAAC,SAAS,CAAC,EAA7B,CAA6B,CAAC;aACjD,MAAM,CAAC,YAAY,CAAC,CAAC;IAC1B,CAAC;IAED,8CAAmB,GAAnB,UAAoB,QAAgB;QAClC,IAAM,YAAY,GAAG,IAAI,CAAC,aAAa,CAAC;QACxC,uCAAuC;QACvC,IACE,YAAY;YACZ,aAAK,CAAC,YAAY,CAAC;YACnB,aAAK,CAAC,QAAQ,CAAC;YACf,mBAAW,CAAC,QAAQ,CAAC,IAAI,mBAAW,CAAC,YAAY,CAAC,EAClD;YACA,OAAO;SACR;QACD,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC;IAClC,CAAC;IAED,2CAAgB,GAAhB,UAAiB,QAAgB;QAC/B,IAAM,QAAQ,GAAG,IAAI,CAAC,aAAa,CAAC;QACpC,IAAI,CAAC,aAAa,GAAG,QAAQ,CAAC;QAC9B,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;QAC9B,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,EAAE,QAAQ,UAAA,EAAE,QAAQ,UAAA,EAAE,CAAC,CAAC;IAC5C,CAAC;IAED,kDAAuB,GAAvB;QACE,6BAA6B;QAC7B,IAAI,CAAC,wBAAwB,EAAE,CAAC;QAChC,gCAAgC;QAChC,IAAI,CAAC,kBAAkB,GAAG,UAAU,CAAC,IAAI,CAAC,kBAAkB,EAAE,IAAI,CAAC,mBAAmB,CAAC,CAAC;QACxF,kCAAkC;QAClC,IAAI,IAAI,CAAC,kBAAkB,CAAC,KAAK,EAAE;YACjC,IAAI,CAAC,kBAAkB,CAAC,KAAK,EAAE,CAAC;SACjC;IACH,CAAC;IAED,mDAAwB,GAAxB;QACE,YAAY,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;IACxC,CAAC;IAED,6CAAkB,GAAlB;QACE,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC;IAC5B,CAAC;IACH,uBAAC;AAAD,CAAC,AA9KD,CAAsC,iBAAO,GA8K5C;AA9KY,4CAAgB","sourcesContent":["/**\n * @packageDocumentation\n * @module harmony-network\n * @hidden\n */\n\nimport { isHex, hexToNumber } from '@harmony-js/utils';\nimport { Emitter } from '../providers/emitter';\n\nconst sec = 1000;\n\nconst calculateSum = (accumulator: number, currentValue: number) => accumulator + currentValue;\nconst blockTrackerEvents = ['sync', 'latest'];\n\nexport class BaseBlockTracker extends Emitter {\n  // tslint:disable-next-line: variable-name\n  _blockResetDuration?: number;\n  // tslint:disable-next-line: variable-name\n  _blockResetTimeout: any;\n  // tslint:disable-next-line: variable-name\n  _currentBlock: any;\n  // tslint:disable-next-line: variable-name\n  _isRunning: boolean;\n  constructor(\n    opts: any = {\n      blockResetDuration: undefined,\n      retryTimeout: undefined,\n      keepEventLoopActive: undefined,\n      setSkipCacheFlag: false,\n    },\n  ) {\n    super();\n    // config\n    this._blockResetDuration = opts.blockResetDuration || 20 * sec;\n    // state\n    // tslint:disable-next-line: no-unused-expression\n    this._blockResetTimeout;\n    this._currentBlock = null;\n    this._isRunning = false;\n    // bind functions for internal use\n    // this._onNewListener = this._onNewListener.bind(this);\n    // this._onRemoveListener = this._onRemoveListener.bind(this);\n    // this._resetCurrentBlock = this._resetCurrentBlock.bind(this);\n    // listen for handler changes\n    // this._setupInternalEvents();\n    this._maybeStart();\n  }\n\n  isRunning() {\n    return this._isRunning;\n  }\n\n  getCurrentBlock() {\n    return this._currentBlock;\n  }\n\n  async getLatestBlock() {\n    // return if available\n    if (this._currentBlock) {\n      return this._currentBlock;\n    }\n    // wait for a new latest block\n    const latestBlock = await new Promise((resolve) => this.once('latest', resolve));\n    // return newly set current block\n    return latestBlock;\n  }\n\n  // dont allow module consumer to remove our internal event listeners\n  removeAllListeners(eventName: string) {\n    // perform default behavior, preserve fn arity\n    if (eventName) {\n      super.removeEventListener(eventName);\n    } else {\n      super.removeEventListener('*');\n    }\n    // re-add internal events\n    this._setupInternalEvents();\n    // trigger stop check just in case\n    this._onRemoveListener('*');\n  }\n\n  //\n  // to be implemented in subclass\n  //\n\n  _start() {\n    // default behavior is noop\n  }\n\n  _end() {\n    // default behavior is noop\n  }\n\n  //\n  // private\n  //\n\n  _setupInternalEvents() {\n    // first remove listeners for idempotence\n    this.removeEventListener('newListener', this._onNewListener);\n    this.removeEventListener('removeListener', this._onRemoveListener);\n    // then add them\n\n    this.on('newListener', this._onNewListener);\n    this.on('removeListener', this._onRemoveListener);\n  }\n\n  _onNewListener(eventName: string, handler?: mitt.Handler) {\n    // `newListener` is called *before* the listener is added\n    if (!blockTrackerEvents.includes(eventName)) {\n      return;\n    }\n\n    this._maybeStart();\n  }\n\n  _onRemoveListener(eventName: string, handler?: mitt.Handler) {\n    // `removeListener` is called *after* the listener is removed\n    if (this._getBlockTrackerEventCount() > 0) {\n      return;\n    }\n    this._maybeEnd();\n  }\n\n  _maybeStart() {\n    if (this._isRunning) {\n      return;\n    }\n    this._isRunning = true;\n    // cancel setting latest block to stale\n    this._cancelBlockResetTimeout();\n    this._start();\n  }\n\n  _maybeEnd() {\n    if (!this._isRunning) {\n      return;\n    }\n    this._isRunning = false;\n    this._setupBlockResetTimeout();\n    this._end();\n  }\n\n  _getBlockTrackerEventCount() {\n    return blockTrackerEvents\n      .map((eventName) => this.listenerCount(eventName))\n      .reduce(calculateSum);\n  }\n\n  _newPotentialLatest(newBlock: string) {\n    const currentBlock = this._currentBlock;\n    // only update if blok number is higher\n    if (\n      currentBlock &&\n      isHex(currentBlock) &&\n      isHex(newBlock) &&\n      hexToNumber(newBlock) <= hexToNumber(currentBlock)\n    ) {\n      return;\n    }\n    this._setCurrentBlock(newBlock);\n  }\n\n  _setCurrentBlock(newBlock: string) {\n    const oldBlock = this._currentBlock;\n    this._currentBlock = newBlock;\n    this.emit('latest', newBlock);\n    this.emit('sync', { oldBlock, newBlock });\n  }\n\n  _setupBlockResetTimeout() {\n    // clear any existing timeout\n    this._cancelBlockResetTimeout();\n    // clear latest block when stale\n    this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this._blockResetDuration);\n    // nodejs - dont hold process open\n    if (this._blockResetTimeout.unref) {\n      this._blockResetTimeout.unref();\n    }\n  }\n\n  _cancelBlockResetTimeout() {\n    clearTimeout(this._blockResetTimeout);\n  }\n\n  _resetCurrentBlock() {\n    this._currentBlock = null;\n  }\n}\n"]}},"error":null,"hash":"4b4b47591ace6da87256485f4566096c","cacheData":{"env":{}}}