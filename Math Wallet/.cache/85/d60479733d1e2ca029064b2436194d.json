{"id":"../node_modules/@harmony-js/core/dist/blockchain.js","dependencies":[{"name":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/core/dist/blockchain.js.map","includedInParent":true,"mtime":499162500000},{"name":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/core/src/blockchain.ts","includedInParent":true,"mtime":499162500000},{"name":"/home/rachit/Projects/demo/web/package.json","includedInParent":true,"mtime":1605273881149},{"name":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/core/package.json","includedInParent":true,"mtime":1605232158322},{"name":"tslib","loc":{"line":88,"column":22},"parent":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/core/dist/blockchain.js","resolved":"/home/rachit/Projects/demo/node_modules/tslib/tslib.es6.js"},{"name":"@harmony-js/network","loc":{"line":89,"column":24},"parent":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/core/dist/blockchain.js","resolved":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/network/dist/index.js"},{"name":"@harmony-js/utils","loc":{"line":90,"column":22},"parent":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/core/dist/blockchain.js","resolved":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/utils/dist/index.js"},{"name":"@harmony-js/crypto","loc":{"line":91,"column":23},"parent":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/core/dist/blockchain.js","resolved":"/home/rachit/Projects/demo/web/node_modules/@harmony-js/crypto/dist/index.js"}],"generated":{"js":"\"use strict\";\n/**\n * ## About this package\n *\n * `@harmony-js/core` is collection of modules to guide user to interacte with harmony blockchian.\n *\n * Develops can use this package to:\n * - Create a `harmony` instance\n * - Create a `harmonyExtension` instance, which support fo `MathWallet`\n * - Get block and transaction by hash or blocknumber\n * - Send transaction\n * - Get balance of address\n *\n * ## How to use `@harmony-core`\n * ### Dependencies\n * - @harmony-js/core\n * - @harmony-js/utils\n *\n * ### Step 1: Initialize the Harmony instance\n * Before using harmony-core package, you should initialize the Harmony instance\n * ```javascript\n * // import or require Harmony class\n * const { Harmony } = require('@harmony-js/core');\n * // import or require settings\n * const { ChainID, ChainType } = require('@harmony-js/utils');\n *\n * // initialize the Harmony instance\n * const hmy = new Harmony(\n *   // rpc url\n *   'https://api.s0.b.hmny.io/',\n *   {\n *     // chainType set to Harmony\n *     chainType: ChainType.Harmony,\n *     // chainType set to HmyLocal\n *     chainId: ChainID.HmyLocal,\n *   },\n * );\n * ```\n *\n * ### Step 2: Use the instance to call specific functions\n * Example 1: get balance\n * ```javascript\n * // get balance\n * hmy.blockchain.getBalance({\n *   address: 'one103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7',\n *   blockNumber: 'latest'\n * }).then((value) => {\n *   console.log(value.result);\n * });\n * ```\n *\n * Example 2: send transaction\n * ```\n * // add privateKey to wallet\n * const privateKey = '45e497bd45a9049bcb649016594489ac67b9f052a6cdf5cb74ee2427a60bf25e';\n * hmy.wallet.addByPrivateKey(privateKey);\n *\n * async function transfer() {\n *   const txn = hmy.transactions.newTx({\n *     //  token send to\n *     to: 'one166axnkjmghkf3df7xfvd0hn4dft8kemrza4cd2',\n *     // amount to send\n *     value: '10000',\n *     // gas limit, you can use string\n *     gasLimit: '210000',\n *     // send token from shardID\n *     shardID: 0,\n *     // send token to toShardID\n *     toShardID: 0,\n *     // gas Price, you can use Unit class, and use Gwei, then remember to use toWei(), which will be transformed to BN\n *     gasPrice: new hmy.utils.Unit('100').asGwei().toWei(),\n *   });\n *\n *   // sign the transaction use wallet;\n *   const signedTxn = await hmy.wallet.signTransaction(txn);\n *   const txnHash = await hmy.blockchain.sendTransaction(signedTxn);\n *   console.log(txnHash.result);\n * }\n *\n * transfer();\n * ```\n *\n * @packageDocumentation\n * @module harmony-core\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Blockchain = void 0;\nvar tslib_1 = require(\"tslib\");\nvar network_1 = require(\"@harmony-js/network\");\nvar utils_1 = require(\"@harmony-js/utils\");\nvar crypto_1 = require(\"@harmony-js/crypto\");\nvar Blockchain = /** @class */ (function () {\n    /**\n     * @hidden\n     */\n    function Blockchain(messenger) {\n        this.messenger = messenger;\n    }\n    /**\n     * @hidden\n     */\n    Blockchain.prototype.setMessenger = function (messenger) {\n        this.messenger = messenger;\n    };\n    /**\n     *\n     * @hidden\n     */\n    Blockchain.prototype.getRpcResult = function (result) {\n        if (result instanceof network_1.ResponseMiddleware) {\n            return result.getRaw;\n        }\n        else {\n            return result;\n        }\n    };\n    /**\n     * Get the balance of an address at a given block.\n     *\n     * @param address the address to get the balance of.\n     * @param blockNumber (option) If you pass this parameter it will not use the default block set with `DefaultBlockParams.latest`\n     * @param shardID (option) If you pass this parameter it will not use the default block set with `this.messenger.currentShard`\n     *\n     * @returns The current balance for the given address in wei.\n     *\n     * @hint\n     * ```\n     * the third param `shardID` is binding with the endpoint\n     * shard 0: localhost:9500\n     * shard 1: localhost:9501\n     * ```\n     *\n     * @example\n     * ```javascript\n     * hmy.blockchain.getBalance({\n     *   address: 'one103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7',\n     *   blockNumber: 'latest'\n     * }).then(value => {\n     *   console.log(value.result);\n     * });\n     * ```\n     */\n    Blockchain.prototype.getBalance = function (_a) {\n        var address = _a.address, _b = _a.blockNumber, blockNumber = _b === void 0 ? utils_1.DefaultBlockParams.latest : _b, _c = _a.shardID, shardID = _c === void 0 ? this.messenger.currentShard : _c;\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var result;\n            return tslib_1.__generator(this, function (_d) {\n                switch (_d.label) {\n                    case 0: return [4 /*yield*/, this.messenger.send(network_1.RPCMethod.GetBalance, [crypto_1.getAddress(address).checksum, blockNumber], this.messenger.chainPrefix, shardID)];\n                    case 1:\n                        result = _d.sent();\n                        return [2 /*return*/, this.getRpcResult(result)];\n                }\n            });\n        });\n    };\n    /**\n     * Returns the current block number.\n     *\n     * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n     * @return `Promise` - The number of the most recent block.\n     *\n     * @hint\n     * ```\n     * the third param `shardID` is binding with the endpoint\n     * shard 0: localhost:9500\n     * shard 1: localhost:9501\n     * ```\n     *\n     * @example\n     * ```javascript\n     * hmy.blockchain.getBlockNumber().then((value) => {\n     *   console.log(value.result);\n     * });\n     * ```\n     */\n    Blockchain.prototype.getBlockNumber = function (shardID) {\n        if (shardID === void 0) { shardID = this.messenger.currentShard; }\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var result;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.messenger.send(network_1.RPCMethod.BlockNumber, [], this.messenger.chainPrefix, shardID)];\n                    case 1:\n                        result = _a.sent();\n                        return [2 /*return*/, this.getRpcResult(result)];\n                }\n            });\n        });\n    };\n    /**\n     * Returns a block matching the block Hash.\n     *\n     * @param blockHash the block hash\n     * @param returnObject By default it is `true`, Features in development, IGNORE it!\n     * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n     * @returns `Promise` - The block object\n     *\n     * @example\n     * ```javascript\n     * hmy.blockchain.getBlockByHash({\n     *   blockHash: '0x9cd821b576efdff61280e8857ef218fb2cff8db0cf0fb27dfceef7237042b79e',\n     * }).then((value) => {\n     *   console.log(value);\n     * });\n     * ```\n     */\n    Blockchain.prototype.getBlockByHash = function (_a) {\n        var blockHash = _a.blockHash, _b = _a.returnObject, returnObject = _b === void 0 ? true : _b, _c = _a.shardID, shardID = _c === void 0 ? this.messenger.currentShard : _c;\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var result;\n            return tslib_1.__generator(this, function (_d) {\n                switch (_d.label) {\n                    case 0: return [4 /*yield*/, this.messenger.send(network_1.RPCMethod.GetBlockByHash, [blockHash, returnObject], this.messenger.chainPrefix, shardID)];\n                    case 1:\n                        result = _d.sent();\n                        return [2 /*return*/, this.getRpcResult(result)];\n                }\n            });\n        });\n    };\n    /**\n     * Returns a block matching the block Number.\n     *\n     * @param blockNumber the block number\n     * @param returnObject By default it is `true`, Features in development, IGNORE it!\n     * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n     * @returns `Promise` - The block object\n     *\n     * @example\n     * ```javascript\n     * hmy.blockchain.getBlockByNumber({\n     *   blockNumber: '0x89',\n     * }).then((value) => {\n     *   console.log(value);\n     * });\n     * ```\n     */\n    Blockchain.prototype.getBlockByNumber = function (_a) {\n        var _b = _a.blockNumber, blockNumber = _b === void 0 ? utils_1.DefaultBlockParams.latest : _b, _c = _a.returnObject, returnObject = _c === void 0 ? true : _c, _d = _a.shardID, shardID = _d === void 0 ? this.messenger.currentShard : _d;\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var result;\n            return tslib_1.__generator(this, function (_e) {\n                switch (_e.label) {\n                    case 0: return [4 /*yield*/, this.messenger.send(network_1.RPCMethod.GetBlockByNumber, [blockNumber, returnObject], this.messenger.chainPrefix, shardID)];\n                    case 1:\n                        result = _e.sent();\n                        return [2 /*return*/, this.getRpcResult(result)];\n                }\n            });\n        });\n    };\n    /**\n     * Returns the number of transaction in a given block.\n     *\n     * @param blockHash the block number Hash\n     * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n     * @returns `Promise` -  The number of transactions in the given block.\n     *\n     * @example\n     * ```javascript\n     * hmy.blockchain.getBlockTransactionCountByHash({\n     *   blockHash: '0x4142514a238157e7fe57b9d54abedb33943507fa15b3799954c273a12705ced1'\n     * }).then((value) => {\n     *   console.log(value):\n     * });\n     * ```\n     */\n    Blockchain.prototype.getBlockTransactionCountByHash = function (_a) {\n        var blockHash = _a.blockHash, _b = _a.shardID, shardID = _b === void 0 ? this.messenger.currentShard : _b;\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var result;\n            return tslib_1.__generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0: return [4 /*yield*/, this.messenger.send(network_1.RPCMethod.GetBlockTransactionCountByHash, [blockHash], this.messenger.chainPrefix, shardID)];\n                    case 1:\n                        result = _c.sent();\n                        return [2 /*return*/, this.getRpcResult(result)];\n                }\n            });\n        });\n    };\n    /**\n     * Returns the number of transaction in a given block.\n     *\n     * @param blockNumber the block number Hash\n     * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n     * @returns `Promise` -  The number of transactions in the given block.\n     *\n     * @example\n     * ```javascript\n     * hmy.blockchain.getBlockTransactionCountByNumber({\n     *   blockNumber: '0x2403C'\n     * }).then((value) => {\n     *   console.log(value);\n     * });\n     * ```\n     */\n    Blockchain.prototype.getBlockTransactionCountByNumber = function (_a) {\n        var blockNumber = _a.blockNumber, _b = _a.shardID, shardID = _b === void 0 ? this.messenger.currentShard : _b;\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var result;\n            return tslib_1.__generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0: return [4 /*yield*/, this.messenger.send(network_1.RPCMethod.GetBlockTransactionCountByNumber, [blockNumber], this.messenger.chainPrefix, shardID)];\n                    case 1:\n                        result = _c.sent();\n                        return [2 /*return*/, this.getRpcResult(result)];\n                }\n            });\n        });\n    };\n    /**\n     * Returns a transaction based on a block hash and the transactions index position.\n     *\n     * @param blockHash the block number Hash\n     * @param index The transactions index position. **Hex Number**\n     * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n     * @returns `Promise` -  A transaction object\n     *\n     * @example\n     * ```javascript\n     * hmy.blockchain.getTransactionByBlockHashAndIndex({\n     *   blockHash: '0x4142514a238157e7fe57b9d54abedb33943507fa15b3799954c273a12705ced1',\n     *   index: '0x0'\n     * }).then((value) => {\n     *   console.log(value);\n     * });\n     * ```\n     */\n    Blockchain.prototype.getTransactionByBlockHashAndIndex = function (_a) {\n        var blockHash = _a.blockHash, index = _a.index, _b = _a.shardID, shardID = _b === void 0 ? this.messenger.currentShard : _b;\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var result;\n            return tslib_1.__generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0: return [4 /*yield*/, this.messenger.send(network_1.RPCMethod.GetTransactionByBlockHashAndIndex, [blockHash, index], this.messenger.chainPrefix, shardID)];\n                    case 1:\n                        result = _c.sent();\n                        return [2 /*return*/, this.getRpcResult(result)];\n                }\n            });\n        });\n    };\n    /**\n     * Returns a transaction based on a block number and the transactions index position.\n     *\n     * @param blockNumber the block number\n     * @param index The transactions index position. **Hex Number**\n     * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n     * @returns `Promise` -  A transaction object\n     *\n     * @example\n     * ```javascript\n     * hmy.blockchain.getTransactionByBlockNumberAndIndex({\n     *   blockNumber: '0x2403C',\n     *   index: '0x0'\n     * }).then((value) => {\n     *   console.log(value);\n     * });\n     * ```\n     */\n    Blockchain.prototype.getTransactionByBlockNumberAndIndex = function (_a) {\n        var _b = _a.blockNumber, blockNumber = _b === void 0 ? utils_1.DefaultBlockParams.latest : _b, index = _a.index, _c = _a.shardID, shardID = _c === void 0 ? this.messenger.currentShard : _c;\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var result;\n            return tslib_1.__generator(this, function (_d) {\n                switch (_d.label) {\n                    case 0: return [4 /*yield*/, this.messenger.send(network_1.RPCMethod.GetTransactionByBlockNumberAndIndex, [blockNumber, index], this.messenger.chainPrefix, shardID)];\n                    case 1:\n                        result = _d.sent();\n                        return [2 /*return*/, this.getRpcResult(result)];\n                }\n            });\n        });\n    };\n    /**\n     * Returns a transaction matching the given transaction hash.\n     *\n     * @param txnHash The transaction hash\n     * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n     * @returns `Promise` -  A transaction object\n     *\n     * @example\n     * ```javascript\n     * hmy.blockchain.getTransactionByHash({\n     *   txnHash: '0x146a0cf7e8da45b44194207c4e7785564527059483b765f9a04424554443b224'\n     * }).then((value) => {\n     *   console.log(value);\n     * });\n     * ```\n     */\n    Blockchain.prototype.getTransactionByHash = function (_a) {\n        var txnHash = _a.txnHash, _b = _a.shardID, shardID = _b === void 0 ? this.messenger.currentShard : _b;\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var result;\n            return tslib_1.__generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0: return [4 /*yield*/, this.messenger.send(network_1.RPCMethod.GetTransactionByHash, [txnHash], this.messenger.chainPrefix, shardID)];\n                    case 1:\n                        result = _c.sent();\n                        return [2 /*return*/, this.getRpcResult(result)];\n                }\n            });\n        });\n    };\n    /**\n     * Returns the receipt of a transaction by transaction hash.\n     *\n     * @param txnHash The transaction hash\n     * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n     * @returns `Promise` -  A transaction receipt object, or `null` when no receipt was found\n     *\n     * @example\n     * ```javascript\n     * hmy.blockchain.getTransactionReceipt({\n     *   txnHash: '0x146a0cf7e8da45b44194207c4e7785564527059483b765f9a04424554443b224'\n     * }).then((value) => {\n     *   console.log(value);\n     * });\n     * ```\n     */\n    Blockchain.prototype.getTransactionReceipt = function (_a) {\n        var txnHash = _a.txnHash, _b = _a.shardID, shardID = _b === void 0 ? this.messenger.currentShard : _b;\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var result;\n            return tslib_1.__generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0: return [4 /*yield*/, this.messenger.send(network_1.RPCMethod.GetTransactionReceipt, [txnHash], this.messenger.chainPrefix, shardID)];\n                    case 1:\n                        result = _c.sent();\n                        return [2 /*return*/, this.getRpcResult(result)];\n                }\n            });\n        });\n    };\n    /**\n     * Get transaction recepit from cross shard transaction\n     *\n     * @param txnHash The transaction hash\n     * @param shardID the shard id of receiver's address\n     * @returns `Promise` -  A transaction receipt object, or `null` when no receipt was found\n     *\n     * @example\n     * ```javascript\n     * // This transaction sends from shard 0 to shard 1\n     * hmy.blockchain.getCxReceiptByHash({\n     *   txnHash: '0x7fae9252fbda68d718e610bc10cf2b5c6a9cafb42d4a6b9d6e392c77d587b9ea',\n     *   shardID: 1,\n     * }).then((value) => {\n     *   console.log(value);\n     * });\n     * ```\n     */\n    Blockchain.prototype.getCxReceiptByHash = function (_a) {\n        var txnHash = _a.txnHash, shardID = _a.shardID;\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var result;\n            return tslib_1.__generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, this.messenger.send(network_1.RPCMethod.GetCXReceiptByHash, [txnHash], this.messenger.chainPrefix, shardID)];\n                    case 1:\n                        result = _b.sent();\n                        return [2 /*return*/, this.getRpcResult(result)];\n                }\n            });\n        });\n    };\n    /**\n     * Get the code at a specific address.\n     *\n     * @param address The address to get the code from (eg:smart contract)\n     * @param blockNumber (OPTIONAL) If you pass this parameter it will not use the default block\n     * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n     * @return `Promise` - The data at given `address`\n     *\n     * @example\n     * ```javascript\n     * hmy.blockchain.getCode({\n     *   address: '0x08AE1abFE01aEA60a47663bCe0794eCCD5763c19',\n     *   blockNumber: 'latest'\n     * }).then((value) => {\n     *   console.log(value);\n     * });\n     * ```\n     */\n    Blockchain.prototype.getCode = function (_a) {\n        var address = _a.address, _b = _a.blockNumber, blockNumber = _b === void 0 ? utils_1.DefaultBlockParams.latest : _b, _c = _a.shardID, shardID = _c === void 0 ? this.messenger.currentShard : _c;\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var result;\n            return tslib_1.__generator(this, function (_d) {\n                switch (_d.label) {\n                    case 0: return [4 /*yield*/, this.messenger.send(network_1.RPCMethod.GetCode, [crypto_1.getAddress(address).checksum, blockNumber], this.messenger.chainPrefix, shardID)];\n                    case 1:\n                        result = _d.sent();\n                        return [2 /*return*/, this.getRpcResult(result)];\n                }\n            });\n        });\n    };\n    /**\n     * Get the number of peers connected to.\n     *\n     * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n     * @returns `Promise` - number of peer count\n     *\n     * @example\n     * ```javascript\n     * hmy.blockchain.net_peerCount().then((value) => {\n     *   console.log(value.result);\n     * });\n     * ```\n     */\n    Blockchain.prototype.net_peerCount = function (shardID) {\n        if (shardID === void 0) { shardID = this.messenger.currentShard; }\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var result;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.messenger.send(network_1.RPCMethod.PeerCount, [], 'net', shardID)];\n                    case 1:\n                        result = _a.sent();\n                        return [2 /*return*/, this.getRpcResult(result)];\n                }\n            });\n        });\n    };\n    /**\n     * Get the version of net.\n     *\n     * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n     * @returns `Promise` - the current version.\n     *\n     * @example\n     * ```javascript\n     * hmy.blockchain.net_version().then((value) => {\n     *   console.log(value.result);\n     * });\n     * ```\n     */\n    Blockchain.prototype.net_version = function (shardID) {\n        if (shardID === void 0) { shardID = this.messenger.currentShard; }\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var result;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.messenger.send(network_1.RPCMethod.NetVersion, [], 'net', shardID)];\n                    case 1:\n                        result = _a.sent();\n                        return [2 /*return*/, this.getRpcResult(result)];\n                }\n            });\n        });\n    };\n    /**\n     * Get the protocal version.\n     *\n     * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n     * @returns `Promise` - the current protocol version.\n     *\n     * @example\n     * ```javascript\n     * hmy.blockchain.getProtocolVersion().then((value) => {\n     *   console.log(value.result);\n     * });\n     * ```\n     */\n    Blockchain.prototype.getProtocolVersion = function (shardID) {\n        if (shardID === void 0) { shardID = this.messenger.currentShard; }\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var result;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.messenger.send(network_1.RPCMethod.ProtocolVersion, [], this.messenger.chainPrefix, shardID)];\n                    case 1:\n                        result = _a.sent();\n                        return [2 /*return*/, this.getRpcResult(result)];\n                }\n            });\n        });\n    };\n    /**\n     * Get the storage at a specific position of an address\n     *\n     * @param address The address to get the storage from\n     * @param position The index position of the storage\n     * @param blockNumber by default it's `latest`.\n     * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n     *\n     * @example\n     * ```javascript\n     * hmy.blockchain.getStorageAt({\n     *   address: 'one1d0kw95t6kkljmkk9vu0zv25jraut8ngv5vrs5g',\n     *   position: '0x0'\n     * }).then((value) => {\n     *   console.log(value);\n     * });\n     * ```\n     */\n    Blockchain.prototype.getStorageAt = function (_a) {\n        var address = _a.address, position = _a.position, _b = _a.blockNumber, blockNumber = _b === void 0 ? utils_1.DefaultBlockParams.latest : _b, _c = _a.shardID, shardID = _c === void 0 ? this.messenger.currentShard : _c;\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var result;\n            return tslib_1.__generator(this, function (_d) {\n                switch (_d.label) {\n                    case 0: return [4 /*yield*/, this.messenger.send(network_1.RPCMethod.GetStorageAt, [crypto_1.getAddress(address).checksum, position, blockNumber], this.messenger.chainPrefix, shardID)];\n                    case 1:\n                        result = _d.sent();\n                        return [2 /*return*/, this.getRpcResult(result)];\n                }\n            });\n        });\n    };\n    /**\n     * Get the numbers of transactions sent from this address.\n     *\n     * @param address The address to get the numbers of transactions from\n     * @param blockNumber by default it's `latest`\n     * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n     * @return `Promise` - The number of transactions sent from the given address.\n     *\n     * @example\n     * ```javascript\n     * hmy.blockchain.getTransactionCount({\n     *   address: \"one1d0kw95t6kkljmkk9vu0zv25jraut8ngv5vrs5g\"\n     * }).then((value) => {\n     *   console.log(value.result);\n     * });\n     * ```\n     */\n    Blockchain.prototype.getTransactionCount = function (_a) {\n        var address = _a.address, _b = _a.blockNumber, blockNumber = _b === void 0 ? utils_1.DefaultBlockParams.latest : _b, _c = _a.shardID, shardID = _c === void 0 ? this.messenger.currentShard : _c;\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var result;\n            return tslib_1.__generator(this, function (_d) {\n                switch (_d.label) {\n                    case 0: return [4 /*yield*/, this.messenger.send(network_1.RPCMethod.GetTransactionCount, [crypto_1.getAddress(address).checksum, blockNumber], this.messenger.chainPrefix, shardID)];\n                    case 1:\n                        result = _d.sent();\n                        return [2 /*return*/, this.getRpcResult(result)];\n                }\n            });\n        });\n    };\n    /**\n     * Get the sharding structure of current network\n     *\n     * @return `Promise` - The sharding structure of current network.\n     *\n     * @example\n     * ```javascript\n     * hmy.blockchain.getShardingStructure().then((value) => {\n     *   console.log(value);\n     * });\n     * ```\n     */\n    Blockchain.prototype.getShardingStructure = function () {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var result;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.messenger.send(network_1.RPCMethod.GetShardingStructure, [], this.messenger.chainPrefix)];\n                    case 1:\n                        result = _a.sent();\n                        return [2 /*return*/, this.getRpcResult(result)];\n                }\n            });\n        });\n    };\n    /**\n     * Sends a signed transaction to the network.\n     *\n     * @param transaction `Object` - The transaction object to send:\n     * @return The **callbalck** will return the 32 bytes transaction hash\n     *\n     * @example\n     * ```javascript\n     * // add privateKey to wallet\n     * const privateKey = '45e497bd45a9049bcb649016594489ac67b9f052a6cdf5cb74ee2427a60bf25e';\n     * hmy.wallet.addByPrivateKey(privateKey);\n     *\n     * async function transfer() {\n     *   const txn = hmy.transactions.newTx({\n     *     //  token send to\n     *     to: 'one166axnkjmghkf3df7xfvd0hn4dft8kemrza4cd2',\n     *     // amount to send\n     *     value: '10000',\n     *     // gas limit, you can use string\n     *     gasLimit: '210000',\n     *     // send token from shardID\n     *     shardID: 0,\n     *     // send token to toShardID\n     *     toShardID: 0,\n     *     // gas Price, you can use Unit class, and use Gwei, then remember to use toWei(), which will be transformed to BN\n     *     gasPrice: new hmy.utils.Unit('100').asGwei().toWei(),\n     *   });\n     *\n     *   // sign the transaction use wallet;\n     *   const signedTxn = await hmy.wallet.signTransaction(txn);\n     *   const txnHash = await hmy.blockchain.sendTransaction(signedTxn);\n     *   console.log(txnHash.result);\n     * }\n     *\n     * transfer();\n     * ```\n     */\n    Blockchain.prototype.sendTransaction = function (transaction) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var result;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!transaction.isSigned() || !transaction) {\n                            throw new Error('transaction is not signed or not exist');\n                        }\n                        return [4 /*yield*/, this.messenger.send(network_1.RPCMethod.SendRawTransaction, [transaction.getRawTransaction()], this.messenger.chainPrefix, typeof transaction.txParams.shardID === 'string'\n                                ? Number.parseInt(transaction.txParams.shardID, 10)\n                                : transaction.txParams.shardID)];\n                    case 1:\n                        result = _a.sent();\n                        return [2 /*return*/, this.getRpcResult(result)];\n                }\n            });\n        });\n    };\n    /**\n     * Sends a raw transaction to the network.\n     *\n     * @param transaction `Object` - The transaction object to send:\n     * @return The **callbalck** will return the 32 bytes transaction hash\n     *\n     * @example\n     * ```javascript\n     * // add privateKey to wallet\n     * const privateKey = '45e497bd45a9049bcb649016594489ac67b9f052a6cdf5cb74ee2427a60bf25e';\n     * hmy.wallet.addByPrivateKey(privateKey);\n     *\n     * async function transfer() {\n     *   const txn = hmy.transactions.newTx({\n     *     //  token send to\n     *     to: 'one166axnkjmghkf3df7xfvd0hn4dft8kemrza4cd2',\n     *     // amount to send\n     *     value: '10000',\n     *     // gas limit, you can use string\n     *     gasLimit: '210000',\n     *     // send token from shardID\n     *     shardID: 0,\n     *     // send token to toShardID\n     *     toShardID: 0,\n     *     // gas Price, you can use Unit class, and use Gwei, then remember to use toWei(), which will be transformed to BN\n     *     gasPrice: new hmy.utils.Unit('100').asGwei().toWei(),\n     *   });\n     *\n     *   // sign the transaction use wallet;\n     *   const signedTxn = await hmy.wallet.signTransaction(txn);\n     *   recovered = signedTxn.recover(signedTxn.rawTransaction);\n     *\n     *   const txnHash = await hmy.blockchain.sendRawTransaction(recovered);\n     *   console.log(txnHash);\n     * }\n     *\n     * transfer();\n     * ```\n     */\n    Blockchain.prototype.sendRawTransaction = function (transaction) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var _a, txn, result;\n            return tslib_1.__generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (!transaction.isSigned() || !transaction) {\n                            throw new Error('transaction is not signed or not exist');\n                        }\n                        return [4 /*yield*/, transaction.sendTransaction()];\n                    case 1:\n                        _a = tslib_1.__read.apply(void 0, [_b.sent(), 2]), txn = _a[0], result = _a[1];\n                        if (txn.isPending()) {\n                            return [2 /*return*/, result];\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * send a transaction and check whether it exists\n     *\n     * @param transaction `Object` - The transaction object to send:\n     * @return The **callbalck** will return the 32 bytes transaction hash\n     *\n     * @example\n     * ```javascript\n     * // add privateKey to wallet\n     * const privateKey = '45e497bd45a9049bcb649016594489ac67b9f052a6cdf5cb74ee2427a60bf25e';\n     * hmy.wallet.addByPrivateKey(privateKey);\n     *\n     * async function transfer() {\n     *   const txn = hmy.transactions.newTx({\n     *     //  token send to\n     *     to: 'one166axnkjmghkf3df7xfvd0hn4dft8kemrza4cd2',\n     *     // amount to send\n     *     value: '10000',\n     *     // gas limit, you can use string\n     *     gasLimit: '210000',\n     *     // send token from shardID\n     *     shardID: 0,\n     *     // send token to toShardID\n     *     toShardID: 0,\n     *     // gas Price, you can use Unit class, and use Gwei, then remember to use toWei(), which will be transformed to BN\n     *     gasPrice: new hmy.utils.Unit('100').asGwei().toWei(),\n     *   });\n     *\n     *   // sign the transaction use wallet;\n     *   const signedTxn = await hmy.wallet.signTransaction(txn);\n     *   const txnHash = await hmy.blockchain.createObservedTransaction(signedTxn);\n     *   console.log(txnHash);\n     * }\n     *\n     * transfer();\n     * ```\n     */\n    Blockchain.prototype.createObservedTransaction = function (transaction) {\n        try {\n            transaction.sendTransaction().then(function (response) {\n                var _a = tslib_1.__read(response, 2), txReturned = _a[0], TranID = _a[1];\n                txReturned.confirm(TranID).then(function (txConfirmed) {\n                    transaction.emitter.resolve(txConfirmed);\n                });\n            });\n            return transaction.emitter;\n        }\n        catch (err) {\n            throw err;\n        }\n    };\n    /**\n     * send raw staking transaction\n     *\n     * @param staking\n     * @ignore\n     *\n     * @warning\n     * ```\n     * At present, this function is not implement yet, will Coming soon!!!\n     * ```\n     */\n    Blockchain.prototype.sendRawStakingTransaction = function (staking) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var _a, txn, result;\n            return tslib_1.__generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (!staking.isSigned() || !staking) {\n                            throw new Error('staking transaction is not signed or not exist');\n                        }\n                        return [4 /*yield*/, staking.sendTransaction()];\n                    case 1:\n                        _a = tslib_1.__read.apply(void 0, [_b.sent(), 2]), txn = _a[0], result = _a[1];\n                        if (txn.isPending()) {\n                            return [2 /*return*/, result];\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * send raw staking transaction and check whether it exists\n     *\n     * @param staking\n     * @ignore\n     *\n     * @warning\n     * ```\n     * At present, this function is not implement yet, will Coming soon!!!\n     * ```\n     */\n    Blockchain.prototype.createObservedStakingTransaction = function (staking) {\n        try {\n            staking.sendTransaction().then(function (response) {\n                var _a = tslib_1.__read(response, 2), txReturned = _a[0], TranID = _a[1];\n                txReturned.confirm(TranID).then(function (txConfirmed) {\n                    staking.emitter.resolve(txConfirmed);\n                });\n            });\n            return staking.emitter;\n        }\n        catch (err) {\n            throw err;\n        }\n    };\n    /**\n     * Executes a message call or transaction and returns the amount of the gas used.\n     *\n     * @param to the address will send to\n     * @param data the data will send to that address\n     * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n     * @return `promise` -  the used gas for the simulated call/transaction.\n     *\n     * @warning\n     * ```\n     * At present, this function hmy_estimateGas is not implement yet, will Coming soon!!!\n     * ```\n     *\n     * @example\n     * ```javascript\n     * hmy.blockchain.estimateGas({\n     *   to: 'one1d0kw95t6kkljmkk9vu0zv25jraut8ngv5vrs5g',\n     *   data: '0xc6888fa10000000000000000000000000000000000000000000000000000000000000003'\n     * }).then((value) => {\n     *   console.log(value);\n     * });\n     * ```\n     */\n    Blockchain.prototype.estimateGas = function (_a) {\n        var to = _a.to, data = _a.data, _b = _a.shardID, shardID = _b === void 0 ? this.messenger.currentShard : _b;\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var result;\n            return tslib_1.__generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0: return [4 /*yield*/, this.messenger.send(network_1.RPCMethod.EstimateGas, [{ to: crypto_1.getAddress(to).checksum, data: data }], this.messenger.chainPrefix, shardID)];\n                    case 1:\n                        result = _c.sent();\n                        return [2 /*return*/, this.getRpcResult(result)];\n                }\n            });\n        });\n    };\n    /**\n     * Returns the current gas price oracle. The gas price is determined by the last few blocks median gas price.\n     *\n     * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n     * @return `promise` - Number string of the current gas price in wei.\n     *\n     * @example\n     * ```javascript\n     * hmy.blockchain.gasPrice().then((value) => {\n     *   console.log(value);\n     * });\n     * ```\n     */\n    Blockchain.prototype.gasPrice = function (shardID) {\n        if (shardID === void 0) { shardID = this.messenger.currentShard; }\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var result;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.messenger.send(network_1.RPCMethod.GasPrice, [], this.messenger.chainPrefix, shardID)];\n                    case 1:\n                        result = _a.sent();\n                        return [2 /*return*/, this.getRpcResult(result)];\n                }\n            });\n        });\n    };\n    /**\n     * Executes a message call transaction,\n     * which is directly executed in the VM of the node, but never mined into the blockchain.\n     *\n     * @param payload some data you want put into these fucntions\n     * @param blockNumber by default it's `latest`\n     * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n     *\n     * @example\n     * ```javascript\n     * hmy.blockchain.call({\n     *   to: \"0x08AE1abFE01aEA60a47663bCe0794eCCD5763c19\",\n     * }).then((value) => {\n     *   console.log(value);\n     * });\n     * ```\n     */\n    Blockchain.prototype.call = function (_a) {\n        var payload = _a.payload, _b = _a.blockNumber, blockNumber = _b === void 0 ? utils_1.DefaultBlockParams.latest : _b, _c = _a.shardID, shardID = _c === void 0 ? this.messenger.currentShard : _c;\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var result;\n            return tslib_1.__generator(this, function (_d) {\n                switch (_d.label) {\n                    case 0: return [4 /*yield*/, this.messenger.send(network_1.RPCMethod.Call, [payload, blockNumber], this.messenger.chainPrefix, shardID)];\n                    case 1:\n                        result = _d.sent();\n                        return [2 /*return*/, this.getRpcResult(result)];\n                }\n            });\n        });\n    };\n    /**\n     * Return new pending Transactions\n     *\n     * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n     *\n     * @example\n     * ```javascript\n     * const hmy = new Harmony(\n     *   // rpc url\n     *   'ws://api.s0.b.hmny.io/',\n     *   {\n     *     // chainType set to Harmony\n     *     chainType: ChainType.Harmony,\n     *     // chainType set to HmyLocal\n     *     chainId: ChainID.HmyLocal,\n     *   },\n     * );\n     *\n     * const tmp = hmy.blockchain.newPendingTransactions();\n     * console.log(tmp)\n     * ```\n     */\n    Blockchain.prototype.newPendingTransactions = function (shardID) {\n        if (shardID === void 0) { shardID = this.messenger.currentShard; }\n        if (this.messenger.provider instanceof network_1.WSProvider) {\n            return new network_1.NewPendingTransactions(this.messenger, shardID);\n        }\n        else {\n            throw new Error('HttpProvider does not support this feature');\n        }\n    };\n    /**\n     *\n     * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n     *\n     * @example\n     * ```javascript\n     * const hmy = new Harmony(\n     *   // rpc url\n     *   'ws://api.s0.b.hmny.io/',\n     *   {\n     *     // chainType set to Harmony\n     *     chainType: ChainType.Harmony,\n     *     // chainType set to HmyLocal\n     *     chainId: ChainID.HmyLocal,\n     *   },\n     * );\n     *\n     * const tmp = hmy.blockchain.newBlockHeaders();\n     * console.log(tmp)\n     * ```\n     */\n    Blockchain.prototype.newBlockHeaders = function (shardID) {\n        if (shardID === void 0) { shardID = this.messenger.currentShard; }\n        if (this.messenger.provider instanceof network_1.WSProvider) {\n            return new network_1.NewHeaders(this.messenger, shardID);\n        }\n        else {\n            throw new Error('HttpProvider does not support this feature');\n        }\n    };\n    /**\n     *\n     * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n     *\n     * @example\n     * ```javascript\n     * const hmy = new Harmony(\n     *   // rpc url\n     *   'ws://api.s0.b.hmny.io/',\n     *   {\n     *     // chainType set to Harmony\n     *     chainType: ChainType.Harmony,\n     *     // chainType set to HmyLocal\n     *     chainId: ChainID.HmyLocal,\n     *   },\n     * );\n     *\n     * const tmp = hmy.blockchain.syncing();\n     * console.log(tmp)\n     * ```\n     */\n    Blockchain.prototype.syncing = function (shardID) {\n        if (shardID === void 0) { shardID = this.messenger.currentShard; }\n        if (this.messenger.provider instanceof network_1.WSProvider) {\n            return new network_1.Syncing(this.messenger, shardID);\n        }\n        else {\n            throw new Error('HttpProvider does not support this feature');\n        }\n    };\n    /**\n     *\n     * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n     *\n     * @example\n     * ```javascript\n     * const hmy = new Harmony(\n     *   // rpc url\n     *   'ws://api.s0.b.hmny.io/',\n     *   {\n     *     // chainType set to Harmony\n     *     chainType: ChainType.Harmony,\n     *     // chainType set to HmyLocal\n     *     chainId: ChainID.HmyLocal,\n     *   },\n     * );\n     *\n     * const tmp = hmy.blockchain.logs({\n     *   from: '0x12'\n     * });\n     * console.log(tmp)\n     * ```\n     */\n    Blockchain.prototype.logs = function (options, shardID) {\n        if (shardID === void 0) { shardID = this.messenger.currentShard; }\n        if (this.messenger.provider instanceof network_1.WSProvider) {\n            return new network_1.LogSub(options, this.messenger, shardID);\n        }\n        else {\n            throw new Error('HttpProvider does not support this feature');\n        }\n    };\n    tslib_1.__decorate([\n        utils_1.assertObject({\n            address: ['isValidAddress', utils_1.AssertType.required],\n            blockNumber: ['isBlockNumber', utils_1.AssertType.optional],\n            shardID: ['isNumber', utils_1.AssertType.optional],\n        }),\n        tslib_1.__metadata(\"design:type\", Function),\n        tslib_1.__metadata(\"design:paramtypes\", [Object]),\n        tslib_1.__metadata(\"design:returntype\", Promise)\n    ], Blockchain.prototype, \"getBalance\", null);\n    tslib_1.__decorate([\n        utils_1.assertObject({\n            blockHash: ['isHash', utils_1.AssertType.required],\n            returnObject: ['isBoolean', utils_1.AssertType.optional],\n            shardID: ['isNumber', utils_1.AssertType.optional],\n        }),\n        tslib_1.__metadata(\"design:type\", Function),\n        tslib_1.__metadata(\"design:paramtypes\", [Object]),\n        tslib_1.__metadata(\"design:returntype\", Promise)\n    ], Blockchain.prototype, \"getBlockByHash\", null);\n    tslib_1.__decorate([\n        utils_1.assertObject({\n            blockNumber: ['isBlockNumber', utils_1.AssertType.optional],\n            returnObject: ['isBoolean', utils_1.AssertType.optional],\n            shardID: ['isNumber', utils_1.AssertType.optional],\n        }),\n        tslib_1.__metadata(\"design:type\", Function),\n        tslib_1.__metadata(\"design:paramtypes\", [Object]),\n        tslib_1.__metadata(\"design:returntype\", Promise)\n    ], Blockchain.prototype, \"getBlockByNumber\", null);\n    tslib_1.__decorate([\n        utils_1.assertObject({\n            blockHash: ['isHash', utils_1.AssertType.required],\n            shardID: ['isNumber', utils_1.AssertType.optional],\n        }),\n        tslib_1.__metadata(\"design:type\", Function),\n        tslib_1.__metadata(\"design:paramtypes\", [Object]),\n        tslib_1.__metadata(\"design:returntype\", Promise)\n    ], Blockchain.prototype, \"getBlockTransactionCountByHash\", null);\n    tslib_1.__decorate([\n        utils_1.assertObject({\n            blockNumber: ['isBlockNumber', utils_1.AssertType.required],\n            shardID: ['isNumber', utils_1.AssertType.optional],\n        }),\n        tslib_1.__metadata(\"design:type\", Function),\n        tslib_1.__metadata(\"design:paramtypes\", [Object]),\n        tslib_1.__metadata(\"design:returntype\", Promise)\n    ], Blockchain.prototype, \"getBlockTransactionCountByNumber\", null);\n    tslib_1.__decorate([\n        utils_1.assertObject({\n            blockHash: ['isHash', utils_1.AssertType.required],\n            index: ['isHex', utils_1.AssertType.required],\n            shardID: ['isNumber', utils_1.AssertType.optional],\n        }),\n        tslib_1.__metadata(\"design:type\", Function),\n        tslib_1.__metadata(\"design:paramtypes\", [Object]),\n        tslib_1.__metadata(\"design:returntype\", Promise)\n    ], Blockchain.prototype, \"getTransactionByBlockHashAndIndex\", null);\n    tslib_1.__decorate([\n        utils_1.assertObject({\n            blockNumber: ['isBlockNumber', utils_1.AssertType.optional],\n            index: ['isHex', utils_1.AssertType.required],\n            shardID: ['isNumber', utils_1.AssertType.optional],\n        }),\n        tslib_1.__metadata(\"design:type\", Function),\n        tslib_1.__metadata(\"design:paramtypes\", [Object]),\n        tslib_1.__metadata(\"design:returntype\", Promise)\n    ], Blockchain.prototype, \"getTransactionByBlockNumberAndIndex\", null);\n    tslib_1.__decorate([\n        utils_1.assertObject({\n            txnHash: ['isHash', utils_1.AssertType.required],\n            shardID: ['isNumber', utils_1.AssertType.optional],\n        }),\n        tslib_1.__metadata(\"design:type\", Function),\n        tslib_1.__metadata(\"design:paramtypes\", [Object]),\n        tslib_1.__metadata(\"design:returntype\", Promise)\n    ], Blockchain.prototype, \"getTransactionByHash\", null);\n    tslib_1.__decorate([\n        utils_1.assertObject({\n            txnHash: ['isString', utils_1.AssertType.required],\n            shardID: ['isNumber', utils_1.AssertType.optional],\n        }),\n        tslib_1.__metadata(\"design:type\", Function),\n        tslib_1.__metadata(\"design:paramtypes\", [Object]),\n        tslib_1.__metadata(\"design:returntype\", Promise)\n    ], Blockchain.prototype, \"getTransactionReceipt\", null);\n    tslib_1.__decorate([\n        utils_1.assertObject({\n            txnHash: ['isString', utils_1.AssertType.required],\n            shardID: ['isNumber', utils_1.AssertType.required],\n        }),\n        tslib_1.__metadata(\"design:type\", Function),\n        tslib_1.__metadata(\"design:paramtypes\", [Object]),\n        tslib_1.__metadata(\"design:returntype\", Promise)\n    ], Blockchain.prototype, \"getCxReceiptByHash\", null);\n    tslib_1.__decorate([\n        utils_1.assertObject({\n            address: ['isValidAddress', utils_1.AssertType.required],\n            blockNumber: ['isBlockNumber', utils_1.AssertType.optional],\n            shardID: ['isNumber', utils_1.AssertType.optional],\n        }),\n        tslib_1.__metadata(\"design:type\", Function),\n        tslib_1.__metadata(\"design:paramtypes\", [Object]),\n        tslib_1.__metadata(\"design:returntype\", Promise)\n    ], Blockchain.prototype, \"getCode\", null);\n    tslib_1.__decorate([\n        utils_1.assertObject({\n            address: ['isValidAddress', utils_1.AssertType.required],\n            position: ['isHex', utils_1.AssertType.required],\n            blockNumber: ['isBlockNumber', utils_1.AssertType.optional],\n            shardID: ['isNumber', utils_1.AssertType.optional],\n        }),\n        tslib_1.__metadata(\"design:type\", Function),\n        tslib_1.__metadata(\"design:paramtypes\", [Object]),\n        tslib_1.__metadata(\"design:returntype\", Promise)\n    ], Blockchain.prototype, \"getStorageAt\", null);\n    tslib_1.__decorate([\n        utils_1.assertObject({\n            address: ['isValidAddress', utils_1.AssertType.required],\n            blockNumber: ['isBlockNumber', utils_1.AssertType.optional],\n            shardID: ['isNumber', utils_1.AssertType.optional],\n        }),\n        tslib_1.__metadata(\"design:type\", Function),\n        tslib_1.__metadata(\"design:paramtypes\", [Object]),\n        tslib_1.__metadata(\"design:returntype\", Promise)\n    ], Blockchain.prototype, \"getTransactionCount\", null);\n    tslib_1.__decorate([\n        utils_1.assertObject({\n            to: ['isValidAddress', utils_1.AssertType.optional],\n            data: ['isHex', utils_1.AssertType.optional],\n            shardID: ['isNumber', utils_1.AssertType.optional],\n        }),\n        tslib_1.__metadata(\"design:type\", Function),\n        tslib_1.__metadata(\"design:paramtypes\", [Object]),\n        tslib_1.__metadata(\"design:returntype\", Promise)\n    ], Blockchain.prototype, \"estimateGas\", null);\n    return Blockchain;\n}());\nexports.Blockchain = Blockchain;\n"},"sourceMaps":{"js":{"version":3,"file":"blockchain.js","sourceRoot":"","sources":["../src/blockchain.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * ## About this package\n *\n * `@harmony-js/core` is collection of modules to guide user to interacte with harmony blockchian.\n *\n * Develops can use this package to:\n * - Create a `harmony` instance\n * - Create a `harmonyExtension` instance, which support fo `MathWallet`\n * - Get block and transaction by hash or blocknumber\n * - Send transaction\n * - Get balance of address\n *\n * ## How to use `@harmony-core`\n * ### Dependencies\n * - @harmony-js/core\n * - @harmony-js/utils\n *\n * ### Step 1: Initialize the Harmony instance\n * Before using harmony-core package, you should initialize the Harmony instance\n * ```javascript\n * // import or require Harmony class\n * const { Harmony } = require('@harmony-js/core');\n * // import or require settings\n * const { ChainID, ChainType } = require('@harmony-js/utils');\n *\n * // initialize the Harmony instance\n * const hmy = new Harmony(\n *   // rpc url\n *   'https://api.s0.b.hmny.io/',\n *   {\n *     // chainType set to Harmony\n *     chainType: ChainType.Harmony,\n *     // chainType set to HmyLocal\n *     chainId: ChainID.HmyLocal,\n *   },\n * );\n * ```\n *\n * ### Step 2: Use the instance to call specific functions\n * Example 1: get balance\n * ```javascript\n * // get balance\n * hmy.blockchain.getBalance({\n *   address: 'one103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7',\n *   blockNumber: 'latest'\n * }).then((value) => {\n *   console.log(value.result);\n * });\n * ```\n *\n * Example 2: send transaction\n * ```\n * // add privateKey to wallet\n * const privateKey = '45e497bd45a9049bcb649016594489ac67b9f052a6cdf5cb74ee2427a60bf25e';\n * hmy.wallet.addByPrivateKey(privateKey);\n *\n * async function transfer() {\n *   const txn = hmy.transactions.newTx({\n *     //  token send to\n *     to: 'one166axnkjmghkf3df7xfvd0hn4dft8kemrza4cd2',\n *     // amount to send\n *     value: '10000',\n *     // gas limit, you can use string\n *     gasLimit: '210000',\n *     // send token from shardID\n *     shardID: 0,\n *     // send token to toShardID\n *     toShardID: 0,\n *     // gas Price, you can use Unit class, and use Gwei, then remember to use toWei(), which will be transformed to BN\n *     gasPrice: new hmy.utils.Unit('100').asGwei().toWei(),\n *   });\n *\n *   // sign the transaction use wallet;\n *   const signedTxn = await hmy.wallet.signTransaction(txn);\n *   const txnHash = await hmy.blockchain.sendTransaction(signedTxn);\n *   console.log(txnHash.result);\n * }\n *\n * transfer();\n * ```\n *\n * @packageDocumentation\n * @module harmony-core\n */\n\nimport {\n  RPCMethod,\n  Messenger,\n  ResponseMiddleware,\n  WSProvider,\n  NewPendingTransactions,\n  NewHeaders,\n  LogSub,\n  Syncing,\n} from '@harmony-js/network';\n\nimport {\n  assertObject,\n  AssertType,\n  // HarmonyCore,\n  DefaultBlockParams,\n} from '@harmony-js/utils';\n\nimport { getAddress } from '@harmony-js/crypto';\n\nimport { Transaction } from '@harmony-js/transaction';\nimport { StakingTransaction } from '@harmony-js/staking';\n\nclass Blockchain {\n  /**\n   * @hidden\n   */\n  messenger: Messenger;\n\n  /**\n   * @hidden\n   */\n  constructor(messenger: Messenger) {\n    this.messenger = messenger;\n  }\n\n  /**\n   * @hidden\n   */\n  setMessenger(messenger: Messenger) {\n    this.messenger = messenger;\n  }\n\n  /**\n   *\n   * @hidden\n   */\n  getRpcResult(result: any) {\n    if (result instanceof ResponseMiddleware) {\n      return result.getRaw;\n    } else {\n      return result;\n    }\n  }\n\n  /**\n   * Get the balance of an address at a given block.\n   *\n   * @param address the address to get the balance of.\n   * @param blockNumber (option) If you pass this parameter it will not use the default block set with `DefaultBlockParams.latest`\n   * @param shardID (option) If you pass this parameter it will not use the default block set with `this.messenger.currentShard`\n   *\n   * @returns The current balance for the given address in wei.\n   *\n   * @hint\n   * ```\n   * the third param `shardID` is binding with the endpoint\n   * shard 0: localhost:9500\n   * shard 1: localhost:9501\n   * ```\n   *\n   * @example\n   * ```javascript\n   * hmy.blockchain.getBalance({\n   *   address: 'one103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7',\n   *   blockNumber: 'latest'\n   * }).then(value => {\n   *   console.log(value.result);\n   * });\n   * ```\n   */\n  @assertObject({\n    address: ['isValidAddress', AssertType.required],\n    blockNumber: ['isBlockNumber', AssertType.optional],\n    shardID: ['isNumber', AssertType.optional],\n  })\n  async getBalance({\n    address,\n    blockNumber = DefaultBlockParams.latest,\n    shardID = this.messenger.currentShard,\n  }: {\n    address: string;\n    blockNumber?: string;\n    shardID?: number;\n  }) {\n    const result = await this.messenger.send(\n      RPCMethod.GetBalance,\n      [getAddress(address).checksum, blockNumber],\n      this.messenger.chainPrefix,\n      shardID,\n    );\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Returns the current block number.\n   *\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   * @return `Promise` - The number of the most recent block.\n   *\n   * @hint\n   * ```\n   * the third param `shardID` is binding with the endpoint\n   * shard 0: localhost:9500\n   * shard 1: localhost:9501\n   * ```\n   *\n   * @example\n   * ```javascript\n   * hmy.blockchain.getBlockNumber().then((value) => {\n   *   console.log(value.result);\n   * });\n   * ```\n   */\n  async getBlockNumber(shardID: number = this.messenger.currentShard) {\n    const result = await this.messenger.send(\n      RPCMethod.BlockNumber,\n      [],\n      this.messenger.chainPrefix,\n      shardID,\n    );\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Returns a block matching the block Hash.\n   *\n   * @param blockHash the block hash\n   * @param returnObject By default it is `true`, Features in development, IGNORE it!\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   * @returns `Promise` - The block object\n   *\n   * @example\n   * ```javascript\n   * hmy.blockchain.getBlockByHash({\n   *   blockHash: '0x9cd821b576efdff61280e8857ef218fb2cff8db0cf0fb27dfceef7237042b79e',\n   * }).then((value) => {\n   *   console.log(value);\n   * });\n   * ```\n   */\n  @assertObject({\n    blockHash: ['isHash', AssertType.required],\n    returnObject: ['isBoolean', AssertType.optional],\n    shardID: ['isNumber', AssertType.optional],\n  })\n  async getBlockByHash({\n    blockHash,\n    returnObject = true,\n    shardID = this.messenger.currentShard,\n  }: {\n    blockHash: string;\n    returnObject?: boolean;\n    shardID?: number;\n  }) {\n    const result = await this.messenger.send(\n      RPCMethod.GetBlockByHash,\n      [blockHash, returnObject],\n      this.messenger.chainPrefix,\n      shardID,\n    );\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Returns a block matching the block Number.\n   *\n   * @param blockNumber the block number\n   * @param returnObject By default it is `true`, Features in development, IGNORE it!\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   * @returns `Promise` - The block object\n   *\n   * @example\n   * ```javascript\n   * hmy.blockchain.getBlockByNumber({\n   *   blockNumber: '0x89',\n   * }).then((value) => {\n   *   console.log(value);\n   * });\n   * ```\n   */\n  @assertObject({\n    blockNumber: ['isBlockNumber', AssertType.optional],\n    returnObject: ['isBoolean', AssertType.optional],\n    shardID: ['isNumber', AssertType.optional],\n  })\n  async getBlockByNumber({\n    blockNumber = DefaultBlockParams.latest,\n    returnObject = true,\n    shardID = this.messenger.currentShard,\n  }: {\n    blockNumber?: string;\n    returnObject?: boolean;\n    shardID?: number;\n  }) {\n    const result = await this.messenger.send(\n      RPCMethod.GetBlockByNumber,\n      [blockNumber, returnObject],\n      this.messenger.chainPrefix,\n      shardID,\n    );\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Returns the number of transaction in a given block.\n   *\n   * @param blockHash the block number Hash\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   * @returns `Promise` -  The number of transactions in the given block.\n   *\n   * @example\n   * ```javascript\n   * hmy.blockchain.getBlockTransactionCountByHash({\n   *   blockHash: '0x4142514a238157e7fe57b9d54abedb33943507fa15b3799954c273a12705ced1'\n   * }).then((value) => {\n   *   console.log(value):\n   * });\n   * ```\n   */\n  @assertObject({\n    blockHash: ['isHash', AssertType.required],\n    shardID: ['isNumber', AssertType.optional],\n  })\n  async getBlockTransactionCountByHash({\n    blockHash,\n    shardID = this.messenger.currentShard,\n  }: {\n    blockHash: string;\n    shardID?: number;\n  }) {\n    const result = await this.messenger.send(\n      RPCMethod.GetBlockTransactionCountByHash,\n      [blockHash],\n      this.messenger.chainPrefix,\n      shardID,\n    );\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Returns the number of transaction in a given block.\n   *\n   * @param blockNumber the block number Hash\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   * @returns `Promise` -  The number of transactions in the given block.\n   *\n   * @example\n   * ```javascript\n   * hmy.blockchain.getBlockTransactionCountByNumber({\n   *   blockNumber: '0x2403C'\n   * }).then((value) => {\n   *   console.log(value);\n   * });\n   * ```\n   */\n  @assertObject({\n    blockNumber: ['isBlockNumber', AssertType.required],\n    shardID: ['isNumber', AssertType.optional],\n  })\n  async getBlockTransactionCountByNumber({\n    blockNumber,\n    shardID = this.messenger.currentShard,\n  }: {\n    blockNumber: string;\n    shardID?: number;\n  }) {\n    const result = await this.messenger.send(\n      RPCMethod.GetBlockTransactionCountByNumber,\n      [blockNumber],\n      this.messenger.chainPrefix,\n      shardID,\n    );\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Returns a transaction based on a block hash and the transactions index position.\n   *\n   * @param blockHash the block number Hash\n   * @param index The transactions index position. **Hex Number**\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   * @returns `Promise` -  A transaction object\n   *\n   * @example\n   * ```javascript\n   * hmy.blockchain.getTransactionByBlockHashAndIndex({\n   *   blockHash: '0x4142514a238157e7fe57b9d54abedb33943507fa15b3799954c273a12705ced1',\n   *   index: '0x0'\n   * }).then((value) => {\n   *   console.log(value);\n   * });\n   * ```\n   */\n  @assertObject({\n    blockHash: ['isHash', AssertType.required],\n    index: ['isHex', AssertType.required],\n    shardID: ['isNumber', AssertType.optional],\n  })\n  async getTransactionByBlockHashAndIndex({\n    blockHash,\n    index,\n    shardID = this.messenger.currentShard,\n  }: {\n    blockHash: string;\n    index: string;\n    shardID?: number;\n  }) {\n    const result = await this.messenger.send(\n      RPCMethod.GetTransactionByBlockHashAndIndex,\n      [blockHash, index],\n      this.messenger.chainPrefix,\n      shardID,\n    );\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Returns a transaction based on a block number and the transactions index position.\n   *\n   * @param blockNumber the block number\n   * @param index The transactions index position. **Hex Number**\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   * @returns `Promise` -  A transaction object\n   *\n   * @example\n   * ```javascript\n   * hmy.blockchain.getTransactionByBlockNumberAndIndex({\n   *   blockNumber: '0x2403C',\n   *   index: '0x0'\n   * }).then((value) => {\n   *   console.log(value);\n   * });\n   * ```\n   */\n  @assertObject({\n    blockNumber: ['isBlockNumber', AssertType.optional],\n    index: ['isHex', AssertType.required],\n    shardID: ['isNumber', AssertType.optional],\n  })\n  async getTransactionByBlockNumberAndIndex({\n    blockNumber = DefaultBlockParams.latest,\n    index,\n    shardID = this.messenger.currentShard,\n  }: {\n    blockNumber?: string;\n    index: string;\n    shardID?: number;\n  }) {\n    const result = await this.messenger.send(\n      RPCMethod.GetTransactionByBlockNumberAndIndex,\n      [blockNumber, index],\n      this.messenger.chainPrefix,\n      shardID,\n    );\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Returns a transaction matching the given transaction hash.\n   *\n   * @param txnHash The transaction hash\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   * @returns `Promise` -  A transaction object\n   *\n   * @example\n   * ```javascript\n   * hmy.blockchain.getTransactionByHash({\n   *   txnHash: '0x146a0cf7e8da45b44194207c4e7785564527059483b765f9a04424554443b224'\n   * }).then((value) => {\n   *   console.log(value);\n   * });\n   * ```\n   */\n  @assertObject({\n    txnHash: ['isHash', AssertType.required],\n    shardID: ['isNumber', AssertType.optional],\n  })\n  async getTransactionByHash({\n    txnHash,\n    shardID = this.messenger.currentShard,\n  }: {\n    txnHash: string;\n    shardID?: number;\n  }) {\n    const result = await this.messenger.send(\n      RPCMethod.GetTransactionByHash,\n      [txnHash],\n      this.messenger.chainPrefix,\n      shardID,\n    );\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Returns the receipt of a transaction by transaction hash.\n   *\n   * @param txnHash The transaction hash\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   * @returns `Promise` -  A transaction receipt object, or `null` when no receipt was found\n   *\n   * @example\n   * ```javascript\n   * hmy.blockchain.getTransactionReceipt({\n   *   txnHash: '0x146a0cf7e8da45b44194207c4e7785564527059483b765f9a04424554443b224'\n   * }).then((value) => {\n   *   console.log(value);\n   * });\n   * ```\n   */\n  @assertObject({\n    txnHash: ['isString', AssertType.required],\n    shardID: ['isNumber', AssertType.optional],\n  })\n  async getTransactionReceipt({\n    txnHash,\n    shardID = this.messenger.currentShard,\n  }: {\n    txnHash: string;\n    shardID?: number;\n  }) {\n    const result = await this.messenger.send(\n      RPCMethod.GetTransactionReceipt,\n      [txnHash],\n      this.messenger.chainPrefix,\n      shardID,\n    );\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Get transaction recepit from cross shard transaction\n   *\n   * @param txnHash The transaction hash\n   * @param shardID the shard id of receiver's address\n   * @returns `Promise` -  A transaction receipt object, or `null` when no receipt was found\n   *\n   * @example\n   * ```javascript\n   * // This transaction sends from shard 0 to shard 1\n   * hmy.blockchain.getCxReceiptByHash({\n   *   txnHash: '0x7fae9252fbda68d718e610bc10cf2b5c6a9cafb42d4a6b9d6e392c77d587b9ea',\n   *   shardID: 1,\n   * }).then((value) => {\n   *   console.log(value);\n   * });\n   * ```\n   */\n  @assertObject({\n    txnHash: ['isString', AssertType.required],\n    shardID: ['isNumber', AssertType.required],\n  })\n  async getCxReceiptByHash({ txnHash, shardID }: { txnHash: string; shardID: number }) {\n    const result = await this.messenger.send(\n      RPCMethod.GetCXReceiptByHash,\n      [txnHash],\n      this.messenger.chainPrefix,\n      shardID,\n    );\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Get the code at a specific address.\n   *\n   * @param address The address to get the code from (eg:smart contract)\n   * @param blockNumber (OPTIONAL) If you pass this parameter it will not use the default block\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   * @return `Promise` - The data at given `address`\n   *\n   * @example\n   * ```javascript\n   * hmy.blockchain.getCode({\n   *   address: '0x08AE1abFE01aEA60a47663bCe0794eCCD5763c19',\n   *   blockNumber: 'latest'\n   * }).then((value) => {\n   *   console.log(value);\n   * });\n   * ```\n   */\n  @assertObject({\n    address: ['isValidAddress', AssertType.required],\n    blockNumber: ['isBlockNumber', AssertType.optional],\n    shardID: ['isNumber', AssertType.optional],\n  })\n  async getCode({\n    address,\n    blockNumber = DefaultBlockParams.latest,\n    shardID = this.messenger.currentShard,\n  }: {\n    address: string;\n    blockNumber?: string;\n    shardID?: number;\n  }) {\n    const result = await this.messenger.send(\n      RPCMethod.GetCode,\n      [getAddress(address).checksum, blockNumber],\n      this.messenger.chainPrefix,\n      shardID,\n    );\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Get the number of peers connected to.\n   *\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   * @returns `Promise` - number of peer count\n   *\n   * @example\n   * ```javascript\n   * hmy.blockchain.net_peerCount().then((value) => {\n   *   console.log(value.result);\n   * });\n   * ```\n   */\n  async net_peerCount(shardID: number = this.messenger.currentShard) {\n    const result = await this.messenger.send(RPCMethod.PeerCount, [], 'net', shardID);\n\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Get the version of net.\n   *\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   * @returns `Promise` - the current version.\n   *\n   * @example\n   * ```javascript\n   * hmy.blockchain.net_version().then((value) => {\n   *   console.log(value.result);\n   * });\n   * ```\n   */\n  async net_version(shardID: number = this.messenger.currentShard) {\n    const result = await this.messenger.send(RPCMethod.NetVersion, [], 'net', shardID);\n\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Get the protocal version.\n   *\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   * @returns `Promise` - the current protocol version.\n   *\n   * @example\n   * ```javascript\n   * hmy.blockchain.getProtocolVersion().then((value) => {\n   *   console.log(value.result);\n   * });\n   * ```\n   */\n  async getProtocolVersion(shardID: number = this.messenger.currentShard) {\n    const result = await this.messenger.send(\n      RPCMethod.ProtocolVersion,\n      [],\n      this.messenger.chainPrefix,\n      shardID,\n    );\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Get the storage at a specific position of an address\n   *\n   * @param address The address to get the storage from\n   * @param position The index position of the storage\n   * @param blockNumber by default it's `latest`.\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   *\n   * @example\n   * ```javascript\n   * hmy.blockchain.getStorageAt({\n   *   address: 'one1d0kw95t6kkljmkk9vu0zv25jraut8ngv5vrs5g',\n   *   position: '0x0'\n   * }).then((value) => {\n   *   console.log(value);\n   * });\n   * ```\n   */\n  @assertObject({\n    address: ['isValidAddress', AssertType.required],\n    position: ['isHex', AssertType.required],\n    blockNumber: ['isBlockNumber', AssertType.optional],\n    shardID: ['isNumber', AssertType.optional],\n  })\n  async getStorageAt({\n    address,\n    position,\n    blockNumber = DefaultBlockParams.latest,\n    shardID = this.messenger.currentShard,\n  }: {\n    address: string;\n    position: string;\n    blockNumber?: string;\n    shardID?: number;\n  }) {\n    const result = await this.messenger.send(\n      RPCMethod.GetStorageAt,\n      [getAddress(address).checksum, position, blockNumber],\n      this.messenger.chainPrefix,\n      shardID,\n    );\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Get the numbers of transactions sent from this address.\n   *\n   * @param address The address to get the numbers of transactions from\n   * @param blockNumber by default it's `latest`\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   * @return `Promise` - The number of transactions sent from the given address.\n   *\n   * @example\n   * ```javascript\n   * hmy.blockchain.getTransactionCount({\n   *   address: \"one1d0kw95t6kkljmkk9vu0zv25jraut8ngv5vrs5g\"\n   * }).then((value) => {\n   *   console.log(value.result);\n   * });\n   * ```\n   */\n  @assertObject({\n    address: ['isValidAddress', AssertType.required],\n    blockNumber: ['isBlockNumber', AssertType.optional],\n    shardID: ['isNumber', AssertType.optional],\n  })\n  async getTransactionCount({\n    address,\n    blockNumber = DefaultBlockParams.latest,\n    shardID = this.messenger.currentShard,\n  }: {\n    address: string;\n    blockNumber?: string;\n    shardID?: number;\n  }) {\n    const result = await this.messenger.send(\n      RPCMethod.GetTransactionCount,\n      [getAddress(address).checksum, blockNumber],\n      this.messenger.chainPrefix,\n      shardID,\n    );\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Get the sharding structure of current network\n   *\n   * @return `Promise` - The sharding structure of current network.\n   *\n   * @example\n   * ```javascript\n   * hmy.blockchain.getShardingStructure().then((value) => {\n   *   console.log(value);\n   * });\n   * ```\n   */\n  async getShardingStructure() {\n    const result = await this.messenger.send(\n      RPCMethod.GetShardingStructure,\n      [],\n      this.messenger.chainPrefix,\n    );\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Sends a signed transaction to the network.\n   *\n   * @param transaction `Object` - The transaction object to send:\n   * @return The **callbalck** will return the 32 bytes transaction hash\n   *\n   * @example\n   * ```javascript\n   * // add privateKey to wallet\n   * const privateKey = '45e497bd45a9049bcb649016594489ac67b9f052a6cdf5cb74ee2427a60bf25e';\n   * hmy.wallet.addByPrivateKey(privateKey);\n   *\n   * async function transfer() {\n   *   const txn = hmy.transactions.newTx({\n   *     //  token send to\n   *     to: 'one166axnkjmghkf3df7xfvd0hn4dft8kemrza4cd2',\n   *     // amount to send\n   *     value: '10000',\n   *     // gas limit, you can use string\n   *     gasLimit: '210000',\n   *     // send token from shardID\n   *     shardID: 0,\n   *     // send token to toShardID\n   *     toShardID: 0,\n   *     // gas Price, you can use Unit class, and use Gwei, then remember to use toWei(), which will be transformed to BN\n   *     gasPrice: new hmy.utils.Unit('100').asGwei().toWei(),\n   *   });\n   *\n   *   // sign the transaction use wallet;\n   *   const signedTxn = await hmy.wallet.signTransaction(txn);\n   *   const txnHash = await hmy.blockchain.sendTransaction(signedTxn);\n   *   console.log(txnHash.result);\n   * }\n   *\n   * transfer();\n   * ```\n   */\n  async sendTransaction(transaction: Transaction) {\n    if (!transaction.isSigned() || !transaction) {\n      throw new Error('transaction is not signed or not exist');\n    }\n    const result = await this.messenger.send(\n      RPCMethod.SendRawTransaction,\n      [transaction.getRawTransaction()],\n      this.messenger.chainPrefix,\n      typeof transaction.txParams.shardID === 'string'\n        ? Number.parseInt(transaction.txParams.shardID, 10)\n        : transaction.txParams.shardID,\n    );\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Sends a raw transaction to the network.\n   *\n   * @param transaction `Object` - The transaction object to send:\n   * @return The **callbalck** will return the 32 bytes transaction hash\n   *\n   * @example\n   * ```javascript\n   * // add privateKey to wallet\n   * const privateKey = '45e497bd45a9049bcb649016594489ac67b9f052a6cdf5cb74ee2427a60bf25e';\n   * hmy.wallet.addByPrivateKey(privateKey);\n   *\n   * async function transfer() {\n   *   const txn = hmy.transactions.newTx({\n   *     //  token send to\n   *     to: 'one166axnkjmghkf3df7xfvd0hn4dft8kemrza4cd2',\n   *     // amount to send\n   *     value: '10000',\n   *     // gas limit, you can use string\n   *     gasLimit: '210000',\n   *     // send token from shardID\n   *     shardID: 0,\n   *     // send token to toShardID\n   *     toShardID: 0,\n   *     // gas Price, you can use Unit class, and use Gwei, then remember to use toWei(), which will be transformed to BN\n   *     gasPrice: new hmy.utils.Unit('100').asGwei().toWei(),\n   *   });\n   *\n   *   // sign the transaction use wallet;\n   *   const signedTxn = await hmy.wallet.signTransaction(txn);\n   *   recovered = signedTxn.recover(signedTxn.rawTransaction);\n   *\n   *   const txnHash = await hmy.blockchain.sendRawTransaction(recovered);\n   *   console.log(txnHash);\n   * }\n   *\n   * transfer();\n   * ```\n   */\n  async sendRawTransaction(transaction: Transaction) {\n    if (!transaction.isSigned() || !transaction) {\n      throw new Error('transaction is not signed or not exist');\n    }\n    const [txn, result] = await transaction.sendTransaction();\n    if (txn.isPending()) {\n      return result;\n    }\n  }\n\n  /**\n   * send a transaction and check whether it exists\n   *\n   * @param transaction `Object` - The transaction object to send:\n   * @return The **callbalck** will return the 32 bytes transaction hash\n   *\n   * @example\n   * ```javascript\n   * // add privateKey to wallet\n   * const privateKey = '45e497bd45a9049bcb649016594489ac67b9f052a6cdf5cb74ee2427a60bf25e';\n   * hmy.wallet.addByPrivateKey(privateKey);\n   *\n   * async function transfer() {\n   *   const txn = hmy.transactions.newTx({\n   *     //  token send to\n   *     to: 'one166axnkjmghkf3df7xfvd0hn4dft8kemrza4cd2',\n   *     // amount to send\n   *     value: '10000',\n   *     // gas limit, you can use string\n   *     gasLimit: '210000',\n   *     // send token from shardID\n   *     shardID: 0,\n   *     // send token to toShardID\n   *     toShardID: 0,\n   *     // gas Price, you can use Unit class, and use Gwei, then remember to use toWei(), which will be transformed to BN\n   *     gasPrice: new hmy.utils.Unit('100').asGwei().toWei(),\n   *   });\n   *\n   *   // sign the transaction use wallet;\n   *   const signedTxn = await hmy.wallet.signTransaction(txn);\n   *   const txnHash = await hmy.blockchain.createObservedTransaction(signedTxn);\n   *   console.log(txnHash);\n   * }\n   *\n   * transfer();\n   * ```\n   */\n  createObservedTransaction(transaction: Transaction) {\n    try {\n      transaction.sendTransaction().then((response: any) => {\n        const [txReturned, TranID] = response;\n\n        txReturned.confirm(TranID).then((txConfirmed: Transaction) => {\n          transaction.emitter.resolve(txConfirmed);\n        });\n      });\n      return transaction.emitter;\n    } catch (err) {\n      throw err;\n    }\n  }\n\n  /**\n   * send raw staking transaction\n   *\n   * @param staking\n   * @ignore\n   *\n   * @warning\n   * ```\n   * At present, this function is not implement yet, will Coming soon!!!\n   * ```\n   */\n  async sendRawStakingTransaction(staking: StakingTransaction) {\n    if (!staking.isSigned() || !staking) {\n      throw new Error('staking transaction is not signed or not exist');\n    }\n    const [txn, result] = await staking.sendTransaction();\n    if (txn.isPending()) {\n      return result;\n    }\n  }\n\n  /**\n   * send raw staking transaction and check whether it exists\n   *\n   * @param staking\n   * @ignore\n   *\n   * @warning\n   * ```\n   * At present, this function is not implement yet, will Coming soon!!!\n   * ```\n   */\n  createObservedStakingTransaction(staking: StakingTransaction) {\n    try {\n      staking.sendTransaction().then((response: any) => {\n        const [txReturned, TranID] = response;\n\n        txReturned.confirm(TranID).then((txConfirmed: StakingTransaction) => {\n          staking.emitter.resolve(txConfirmed);\n        });\n      });\n      return staking.emitter;\n    } catch (err) {\n      throw err;\n    }\n  }\n\n  /**\n   * Executes a message call or transaction and returns the amount of the gas used.\n   *\n   * @param to the address will send to\n   * @param data the data will send to that address\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   * @return `promise` -  the used gas for the simulated call/transaction.\n   *\n   * @warning\n   * ```\n   * At present, this function hmy_estimateGas is not implement yet, will Coming soon!!!\n   * ```\n   *\n   * @example\n   * ```javascript\n   * hmy.blockchain.estimateGas({\n   *   to: 'one1d0kw95t6kkljmkk9vu0zv25jraut8ngv5vrs5g',\n   *   data: '0xc6888fa10000000000000000000000000000000000000000000000000000000000000003'\n   * }).then((value) => {\n   *   console.log(value);\n   * });\n   * ```\n   */\n  @assertObject({\n    to: ['isValidAddress', AssertType.optional],\n    data: ['isHex', AssertType.optional],\n    shardID: ['isNumber', AssertType.optional],\n  })\n  async estimateGas({\n    to,\n    data,\n    shardID = this.messenger.currentShard,\n  }: {\n    to: string;\n    data: string;\n    shardID?: number;\n  }) {\n    const result = await this.messenger.send(\n      RPCMethod.EstimateGas,\n      [{ to: getAddress(to).checksum, data }],\n      this.messenger.chainPrefix,\n      shardID,\n    );\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Returns the current gas price oracle. The gas price is determined by the last few blocks median gas price.\n   *\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   * @return `promise` - Number string of the current gas price in wei.\n   *\n   * @example\n   * ```javascript\n   * hmy.blockchain.gasPrice().then((value) => {\n   *   console.log(value);\n   * });\n   * ```\n   */\n  async gasPrice(shardID: number = this.messenger.currentShard) {\n    const result = await this.messenger.send(\n      RPCMethod.GasPrice,\n      [],\n      this.messenger.chainPrefix,\n      shardID,\n    );\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Executes a message call transaction,\n   * which is directly executed in the VM of the node, but never mined into the blockchain.\n   *\n   * @param payload some data you want put into these fucntions\n   * @param blockNumber by default it's `latest`\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   *\n   * @example\n   * ```javascript\n   * hmy.blockchain.call({\n   *   to: \"0x08AE1abFE01aEA60a47663bCe0794eCCD5763c19\",\n   * }).then((value) => {\n   *   console.log(value);\n   * });\n   * ```\n   */\n  async call({\n    payload,\n    blockNumber = DefaultBlockParams.latest,\n    shardID = this.messenger.currentShard,\n  }: {\n    payload: any;\n    blockNumber?: string;\n    shardID?: number;\n  }) {\n    const result = await this.messenger.send(\n      RPCMethod.Call,\n      [payload, blockNumber],\n      this.messenger.chainPrefix,\n      shardID,\n    );\n    return this.getRpcResult(result);\n  }\n\n  /**\n   * Return new pending Transactions\n   *\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   *\n   * @example\n   * ```javascript\n   * const hmy = new Harmony(\n   *   // rpc url\n   *   'ws://api.s0.b.hmny.io/',\n   *   {\n   *     // chainType set to Harmony\n   *     chainType: ChainType.Harmony,\n   *     // chainType set to HmyLocal\n   *     chainId: ChainID.HmyLocal,\n   *   },\n   * );\n   *\n   * const tmp = hmy.blockchain.newPendingTransactions();\n   * console.log(tmp)\n   * ```\n   */\n  newPendingTransactions(shardID: number = this.messenger.currentShard) {\n    if (this.messenger.provider instanceof WSProvider) {\n      return new NewPendingTransactions(this.messenger, shardID);\n    } else {\n      throw new Error('HttpProvider does not support this feature');\n    }\n  }\n\n  /**\n   *\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   *\n   * @example\n   * ```javascript\n   * const hmy = new Harmony(\n   *   // rpc url\n   *   'ws://api.s0.b.hmny.io/',\n   *   {\n   *     // chainType set to Harmony\n   *     chainType: ChainType.Harmony,\n   *     // chainType set to HmyLocal\n   *     chainId: ChainID.HmyLocal,\n   *   },\n   * );\n   *\n   * const tmp = hmy.blockchain.newBlockHeaders();\n   * console.log(tmp)\n   * ```\n   */\n  newBlockHeaders(shardID: number = this.messenger.currentShard) {\n    if (this.messenger.provider instanceof WSProvider) {\n      return new NewHeaders(this.messenger, shardID);\n    } else {\n      throw new Error('HttpProvider does not support this feature');\n    }\n  }\n\n  /**\n   *\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   *\n   * @example\n   * ```javascript\n   * const hmy = new Harmony(\n   *   // rpc url\n   *   'ws://api.s0.b.hmny.io/',\n   *   {\n   *     // chainType set to Harmony\n   *     chainType: ChainType.Harmony,\n   *     // chainType set to HmyLocal\n   *     chainId: ChainID.HmyLocal,\n   *   },\n   * );\n   *\n   * const tmp = hmy.blockchain.syncing();\n   * console.log(tmp)\n   * ```\n   */\n  syncing(shardID: number = this.messenger.currentShard) {\n    if (this.messenger.provider instanceof WSProvider) {\n      return new Syncing(this.messenger, shardID);\n    } else {\n      throw new Error('HttpProvider does not support this feature');\n    }\n  }\n\n  /**\n   *\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   *\n   * @example\n   * ```javascript\n   * const hmy = new Harmony(\n   *   // rpc url\n   *   'ws://api.s0.b.hmny.io/',\n   *   {\n   *     // chainType set to Harmony\n   *     chainType: ChainType.Harmony,\n   *     // chainType set to HmyLocal\n   *     chainId: ChainID.HmyLocal,\n   *   },\n   * );\n   *\n   * const tmp = hmy.blockchain.logs({\n   *   from: '0x12'\n   * });\n   * console.log(tmp)\n   * ```\n   */\n  logs(options: any, shardID: number = this.messenger.currentShard) {\n    if (this.messenger.provider instanceof WSProvider) {\n      return new LogSub(options, this.messenger, shardID);\n    } else {\n      throw new Error('HttpProvider does not support this feature');\n    }\n  }\n}\n\nexport { Blockchain };\n"]}},"error":null,"hash":"225ea72dcd7996beb867fc191558dc95","cacheData":{"env":{}}}