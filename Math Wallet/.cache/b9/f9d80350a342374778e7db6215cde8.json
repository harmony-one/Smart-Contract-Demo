{"id":"../node_modules/@harmony-js/account/dist/wallet.js","dependencies":[{"name":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/account/dist/wallet.js.map","includedInParent":true,"mtime":499162500000},{"name":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/account/src/wallet.ts","includedInParent":true,"mtime":499162500000},{"name":"/home/rachit/Projects/demo/web Math Wallet/package.json","includedInParent":true,"mtime":1605273881149},{"name":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/account/package.json","includedInParent":true,"mtime":1605232158322},{"name":"tslib","loc":{"line":8,"column":22},"parent":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/account/dist/wallet.js","resolved":"/home/rachit/Projects/demo/node_modules/tslib/tslib.es6.js"},{"name":"@harmony-js/crypto","loc":{"line":9,"column":23},"parent":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/account/dist/wallet.js","resolved":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/crypto/dist/index.js"},{"name":"@harmony-js/utils","loc":{"line":10,"column":22},"parent":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/account/dist/wallet.js","resolved":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/utils/dist/index.js"},{"name":"./account","loc":{"line":11,"column":24},"parent":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/account/dist/wallet.js","resolved":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/account/dist/account.js"},{"name":"./utils","loc":{"line":12,"column":22},"parent":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/account/dist/wallet.js","resolved":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/account/dist/utils.js"}],"generated":{"js":"\"use strict\";\n/**\n * @packageDocumentation\n * @module harmony-account\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Wallet = void 0;\nvar tslib_1 = require(\"tslib\");\nvar crypto_1 = require(\"@harmony-js/crypto\");\nvar utils_1 = require(\"@harmony-js/utils\");\nvar account_1 = require(\"./account\");\nvar utils_2 = require(\"./utils\");\nvar Wallet = /** @class */ (function () {\n    /**\n     * @example\n     * ```\n     * const { Wallet } = require('@harmony-js/account');\n     * const { HttpProvider, Messenger } = require('@harmony-js/network');\n     * const { ChainType, ChainID } = require('@harmony-js/utils');\n     *\n     * // create a custom messenger\n     * const customMessenger = new Messenger(\n     *   new HttpProvider('http://localhost:9500'),\n     *   ChainType.Harmony, // if you are connected to Harmony's blockchain\n     *   ChainID.HmyLocal, // check if the chainId is correct\n     * )\n     *\n     * const wallet = new Wallet(customMessenger);\n     * ```\n     */\n    function Wallet(messenger) {\n        if (messenger === void 0) { messenger = utils_2.defaultMessenger; }\n        /**\n         * @hidden\n         */\n        this.accountMap = new Map();\n        this.messenger = messenger;\n    }\n    // static method generate Mnemonic\n    Wallet.generateMnemonic = function () {\n        return crypto_1.bip39.generateMnemonic();\n    };\n    Object.defineProperty(Wallet.prototype, \"accounts\", {\n        /**\n         * get acounts addresses\n         *\n         * @return {string[]} accounts addresses\n         *\n         * @example\n         * ```javascript\n         * const wallet = new Wallet(customMessenger);\n         * const key_1 = '45e497bd45a9049bcb649016594489ac67b9f052a6cdf5cb74ee2427a60bf25e';\n         * wallet.addByPrivateKey(key_1);\n         *\n         * console.log(wallet.accounts);\n         * ```\n         */\n        get: function () {\n            return tslib_1.__spread(this.accountMap.keys());\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Wallet.prototype, \"signer\", {\n        /**\n         * get the signer of the account, by default, using the first account\n         *\n         * @example\n         * ```javascript\n         * const wallet = new Wallet(customMessenger);\n         * const key_1 = '45e497bd45a9049bcb649016594489ac67b9f052a6cdf5cb74ee2427a60bf25e';\n         * wallet.addByPrivateKey(key_1);\n         *\n         * console.log(wallet.signer)\n         * ```\n         */\n        get: function () {\n            if (this.defaultSigner) {\n                return this.getAccount(this.defaultSigner);\n            }\n            else if (!this.defaultSigner && this.accounts.length > 0) {\n                this.setSigner(this.accounts[0]);\n                return this.getAccount(this.accounts[0]);\n            }\n            else {\n                return undefined;\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * @function newMnemonic\n     * @memberof Wallet\n     * @return {string} Mnemonics\n     */\n    Wallet.prototype.newMnemonic = function () {\n        return Wallet.generateMnemonic();\n    };\n    /**\n     * Add account using Mnemonic phrases\n     * @param  {string} phrase - Mnemonic phrase\n     * @param  {index} index - index to hdKey root\n     *\n     * @example\n     * ```javascript\n     * const mnemonic_1 = 'urge clog right example dish drill card maximum mix bachelor section select';\n     * const wallet = new Wallet(customMessenger);\n     * wallet.addByMnemonic(mnemonic_1);\n     *\n     * console.log(wallet.accounts);\n     * ```\n     */\n    Wallet.prototype.addByMnemonic = function (phrase, index) {\n        if (index === void 0) { index = 0; }\n        if (!this.isValidMnemonic(phrase)) {\n            throw new Error(\"Invalid mnemonic phrase: \" + phrase);\n        }\n        var seed = crypto_1.bip39.mnemonicToSeed(phrase);\n        var hdKey = crypto_1.hdkey.fromMasterSeed(seed);\n        // TODO:hdkey should apply to Harmony's settings\n        var path = this.messenger.chainType === utils_1.ChainType.Harmony ? '1023' : '60';\n        var childKey = hdKey.derive(\"m/44'/\" + path + \"'/0'/0/\" + index);\n        var privateKey = childKey.privateKey.toString('hex');\n        return this.addByPrivateKey(privateKey);\n    };\n    /**\n     * Add an account using privateKey\n     *\n     * @param  {string} privateKey - privateKey to add\n     * @return {Account} return added Account\n     *\n     * @example\n     * ```javascript\n     * const wallet = new Wallet(customMessenger);\n     * const key_1 = '45e497bd45a9049bcb649016594489ac67b9f052a6cdf5cb74ee2427a60bf25e';\n     * console.log(wallet.addByPrivateKey(key_1));\n     * ```\n     */\n    Wallet.prototype.addByPrivateKey = function (privateKey) {\n        try {\n            var newAcc = account_1.Account.add(privateKey);\n            newAcc.setMessenger(this.messenger);\n            if (newAcc.address) {\n                this.accountMap.set(newAcc.address, newAcc);\n                if (!this.defaultSigner) {\n                    this.setSigner(newAcc.address);\n                }\n                return newAcc;\n            }\n            else {\n                throw new Error('add account failed');\n            }\n        }\n        catch (error) {\n            throw error;\n        }\n    };\n    /**\n     * Add an account using privateKey\n     * @param  {string} keyStore - keystore jsonString to add\n     * @param  {string} password - password to decrypt the file\n     * @return {Account} return added Account\n     */\n    Wallet.prototype.addByKeyStore = function (keyStore, password) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var newAcc, result, error_1;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        newAcc = new account_1.Account(undefined);\n                        return [4 /*yield*/, newAcc.fromFile(keyStore, password)];\n                    case 1:\n                        result = _a.sent();\n                        result.setMessenger(this.messenger);\n                        if (result.address) {\n                            this.accountMap.set(result.address, result);\n                            if (!this.defaultSigner) {\n                                this.setSigner(result.address);\n                            }\n                            return [2 /*return*/, result];\n                        }\n                        else {\n                            throw new Error('add account failed');\n                        }\n                        return [3 /*break*/, 3];\n                    case 2:\n                        error_1 = _a.sent();\n                        throw error_1;\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * create a new account using Mnemonic\n     * @return {Account} {description}\n     *\n     * @example\n     * ```javascript\n     * console.log(wallet.accounts);\n     * wallet.createAccount();\n     * wallet.createAccount();\n     *\n     * console.log(wallet.accounts);\n     * ````\n     */\n    Wallet.prototype.createAccount = function (password, options) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var prv, acc, encrypted;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        prv = crypto_1.generatePrivateKey();\n                        acc = this.addByPrivateKey(prv);\n                        if (!(acc.address && password)) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this.encryptAccount(acc.address, password, options)];\n                    case 1:\n                        encrypted = _a.sent();\n                        return [2 /*return*/, encrypted];\n                    case 2:\n                        if (acc.address && !password) {\n                            return [2 /*return*/, acc];\n                        }\n                        else {\n                            throw new Error('create acount failed');\n                        }\n                        _a.label = 3;\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * To encrypt an account that lives in the wallet.\n     * if encrypted, returns original one, if not found, throw error\n     * @param {string} address - address in accounts\n     * @param {string} password - string that used to encrypt\n     * @param {EncryptOptions} options - encryption options\n     * @return {Promise<Account>}\n     *\n     * @example\n     * ```javascript\n     * const key_1 = '45e497bd45a9049bcb649016594489ac67b9f052a6cdf5cb74ee2427a60bf25e';\n     * wallet.addByPrivateKey(key_1);\n     * wallet.encryptAccount('one103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7', '12345').then((value) => {\n     *   console.log(value);\n     * })\n     * ```\n     */\n    Wallet.prototype.encryptAccount = function (address, password, options) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var foundAcc, error_2;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 4, , 5]);\n                        foundAcc = this.getAccount(address);\n                        if (!(foundAcc && foundAcc.privateKey && utils_1.isPrivateKey(foundAcc.privateKey))) return [3 /*break*/, 2];\n                        return [4 /*yield*/, foundAcc.toFile(password, options)];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/, foundAcc];\n                    case 2:\n                        if (foundAcc && foundAcc.privateKey && !utils_1.isPrivateKey(foundAcc.privateKey)) {\n                            return [2 /*return*/, foundAcc];\n                        }\n                        else {\n                            throw new Error('encrypt account failed');\n                        }\n                        _a.label = 3;\n                    case 3: return [3 /*break*/, 5];\n                    case 4:\n                        error_2 = _a.sent();\n                        throw error_2;\n                    case 5: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * To decrypt an account that lives in the wallet,if not encrypted, return original,\n     * if not found, throw error\n     * @param {string} address - address in accounts\n     * @param {string} password - string that used to encrypt\n     * @return {Promise<Account>}\n     *\n     * @example\n     * ```javascript\n     * const key_1 = '45e497bd45a9049bcb649016594489ac67b9f052a6cdf5cb74ee2427a60bf25e';\n     * wallet.addByPrivateKey(key_1);\n     * wallet.encryptAccount('one103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7', '12345')\n     * .then(() => {\n     *   wallet.decryptAccount('one103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7', '12345')\n     *   .then((value) =>{\n     *      console.log(value);\n     *   });\n     * });\n     * ```\n     */\n    Wallet.prototype.decryptAccount = function (address, password) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var foundAcc, error_3;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 4, , 5]);\n                        foundAcc = this.getAccount(address);\n                        if (!(foundAcc && foundAcc.privateKey && !utils_1.isPrivateKey(foundAcc.privateKey))) return [3 /*break*/, 2];\n                        return [4 /*yield*/, foundAcc.fromFile(foundAcc.privateKey, password)];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/, foundAcc];\n                    case 2:\n                        if (foundAcc && foundAcc.privateKey && utils_1.isPrivateKey(foundAcc.privateKey)) {\n                            foundAcc.encrypted = false;\n                            return [2 /*return*/, foundAcc];\n                        }\n                        else {\n                            throw new Error('decrypt account failed');\n                        }\n                        _a.label = 3;\n                    case 3: return [3 /*break*/, 5];\n                    case 4:\n                        error_3 = _a.sent();\n                        throw error_3;\n                    case 5: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Get Account instance using address as param\n     * @param  {string} address - address hex\n     * @return {Account} Account instance which lives in Wallet\n     *\n     * @example\n     * ```\n     * const key_1 = '45e497bd45a9049bcb649016594489ac67b9f052a6cdf5cb74ee2427a60bf25e';\n     * wallet.addByPrivateKey(key_1);\n     * console.log(wallet.getAccount('one103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7'));\n     * ```\n     */\n    Wallet.prototype.getAccount = function (address) {\n        return this.accountMap.get(crypto_1.getAddress(address).basicHex);\n    };\n    /**\n     * @function removeAccount\n     * @memberof Wallet\n     * @description remove Account using address as param\n     * @param  {string} address: - address hex\n     */\n    Wallet.prototype.removeAccount = function (address) {\n        this.accountMap.delete(crypto_1.getAddress(address).basicHex);\n        if (this.defaultSigner === address) {\n            this.defaultSigner = undefined;\n        }\n    };\n    /**\n     * Set Customer Messenage\n     * @param messenger\n     *\n     * @example\n     * ```javascript\n     * const customMessenger = new Messenger(\n     *   new HttpProvider('https://api.s0.b.hmny.io'),\n     *   ChainType.Harmony, // if you are connected to Harmony's blockchain\n     *   ChainID.HmyLocal, // check if the chainId is correct\n     * )\n     * const wallet = new Wallet();\n     * wallet.setMessenger(customMessenger);\n     * console.log(wallet.messenger);\n     * ```\n     */\n    Wallet.prototype.setMessenger = function (messenger) {\n        this.messenger = messenger;\n    };\n    /**\n     * Set signer\n     *\n     * @param address one of the address in the accounts\n     */\n    Wallet.prototype.setSigner = function (address) {\n        if (!utils_1.isAddress(address) && !this.getAccount(address)) {\n            throw new Error('could not set signer');\n        }\n        this.defaultSigner = address;\n    };\n    Wallet.prototype.signTransaction = function (transaction, account, \n    // tslint:disable-next-line: no-unnecessary-initializer\n    password, updateNonce, encodeMode, blockNumber) {\n        if (account === void 0) { account = this.signer; }\n        if (password === void 0) { password = undefined; }\n        if (updateNonce === void 0) { updateNonce = true; }\n        if (encodeMode === void 0) { encodeMode = 'rlp'; }\n        if (blockNumber === void 0) { blockNumber = 'latest'; }\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var toSignWith, decrypted, signed, error_4, signed, error_5;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        toSignWith = account || this.signer;\n                        if (!toSignWith) {\n                            throw new Error('no signer found or did not provide correct account');\n                        }\n                        if (!(toSignWith instanceof account_1.Account && toSignWith.encrypted && toSignWith.address)) return [3 /*break*/, 7];\n                        if (!password) {\n                            throw new Error('must provide password to further execution');\n                        }\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 5, , 6]);\n                        return [4 /*yield*/, this.decryptAccount(toSignWith.address, password)];\n                    case 2:\n                        decrypted = _a.sent();\n                        return [4 /*yield*/, decrypted.signTransaction(transaction, updateNonce, encodeMode, blockNumber)];\n                    case 3:\n                        signed = _a.sent();\n                        return [4 /*yield*/, this.encryptAccount(toSignWith.address, password)];\n                    case 4:\n                        _a.sent();\n                        return [2 /*return*/, signed];\n                    case 5:\n                        error_4 = _a.sent();\n                        throw error_4;\n                    case 6: return [3 /*break*/, 13];\n                    case 7:\n                        if (!(toSignWith instanceof account_1.Account && !toSignWith.encrypted && toSignWith.address)) return [3 /*break*/, 12];\n                        _a.label = 8;\n                    case 8:\n                        _a.trys.push([8, 10, , 11]);\n                        return [4 /*yield*/, toSignWith.signTransaction(transaction, updateNonce, encodeMode, blockNumber)];\n                    case 9:\n                        signed = _a.sent();\n                        return [2 /*return*/, signed];\n                    case 10:\n                        error_5 = _a.sent();\n                        throw error_5;\n                    case 11: return [3 /*break*/, 13];\n                    case 12: throw new Error('sign transaction failed');\n                    case 13: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    Wallet.prototype.signStaking = function (staking, account, \n    // tslint:disable-next-line: no-unnecessary-initializer\n    password, updateNonce, encodeMode, blockNumber, shardID) {\n        if (account === void 0) { account = this.signer; }\n        if (password === void 0) { password = undefined; }\n        if (updateNonce === void 0) { updateNonce = true; }\n        if (encodeMode === void 0) { encodeMode = 'rlp'; }\n        if (blockNumber === void 0) { blockNumber = 'latest'; }\n        if (shardID === void 0) { shardID = this.messenger.currentShard; }\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var toSignWith, decrypted, signed, error_6, signed, error_7;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        toSignWith = account || this.signer;\n                        if (!toSignWith) {\n                            throw new Error('no signer found or did not provide correct account');\n                        }\n                        if (!(toSignWith instanceof account_1.Account && toSignWith.encrypted && toSignWith.address)) return [3 /*break*/, 7];\n                        if (!password) {\n                            throw new Error('must provide password to further execution');\n                        }\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 5, , 6]);\n                        return [4 /*yield*/, this.decryptAccount(toSignWith.address, password)];\n                    case 2:\n                        decrypted = _a.sent();\n                        return [4 /*yield*/, decrypted.signStaking(staking, updateNonce, encodeMode, blockNumber, shardID)];\n                    case 3:\n                        signed = _a.sent();\n                        return [4 /*yield*/, this.encryptAccount(toSignWith.address, password)];\n                    case 4:\n                        _a.sent();\n                        return [2 /*return*/, signed];\n                    case 5:\n                        error_6 = _a.sent();\n                        throw error_6;\n                    case 6: return [3 /*break*/, 13];\n                    case 7:\n                        if (!(toSignWith instanceof account_1.Account && !toSignWith.encrypted && toSignWith.address)) return [3 /*break*/, 12];\n                        _a.label = 8;\n                    case 8:\n                        _a.trys.push([8, 10, , 11]);\n                        return [4 /*yield*/, toSignWith.signStaking(staking, updateNonce, encodeMode, blockNumber, shardID)];\n                    case 9:\n                        signed = _a.sent();\n                        return [2 /*return*/, signed];\n                    case 10:\n                        error_7 = _a.sent();\n                        throw error_7;\n                    case 11: return [3 /*break*/, 13];\n                    case 12: throw new Error('sign transaction failed');\n                    case 13: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * @function isValidMnemonic\n     * @memberof Wallet\n     * @description check if Mnemonic is valid\n     * @param  {string} phrase - Mnemonic phrase\n     * @return {boolean}\n     * @ignore\n     */\n    Wallet.prototype.isValidMnemonic = function (phrase) {\n        if (phrase.trim().split(/\\s+/g).length < 12) {\n            return false;\n        }\n        return crypto_1.bip39.validateMnemonic(phrase);\n    };\n    return Wallet;\n}());\nexports.Wallet = Wallet;\n"},"sourceMaps":{"js":{"version":3,"file":"wallet.js","sourceRoot":"","sources":["../src/wallet.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @packageDocumentation\n * @module harmony-account\n */\n\nimport { bip39, hdkey, EncryptOptions, getAddress, generatePrivateKey } from '@harmony-js/crypto';\nimport { Messenger } from '@harmony-js/network';\nimport { isPrivateKey, isAddress, ChainType } from '@harmony-js/utils';\nimport { Transaction } from '@harmony-js/transaction';\nimport { StakingTransaction } from '@harmony-js/staking';\nimport { Account } from './account';\nimport { defaultMessenger } from './utils';\n\nclass Wallet {\n  // static method generate Mnemonic\n  static generateMnemonic(): string {\n    return bip39.generateMnemonic();\n  }\n\n  /** @hidden */\n  messenger: Messenger;\n  /** @hidden */\n  protected defaultSigner?: string;\n  /**\n   * @hidden\n   */\n  private accountMap: Map<string, Account> = new Map();\n\n  /**\n   * get acounts addresses\n   *\n   * @return {string[]} accounts addresses\n   *\n   * @example\n   * ```javascript\n   * const wallet = new Wallet(customMessenger);\n   * const key_1 = '45e497bd45a9049bcb649016594489ac67b9f052a6cdf5cb74ee2427a60bf25e';\n   * wallet.addByPrivateKey(key_1);\n   *\n   * console.log(wallet.accounts);\n   * ```\n   */\n  get accounts(): string[] {\n    return [...this.accountMap.keys()];\n  }\n\n  /**\n   * get the signer of the account, by default, using the first account\n   *\n   * @example\n   * ```javascript\n   * const wallet = new Wallet(customMessenger);\n   * const key_1 = '45e497bd45a9049bcb649016594489ac67b9f052a6cdf5cb74ee2427a60bf25e';\n   * wallet.addByPrivateKey(key_1);\n   *\n   * console.log(wallet.signer)\n   * ```\n   */\n  get signer(): Account | undefined {\n    if (this.defaultSigner) {\n      return this.getAccount(this.defaultSigner);\n    } else if (!this.defaultSigner && this.accounts.length > 0) {\n      this.setSigner(this.accounts[0]);\n      return this.getAccount(this.accounts[0]);\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * @example\n   * ```\n   * const { Wallet } = require('@harmony-js/account');\n   * const { HttpProvider, Messenger } = require('@harmony-js/network');\n   * const { ChainType, ChainID } = require('@harmony-js/utils');\n   *\n   * // create a custom messenger\n   * const customMessenger = new Messenger(\n   *   new HttpProvider('http://localhost:9500'),\n   *   ChainType.Harmony, // if you are connected to Harmony's blockchain\n   *   ChainID.HmyLocal, // check if the chainId is correct\n   * )\n   *\n   * const wallet = new Wallet(customMessenger);\n   * ```\n   */\n  constructor(messenger: Messenger = defaultMessenger) {\n    this.messenger = messenger;\n  }\n  /**\n   * @function newMnemonic\n   * @memberof Wallet\n   * @return {string} Mnemonics\n   */\n  newMnemonic(): string {\n    return Wallet.generateMnemonic();\n  }\n\n  /**\n   * Add account using Mnemonic phrases\n   * @param  {string} phrase - Mnemonic phrase\n   * @param  {index} index - index to hdKey root\n   *\n   * @example\n   * ```javascript\n   * const mnemonic_1 = 'urge clog right example dish drill card maximum mix bachelor section select';\n   * const wallet = new Wallet(customMessenger);\n   * wallet.addByMnemonic(mnemonic_1);\n   *\n   * console.log(wallet.accounts);\n   * ```\n   */\n  addByMnemonic(phrase: string, index: number = 0) {\n    if (!this.isValidMnemonic(phrase)) {\n      throw new Error(`Invalid mnemonic phrase: ${phrase}`);\n    }\n    const seed = bip39.mnemonicToSeed(phrase);\n    const hdKey = hdkey.fromMasterSeed(seed);\n    // TODO:hdkey should apply to Harmony's settings\n    const path = this.messenger.chainType === ChainType.Harmony ? '1023' : '60';\n    const childKey = hdKey.derive(`m/44'/${path}'/0'/0/${index}`);\n    const privateKey = childKey.privateKey.toString('hex');\n    return this.addByPrivateKey(privateKey);\n  }\n\n  /**\n   * Add an account using privateKey\n   *\n   * @param  {string} privateKey - privateKey to add\n   * @return {Account} return added Account\n   *\n   * @example\n   * ```javascript\n   * const wallet = new Wallet(customMessenger);\n   * const key_1 = '45e497bd45a9049bcb649016594489ac67b9f052a6cdf5cb74ee2427a60bf25e';\n   * console.log(wallet.addByPrivateKey(key_1));\n   * ```\n   */\n  addByPrivateKey(privateKey: string): Account {\n    try {\n      const newAcc = Account.add(privateKey);\n      newAcc.setMessenger(this.messenger);\n      if (newAcc.address) {\n        this.accountMap.set(newAcc.address, newAcc);\n        if (!this.defaultSigner) {\n          this.setSigner(newAcc.address);\n        }\n        return newAcc;\n      } else {\n        throw new Error('add account failed');\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  /**\n   * Add an account using privateKey\n   * @param  {string} keyStore - keystore jsonString to add\n   * @param  {string} password - password to decrypt the file\n   * @return {Account} return added Account\n   */\n  async addByKeyStore(keyStore: string, password: string): Promise<Account> {\n    try {\n      const newAcc = new Account(undefined);\n      const result = await newAcc.fromFile(keyStore, password);\n      result.setMessenger(this.messenger);\n      if (result.address) {\n        this.accountMap.set(result.address, result);\n        if (!this.defaultSigner) {\n          this.setSigner(result.address);\n        }\n        return result;\n      } else {\n        throw new Error('add account failed');\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  /**\n   * create a new account using Mnemonic\n   * @return {Account} {description}\n   *\n   * @example\n   * ```javascript\n   * console.log(wallet.accounts);\n   * wallet.createAccount();\n   * wallet.createAccount();\n   *\n   * console.log(wallet.accounts);\n   * ````\n   */\n  async createAccount(password?: string, options?: EncryptOptions): Promise<Account> {\n    const prv = generatePrivateKey();\n    const acc = this.addByPrivateKey(prv);\n    if (acc.address && password) {\n      const encrypted = await this.encryptAccount(acc.address, password, options);\n      return encrypted;\n    } else if (acc.address && !password) {\n      return acc;\n    } else {\n      throw new Error('create acount failed');\n    }\n  }\n\n  /**\n   * To encrypt an account that lives in the wallet.\n   * if encrypted, returns original one, if not found, throw error\n   * @param {string} address - address in accounts\n   * @param {string} password - string that used to encrypt\n   * @param {EncryptOptions} options - encryption options\n   * @return {Promise<Account>}\n   *\n   * @example\n   * ```javascript\n   * const key_1 = '45e497bd45a9049bcb649016594489ac67b9f052a6cdf5cb74ee2427a60bf25e';\n   * wallet.addByPrivateKey(key_1);\n   * wallet.encryptAccount('one103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7', '12345').then((value) => {\n   *   console.log(value);\n   * })\n   * ```\n   */\n  async encryptAccount(\n    address: string,\n    password: string,\n    options?: EncryptOptions,\n  ): Promise<Account> {\n    try {\n      const foundAcc = this.getAccount(address);\n      if (foundAcc && foundAcc.privateKey && isPrivateKey(foundAcc.privateKey)) {\n        await foundAcc.toFile(password, options);\n        return foundAcc;\n      } else if (foundAcc && foundAcc.privateKey && !isPrivateKey(foundAcc.privateKey)) {\n        return foundAcc;\n      } else {\n        throw new Error('encrypt account failed');\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  /**\n   * To decrypt an account that lives in the wallet,if not encrypted, return original,\n   * if not found, throw error\n   * @param {string} address - address in accounts\n   * @param {string} password - string that used to encrypt\n   * @return {Promise<Account>}\n   *\n   * @example\n   * ```javascript\n   * const key_1 = '45e497bd45a9049bcb649016594489ac67b9f052a6cdf5cb74ee2427a60bf25e';\n   * wallet.addByPrivateKey(key_1);\n   * wallet.encryptAccount('one103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7', '12345')\n   * .then(() => {\n   *   wallet.decryptAccount('one103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7', '12345')\n   *   .then((value) =>{\n   *      console.log(value);\n   *   });\n   * });\n   * ```\n   */\n  async decryptAccount(address: string, password: string): Promise<Account> {\n    try {\n      const foundAcc = this.getAccount(address);\n      if (foundAcc && foundAcc.privateKey && !isPrivateKey(foundAcc.privateKey)) {\n        await foundAcc.fromFile(foundAcc.privateKey, password);\n        return foundAcc;\n      } else if (foundAcc && foundAcc.privateKey && isPrivateKey(foundAcc.privateKey)) {\n        foundAcc.encrypted = false;\n        return foundAcc;\n      } else {\n        throw new Error('decrypt account failed');\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  /**\n   * Get Account instance using address as param\n   * @param  {string} address - address hex\n   * @return {Account} Account instance which lives in Wallet\n   *\n   * @example\n   * ```\n   * const key_1 = '45e497bd45a9049bcb649016594489ac67b9f052a6cdf5cb74ee2427a60bf25e';\n   * wallet.addByPrivateKey(key_1);\n   * console.log(wallet.getAccount('one103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7'));\n   * ```\n   */\n  getAccount(address: string): Account | undefined {\n    return this.accountMap.get(getAddress(address).basicHex);\n  }\n\n  /**\n   * @function removeAccount\n   * @memberof Wallet\n   * @description remove Account using address as param\n   * @param  {string} address: - address hex\n   */\n  removeAccount(address: string): void {\n    this.accountMap.delete(getAddress(address).basicHex);\n    if (this.defaultSigner === address) {\n      this.defaultSigner = undefined;\n    }\n  }\n\n  /**\n   * Set Customer Messenage\n   * @param messenger\n   *\n   * @example\n   * ```javascript\n   * const customMessenger = new Messenger(\n   *   new HttpProvider('https://api.s0.b.hmny.io'),\n   *   ChainType.Harmony, // if you are connected to Harmony's blockchain\n   *   ChainID.HmyLocal, // check if the chainId is correct\n   * )\n   * const wallet = new Wallet();\n   * wallet.setMessenger(customMessenger);\n   * console.log(wallet.messenger);\n   * ```\n   */\n  setMessenger(messenger: Messenger): void {\n    this.messenger = messenger;\n  }\n\n  /**\n   * Set signer\n   *\n   * @param address one of the address in the accounts\n   */\n  setSigner(address: string): void {\n    if (!isAddress(address) && !this.getAccount(address)) {\n      throw new Error('could not set signer');\n    }\n    this.defaultSigner = address;\n  }\n\n  async signTransaction(\n    transaction: Transaction,\n    account: Account | undefined = this.signer,\n    // tslint:disable-next-line: no-unnecessary-initializer\n    password: string | undefined = undefined,\n    updateNonce: boolean = true,\n    encodeMode: string = 'rlp',\n    blockNumber: string = 'latest',\n  ): Promise<Transaction> {\n    const toSignWith = account || this.signer;\n    if (!toSignWith) {\n      throw new Error('no signer found or did not provide correct account');\n    }\n    if (toSignWith instanceof Account && toSignWith.encrypted && toSignWith.address) {\n      if (!password) {\n        throw new Error('must provide password to further execution');\n      }\n      try {\n        const decrypted = await this.decryptAccount(toSignWith.address, password);\n        const signed = await decrypted.signTransaction(\n          transaction,\n          updateNonce,\n          encodeMode,\n          blockNumber,\n        );\n        await this.encryptAccount(toSignWith.address, password);\n        return signed;\n      } catch (error) {\n        throw error;\n      }\n    } else if (toSignWith instanceof Account && !toSignWith.encrypted && toSignWith.address) {\n      try {\n        const signed = await toSignWith.signTransaction(\n          transaction,\n          updateNonce,\n          encodeMode,\n          blockNumber,\n        );\n        return signed;\n      } catch (error) {\n        throw error;\n      }\n    } else {\n      throw new Error('sign transaction failed');\n    }\n  }\n\n  async signStaking(\n    staking: StakingTransaction,\n    account: Account | undefined = this.signer,\n    // tslint:disable-next-line: no-unnecessary-initializer\n    password: string | undefined = undefined,\n    updateNonce: boolean = true,\n    encodeMode: string = 'rlp',\n    blockNumber: string = 'latest',\n    shardID: number = this.messenger.currentShard,\n  ): Promise<StakingTransaction> {\n    const toSignWith = account || this.signer;\n    if (!toSignWith) {\n      throw new Error('no signer found or did not provide correct account');\n    }\n    if (toSignWith instanceof Account && toSignWith.encrypted && toSignWith.address) {\n      if (!password) {\n        throw new Error('must provide password to further execution');\n      }\n      try {\n        const decrypted = await this.decryptAccount(toSignWith.address, password);\n        const signed = await decrypted.signStaking(\n          staking,\n          updateNonce,\n          encodeMode,\n          blockNumber,\n          shardID,\n        );\n        await this.encryptAccount(toSignWith.address, password);\n        return signed;\n      } catch (error) {\n        throw error;\n      }\n    } else if (toSignWith instanceof Account && !toSignWith.encrypted && toSignWith.address) {\n      try {\n        const signed = await toSignWith.signStaking(\n          staking,\n          updateNonce,\n          encodeMode,\n          blockNumber,\n          shardID,\n        );\n        return signed;\n      } catch (error) {\n        throw error;\n      }\n    } else {\n      throw new Error('sign transaction failed');\n    }\n  }\n\n  /**\n   * @function isValidMnemonic\n   * @memberof Wallet\n   * @description check if Mnemonic is valid\n   * @param  {string} phrase - Mnemonic phrase\n   * @return {boolean}\n   * @ignore\n   */\n  private isValidMnemonic(phrase: string): boolean {\n    if (phrase.trim().split(/\\s+/g).length < 12) {\n      return false;\n    }\n    return bip39.validateMnemonic(phrase);\n  }\n}\n\nexport { Wallet };\n"]}},"error":null,"hash":"1bf9cb0b40338bc419e7c1e56b25e694","cacheData":{"env":{}}}