{"id":"../node_modules/@harmony-js/contract/dist/utils/formatter.js","dependencies":[{"name":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/contract/dist/utils/formatter.js.map","includedInParent":true,"mtime":499162500000},{"name":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/contract/src/utils/formatter.ts","includedInParent":true,"mtime":499162500000},{"name":"/home/rachit/Projects/demo/web Math Wallet/package.json","includedInParent":true,"mtime":1605273881149},{"name":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/contract/package.json","includedInParent":true,"mtime":1605275414276},{"name":"@harmony-js/crypto","loc":{"line":9,"column":23},"parent":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/contract/dist/utils/formatter.js","resolved":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/crypto/dist/index.js"},{"name":"@harmony-js/utils","loc":{"line":10,"column":22},"parent":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/contract/dist/utils/formatter.js","resolved":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/utils/dist/index.js"},{"name":"../abi/abiCoder","loc":{"line":11,"column":25},"parent":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/contract/dist/utils/formatter.js","resolved":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/contract/dist/abi/abiCoder.js"}],"generated":{"js":"\"use strict\";\n/**\n * @packageDocumentation\n * @module harmony-contract\n * @hidden\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toTopic = exports.inputAddressFormatter = exports.isPredefinedBlockNumber = exports.inputBlockNumberFormatter = exports.outputLogFormatter = exports.inputLogFormatter = void 0;\nvar crypto_1 = require(\"@harmony-js/crypto\");\nvar utils_1 = require(\"@harmony-js/utils\");\nvar abiCoder_1 = require(\"../abi/abiCoder\");\nexports.inputLogFormatter = function (options) {\n    if (options.fromBlock) {\n        options.fromBlock = exports.inputBlockNumberFormatter(options.fromBlock);\n    }\n    if (options.toBlock) {\n        options.toBlock = exports.inputBlockNumberFormatter(options.toBlock);\n    }\n    // make sure topics, get converted to hex\n    options.topics = options.topics || [];\n    options.topics = options.topics.map(function (topic) {\n        return utils_1.isArray(topic) ? topic.map(exports.toTopic) : exports.toTopic(topic);\n    });\n    if (options.address) {\n        if (utils_1.isArray(options.address)) {\n            options.address = options.address.map(function (addr) {\n                return exports.inputAddressFormatter(addr);\n            });\n        }\n        else {\n            options.address = exports.inputAddressFormatter(options.address);\n        }\n    }\n    return options;\n};\n/**\n * Formats the output of a log\n *\n * @method outputLogFormatter\n *\n * @param {Object} log object\n *\n * @returns {Object} log\n */\nexports.outputLogFormatter = function (log) {\n    // generate a custom log id\n    if (typeof log.blockHash === 'string' &&\n        typeof log.transactionHash === 'string' &&\n        typeof log.logIndex === 'string') {\n        var shaId = crypto_1.keccak256('0x' +\n            log.blockHash.replace('0x', '') +\n            log.transactionHash.replace('0x', '') +\n            log.logIndex.replace('0x', ''));\n        shaId.replace('0x', '').substr(0, 8);\n        log.id = \"log_\" + shaId;\n    }\n    else if (!log.id) {\n        log.id = null;\n    }\n    if (log.blockNumber !== null) {\n        log.blockNumber = utils_1.hexToBN(log.blockNumber).toNumber();\n    }\n    if (log.transactionIndex !== null) {\n        log.transactionIndex = utils_1.hexToBN(log.transactionIndex).toNumber();\n    }\n    if (log.logIndex !== null) {\n        log.logIndex = utils_1.hexToBN(log.logIndex).toNumber();\n    }\n    if (log.address) {\n        log.address = crypto_1.toChecksumAddress(log.address);\n    }\n    return log;\n};\nexports.inputBlockNumberFormatter = function (blockNumber) {\n    if (blockNumber === undefined || blockNumber === null || exports.isPredefinedBlockNumber(blockNumber)) {\n        return blockNumber;\n    }\n    if (crypto_1.isHexString(blockNumber)) {\n        if (utils_1.isString(blockNumber)) {\n            return blockNumber.toLowerCase();\n        }\n        return blockNumber;\n    }\n    return utils_1.numberToHex(blockNumber);\n};\nexports.isPredefinedBlockNumber = function (blockNumber) {\n    return blockNumber === 'latest' || blockNumber === 'pending' || blockNumber === 'earliest';\n};\nexports.inputAddressFormatter = function (address) {\n    if (utils_1.isAddress(address)) {\n        return \"0x\" + address.toLowerCase().replace('0x', '');\n    }\n    throw new Error(\"Provided address \\\"\" + address + \"\\\" is invalid, the capitalization checksum test failed, or its an indrect IBAN address which can't be converted.\");\n};\nexports.toTopic = function (value) {\n    if (value === null || typeof value === 'undefined') {\n        return null;\n    }\n    value = String(value);\n    if (value.indexOf('0x') === 0) {\n        return value;\n    }\n    return crypto_1.hexlify(abiCoder_1.toUtf8Bytes(value));\n};\n"},"sourceMaps":{"js":{"version":3,"file":"formatter.js","sourceRoot":"","sources":["../../src/utils/formatter.ts"],"names":[],"mappings":";AAAA;;;;GAIG;;;AAEH,6CAAwF;AACxF,2CAO2B;AAC3B,4CAA8C;AAEjC,QAAA,iBAAiB,GAAG,UAAC,OAAY;IAC5C,IAAI,OAAO,CAAC,SAAS,EAAE;QACrB,OAAO,CAAC,SAAS,GAAG,iCAAyB,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;KAClE;IAED,IAAI,OAAO,CAAC,OAAO,EAAE;QACnB,OAAO,CAAC,OAAO,GAAG,iCAAyB,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;KAC9D;IAED,yCAAyC;IACzC,OAAO,CAAC,MAAM,GAAG,OAAO,CAAC,MAAM,IAAI,EAAE,CAAC;IACtC,OAAO,CAAC,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,UAAC,KAAU;QAC7C,OAAO,eAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,eAAO,CAAC,CAAC,CAAC,CAAC,eAAO,CAAC,KAAK,CAAC,CAAC;IAC9D,CAAC,CAAC,CAAC;IAEH,IAAI,OAAO,CAAC,OAAO,EAAE;QACnB,IAAI,eAAO,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE;YAC5B,OAAO,CAAC,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,UAAC,IAAY;gBACjD,OAAO,6BAAqB,CAAC,IAAI,CAAC,CAAC;YACrC,CAAC,CAAC,CAAC;SACJ;aAAM;YACL,OAAO,CAAC,OAAO,GAAG,6BAAqB,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;SAC1D;KACF;IAED,OAAO,OAAO,CAAC;AACjB,CAAC,CAAC;AAEF;;;;;;;;GAQG;AACU,QAAA,kBAAkB,GAAG,UAAC,GAAQ;IACzC,2BAA2B;IAC3B,IACE,OAAO,GAAG,CAAC,SAAS,KAAK,QAAQ;QACjC,OAAO,GAAG,CAAC,eAAe,KAAK,QAAQ;QACvC,OAAO,GAAG,CAAC,QAAQ,KAAK,QAAQ,EAChC;QACA,IAAM,KAAK,GAAG,kBAAS,CACrB,IAAI;YACF,GAAG,CAAC,SAAS,CAAC,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC;YAC/B,GAAG,CAAC,eAAe,CAAC,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC;YACrC,GAAG,CAAC,QAAQ,CAAC,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,CACjC,CAAC;QAEF,KAAK,CAAC,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAErC,GAAG,CAAC,EAAE,GAAG,SAAO,KAAO,CAAC;KACzB;SAAM,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE;QAClB,GAAG,CAAC,EAAE,GAAG,IAAI,CAAC;KACf;IAED,IAAI,GAAG,CAAC,WAAW,KAAK,IAAI,EAAE;QAC5B,GAAG,CAAC,WAAW,GAAG,eAAO,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC,QAAQ,EAAE,CAAC;KACvD;IAED,IAAI,GAAG,CAAC,gBAAgB,KAAK,IAAI,EAAE;QACjC,GAAG,CAAC,gBAAgB,GAAG,eAAO,CAAC,GAAG,CAAC,gBAAgB,CAAC,CAAC,QAAQ,EAAE,CAAC;KACjE;IAED,IAAI,GAAG,CAAC,QAAQ,KAAK,IAAI,EAAE;QACzB,GAAG,CAAC,QAAQ,GAAG,eAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,QAAQ,EAAE,CAAC;KACjD;IAED,IAAI,GAAG,CAAC,OAAO,EAAE;QACf,GAAG,CAAC,OAAO,GAAG,0BAAiB,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;KAC9C;IAED,OAAO,GAAG,CAAC;AACb,CAAC,CAAC;AAEW,QAAA,yBAAyB,GAAG,UAAC,WAAgB;IACxD,IAAI,WAAW,KAAK,SAAS,IAAI,WAAW,KAAK,IAAI,IAAI,+BAAuB,CAAC,WAAW,CAAC,EAAE;QAC7F,OAAO,WAAW,CAAC;KACpB;IAED,IAAI,oBAAW,CAAC,WAAW,CAAC,EAAE;QAC5B,IAAI,gBAAQ,CAAC,WAAW,CAAC,EAAE;YACzB,OAAO,WAAW,CAAC,WAAW,EAAE,CAAC;SAClC;QAED,OAAO,WAAW,CAAC;KACpB;IAED,OAAO,mBAAW,CAAC,WAAW,CAAC,CAAC;AAClC,CAAC,CAAC;AAEW,QAAA,uBAAuB,GAAG,UAAC,WAAmB;IACzD,OAAO,WAAW,KAAK,QAAQ,IAAI,WAAW,KAAK,SAAS,IAAI,WAAW,KAAK,UAAU,CAAC;AAC7F,CAAC,CAAC;AAEW,QAAA,qBAAqB,GAAG,UAAC,OAAe;IACnD,IAAI,iBAAS,CAAC,OAAO,CAAC,EAAE;QACtB,OAAO,OAAK,OAAO,CAAC,WAAW,EAAE,CAAC,OAAO,CAAC,IAAI,EAAE,EAAE,CAAG,CAAC;KACvD;IAED,MAAM,IAAI,KAAK,CACb,wBAAqB,OAAO,qHAAiH,CAC9I,CAAC;AACJ,CAAC,CAAC;AAEW,QAAA,OAAO,GAAG,UAAC,KAAU;IAChC,IAAI,KAAK,KAAK,IAAI,IAAI,OAAO,KAAK,KAAK,WAAW,EAAE;QAClD,OAAO,IAAI,CAAC;KACb;IAED,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC;IAEtB,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE;QAC7B,OAAO,KAAK,CAAC;KACd;IAED,OAAO,gBAAO,CAAC,sBAAW,CAAC,KAAK,CAAC,CAAC,CAAC;AACrC,CAAC,CAAC","sourcesContent":["/**\n * @packageDocumentation\n * @module harmony-contract\n * @hidden\n */\n\nimport { hexlify, isHexString, keccak256, toChecksumAddress } from '@harmony-js/crypto';\nimport {\n  numberToHex,\n  isArray,\n  // hexToNumber,\n  isString,\n  isAddress,\n  hexToBN,\n} from '@harmony-js/utils';\nimport { toUtf8Bytes } from '../abi/abiCoder';\n\nexport const inputLogFormatter = (options: any) => {\n  if (options.fromBlock) {\n    options.fromBlock = inputBlockNumberFormatter(options.fromBlock);\n  }\n\n  if (options.toBlock) {\n    options.toBlock = inputBlockNumberFormatter(options.toBlock);\n  }\n\n  // make sure topics, get converted to hex\n  options.topics = options.topics || [];\n  options.topics = options.topics.map((topic: any) => {\n    return isArray(topic) ? topic.map(toTopic) : toTopic(topic);\n  });\n\n  if (options.address) {\n    if (isArray(options.address)) {\n      options.address = options.address.map((addr: string) => {\n        return inputAddressFormatter(addr);\n      });\n    } else {\n      options.address = inputAddressFormatter(options.address);\n    }\n  }\n\n  return options;\n};\n\n/**\n * Formats the output of a log\n *\n * @method outputLogFormatter\n *\n * @param {Object} log object\n *\n * @returns {Object} log\n */\nexport const outputLogFormatter = (log: any) => {\n  // generate a custom log id\n  if (\n    typeof log.blockHash === 'string' &&\n    typeof log.transactionHash === 'string' &&\n    typeof log.logIndex === 'string'\n  ) {\n    const shaId = keccak256(\n      '0x' +\n        log.blockHash.replace('0x', '') +\n        log.transactionHash.replace('0x', '') +\n        log.logIndex.replace('0x', ''),\n    );\n\n    shaId.replace('0x', '').substr(0, 8);\n\n    log.id = `log_${shaId}`;\n  } else if (!log.id) {\n    log.id = null;\n  }\n\n  if (log.blockNumber !== null) {\n    log.blockNumber = hexToBN(log.blockNumber).toNumber();\n  }\n\n  if (log.transactionIndex !== null) {\n    log.transactionIndex = hexToBN(log.transactionIndex).toNumber();\n  }\n\n  if (log.logIndex !== null) {\n    log.logIndex = hexToBN(log.logIndex).toNumber();\n  }\n\n  if (log.address) {\n    log.address = toChecksumAddress(log.address);\n  }\n\n  return log;\n};\n\nexport const inputBlockNumberFormatter = (blockNumber: any) => {\n  if (blockNumber === undefined || blockNumber === null || isPredefinedBlockNumber(blockNumber)) {\n    return blockNumber;\n  }\n\n  if (isHexString(blockNumber)) {\n    if (isString(blockNumber)) {\n      return blockNumber.toLowerCase();\n    }\n\n    return blockNumber;\n  }\n\n  return numberToHex(blockNumber);\n};\n\nexport const isPredefinedBlockNumber = (blockNumber: string) => {\n  return blockNumber === 'latest' || blockNumber === 'pending' || blockNumber === 'earliest';\n};\n\nexport const inputAddressFormatter = (address: string) => {\n  if (isAddress(address)) {\n    return `0x${address.toLowerCase().replace('0x', '')}`;\n  }\n\n  throw new Error(\n    `Provided address \"${address}\" is invalid, the capitalization checksum test failed, or its an indrect IBAN address which can't be converted.`,\n  );\n};\n\nexport const toTopic = (value: any) => {\n  if (value === null || typeof value === 'undefined') {\n    return null;\n  }\n\n  value = String(value);\n\n  if (value.indexOf('0x') === 0) {\n    return value;\n  }\n\n  return hexlify(toUtf8Bytes(value));\n};\n"]}},"error":null,"hash":"a8bbac0eb89821acede7ab230c1293c7","cacheData":{"env":{}}}