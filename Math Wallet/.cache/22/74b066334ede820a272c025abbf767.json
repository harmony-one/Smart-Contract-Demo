{"id":"../node_modules/@harmony-js/account/dist/account.js","dependencies":[{"name":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/account/dist/account.js.map","includedInParent":true,"mtime":499162500000},{"name":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/account/src/account.ts","includedInParent":true,"mtime":499162500000},{"name":"/home/rachit/Projects/demo/web Math Wallet/package.json","includedInParent":true,"mtime":1605273881149},{"name":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/account/package.json","includedInParent":true,"mtime":1605232158322},{"name":"tslib","loc":{"line":9,"column":22},"parent":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/account/dist/account.js","resolved":"/home/rachit/Projects/demo/node_modules/tslib/tslib.es6.js"},{"name":"@harmony-js/crypto","loc":{"line":10,"column":23},"parent":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/account/dist/account.js","resolved":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/crypto/dist/index.js"},{"name":"@harmony-js/utils","loc":{"line":11,"column":22},"parent":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/account/dist/account.js","resolved":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/utils/dist/index.js"},{"name":"@harmony-js/transaction","loc":{"line":12,"column":28},"parent":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/account/dist/account.js","resolved":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/transaction/dist/index.js"},{"name":"@harmony-js/network","loc":{"line":13,"column":24},"parent":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/account/dist/account.js","resolved":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/network/dist/index.js"},{"name":"./utils","loc":{"line":14,"column":22},"parent":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/account/dist/account.js","resolved":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/account/dist/utils.js"}],"generated":{"js":"\"use strict\";\n/**\n * @packageDocumentation\n * @module harmony-account\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Account = void 0;\nvar tslib_1 = require(\"tslib\");\nvar crypto_1 = require(\"@harmony-js/crypto\");\nvar utils_1 = require(\"@harmony-js/utils\");\nvar transaction_1 = require(\"@harmony-js/transaction\");\nvar network_1 = require(\"@harmony-js/network\");\nvar utils_2 = require(\"./utils\");\nvar Account = /** @class */ (function () {\n    /**\n     * Generate an account object\n     *\n     * @param key import an existing privateKey, or create a random one\n     * @param messenger you can setMessage later, or set message on `new`\n     *\n     * @example\n     * ```javascript\n     * // import the Account class\n     * const { Account } = require('@harmony-js/account');\n     *\n     * // Messenger is optional, by default, we have a defaultMessenger\n     * // If you like to change, you will import related package here.\n     * const { HttpProvider, Messenger } = require('@harmony-js/network');\n     * const { ChainType, ChainID } = require('@harmony-js/utils');\n     *\n     * // create a custom messenger\n     * const customMessenger = new Messenger(\n     *   new HttpProvider('http://localhost:9500'),\n     *   ChainType.Harmony, // if you are connected to Harmony's blockchain\n     *   ChainID.HmyLocal, // check if the chainId is correct\n     * )\n     *\n     * // setMessenger later\n     * const randomAccount = new Account()\n     * randomAccount.setMessenger(customMessenger)\n     *\n     * // or you can set messenger on `new`\n     * const randomAccountWithCustomMessenger = new Account(undefined, customMessenger)\n     *\n     * // NOTED: Key with or without `0x` are accepted, makes no different\n     * // NOTED: DO NOT import `mnemonic phrase` using `Account` class, use `Wallet` instead\n     * const myPrivateKey = '0xe19d05c5452598e24caad4a0d85a49146f7be089515c905ae6a19e8a578a6930'\n     * const myAccountWithMyPrivateKey = new Account(myPrivateKey)\n     * ```\n     */\n    function Account(key, messenger) {\n        if (messenger === void 0) { messenger = utils_2.defaultMessenger; }\n        /**@hidden */\n        this.balance = '0';\n        /**@hidden */\n        this.nonce = 0;\n        /**@hidden */\n        this.encrypted = false;\n        this.messenger = messenger;\n        if (!key) {\n            this._new();\n        }\n        else {\n            this._import(key);\n        }\n        this.shardID = this.messenger.currentShard || 0;\n        this.shards = new Map();\n        this.shards.set(this.shardID, {\n            address: \"\" + this.bech32Address + utils_1.AddressSuffix + \"0\",\n            balance: this.balance || '0',\n            nonce: this.nonce || 0,\n        });\n    }\n    /**\n     * static method create account\n     *\n     * @example\n     * ```javascript\n     * const account = new Account();\n     * console.log(account);\n     * ```\n     */\n    Account.new = function () {\n        var newAcc = new Account()._new();\n        return newAcc;\n    };\n    /**\n     * Static Method: add a private key to Account\n     * @param  {string} key - private Key\n     *\n     * @example\n     * ```javascript\n     * const account = new Account.add(key_1);\n     * console.log(account);\n     * ```\n     */\n    Account.add = function (key) {\n        var newAcc = new Account()._import(key);\n        return newAcc;\n    };\n    Object.defineProperty(Account.prototype, \"checksumAddress\", {\n        /**\n         * check sum address\n         *\n         * @example\n         * ```javascript\n         * console.log(account.checksumAddress);\n         * ```\n         */\n        get: function () {\n            return this.address ? crypto_1.getAddress(this.address).checksum : '';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Account.prototype, \"bech32Address\", {\n        /**\n         * Get bech32 Address\n         *\n         * @example\n         * ```javascript\n         * console.log(account.bech32Address);\n         * ```\n         */\n        get: function () {\n            return this.address ? crypto_1.getAddress(this.address).bech32 : '';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Account.prototype, \"bech32TestNetAddress\", {\n        /**\n         * get Bech32 TestNet Address\n         *\n         * @example\n         * ```javascript\n         * console.log(account.bech32TestNetAddress);\n         * ```\n         */\n        get: function () {\n            return this.address ? crypto_1.getAddress(this.address).bech32TestNet : '';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Account.prototype, \"getShardsCount\", {\n        /**\n         * get Shards number with this Account\n         *\n         * @example\n         * ```javascript\n         * console.log(account.getShardsCount);\n         * ```\n         */\n        get: function () {\n            return this.shards.size;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Account.prototype.toFile = function (password, options) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var file;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!(this.privateKey && utils_1.isPrivateKey(this.privateKey))) return [3 /*break*/, 2];\n                        return [4 /*yield*/, crypto_1.encrypt(this.privateKey, password, options)];\n                    case 1:\n                        file = _a.sent();\n                        this.privateKey = file;\n                        this.encrypted = true;\n                        return [2 /*return*/, file];\n                    case 2: throw new Error('Encryption failed because PrivateKey is not correct');\n                }\n            });\n        });\n    };\n    Account.prototype.fromFile = function (keyStore, password) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var file, decyptedPrivateKey, error_1;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        if (typeof password !== 'string') {\n                            throw new Error('you must provide password');\n                        }\n                        file = JSON.parse(keyStore.toLowerCase());\n                        return [4 /*yield*/, crypto_1.decrypt(file, password)];\n                    case 1:\n                        decyptedPrivateKey = _a.sent();\n                        if (utils_1.isPrivateKey(decyptedPrivateKey)) {\n                            return [2 /*return*/, this._import(decyptedPrivateKey)];\n                        }\n                        else {\n                            throw new Error('decrypted failed');\n                        }\n                        return [3 /*break*/, 3];\n                    case 2:\n                        error_1 = _a.sent();\n                        throw error_1;\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Get the account balance\n     *\n     * @param blockNumber by default, it's `latest`\n     *\n     * @example\n     * ```javascript\n     * account.getBalance().then((value) => {\n     *   console.log(value);\n     * });\n     * ```\n     */\n    Account.prototype.getBalance = function (blockNumber) {\n        if (blockNumber === void 0) { blockNumber = 'latest'; }\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var balance, nonce, error_2;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 5, , 6]);\n                        if (!this.messenger) return [3 /*break*/, 3];\n                        return [4 /*yield*/, this.messenger.send(network_1.RPCMethod.GetBalance, [this.address, blockNumber], this.messenger.chainPrefix, this.messenger.currentShard || 0)];\n                    case 1:\n                        balance = _a.sent();\n                        return [4 /*yield*/, this.messenger.send(network_1.RPCMethod.GetTransactionCount, [this.address, blockNumber], this.messenger.chainPrefix, this.messenger.currentShard || 0)];\n                    case 2:\n                        nonce = _a.sent();\n                        if (balance.isError()) {\n                            throw balance.error.message;\n                        }\n                        if (nonce.isError()) {\n                            throw nonce.error.message;\n                        }\n                        this.balance = utils_1.hexToNumber(balance.result);\n                        this.nonce = Number.parseInt(utils_1.hexToNumber(nonce.result), 10);\n                        this.shardID = this.messenger.currentShard || 0;\n                        return [3 /*break*/, 4];\n                    case 3: throw new Error('No Messenger found');\n                    case 4: return [2 /*return*/, {\n                            balance: this.balance,\n                            nonce: this.nonce,\n                            shardID: this.shardID,\n                        }];\n                    case 5:\n                        error_2 = _a.sent();\n                        throw error_2;\n                    case 6: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * @function updateShards\n     */\n    Account.prototype.updateBalances = function (blockNumber) {\n        if (blockNumber === void 0) { blockNumber = 'latest'; }\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var shardProviders, shardProviders_1, shardProviders_1_1, _a, name_1, val, balanceObject, e_1_1, currentShard;\n            var e_1, _b;\n            return tslib_1.__generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        shardProviders = this.messenger.shardProviders;\n                        if (!(shardProviders.size > 1)) return [3 /*break*/, 10];\n                        _c.label = 1;\n                    case 1:\n                        _c.trys.push([1, 7, 8, 9]);\n                        shardProviders_1 = tslib_1.__values(shardProviders), shardProviders_1_1 = shardProviders_1.next();\n                        _c.label = 2;\n                    case 2:\n                        if (!!shardProviders_1_1.done) return [3 /*break*/, 6];\n                        _a = tslib_1.__read(shardProviders_1_1.value, 2), name_1 = _a[0], val = _a[1];\n                        return [4 /*yield*/, this.getShardBalance(val.shardID, blockNumber)];\n                    case 3:\n                        balanceObject = _c.sent();\n                        return [4 /*yield*/, this.shards.set(name_1 === val.shardID ? name_1 : val.shardID, balanceObject)];\n                    case 4:\n                        _c.sent();\n                        _c.label = 5;\n                    case 5:\n                        shardProviders_1_1 = shardProviders_1.next();\n                        return [3 /*break*/, 2];\n                    case 6: return [3 /*break*/, 9];\n                    case 7:\n                        e_1_1 = _c.sent();\n                        e_1 = { error: e_1_1 };\n                        return [3 /*break*/, 9];\n                    case 8:\n                        try {\n                            if (shardProviders_1_1 && !shardProviders_1_1.done && (_b = shardProviders_1.return)) _b.call(shardProviders_1);\n                        }\n                        finally { if (e_1) throw e_1.error; }\n                        return [7 /*endfinally*/];\n                    case 9: return [3 /*break*/, 12];\n                    case 10: return [4 /*yield*/, this.getShardBalance(this.messenger.currentShard || 0, blockNumber)];\n                    case 11:\n                        currentShard = _c.sent();\n                        this.shards.set(this.messenger.currentShard || 0, currentShard);\n                        _c.label = 12;\n                    case 12: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * @function signTransaction\n     */\n    Account.prototype.signTransaction = function (transaction, updateNonce, encodeMode, blockNumber) {\n        if (updateNonce === void 0) { updateNonce = true; }\n        if (encodeMode === void 0) { encodeMode = 'rlp'; }\n        if (blockNumber === void 0) { blockNumber = 'latest'; }\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var txShardID, shardBalanceObject, shardNonce, _a, signature_1, rawTransaction_1;\n            var _this = this;\n            return tslib_1.__generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (!this.privateKey || !utils_1.isPrivateKey(this.privateKey)) {\n                            throw new Error(this.privateKey + \" is not found or not correct\");\n                        }\n                        if (!updateNonce) return [3 /*break*/, 2];\n                        txShardID = transaction.txParams.shardID;\n                        return [4 /*yield*/, this.getShardBalance(typeof txShardID === 'string' ? Number.parseInt(txShardID, 10) : txShardID, blockNumber)];\n                    case 1:\n                        shardBalanceObject = _b.sent();\n                        if (shardBalanceObject !== undefined) {\n                            shardNonce = shardBalanceObject.nonce;\n                            transaction.setParams(tslib_1.__assign(tslib_1.__assign({}, transaction.txParams), { from: this.messenger.chainPrefix === utils_1.ChainType.Harmony\n                                    ? this.bech32Address\n                                    : this.checksumAddress || '0x', nonce: shardNonce }));\n                        }\n                        else {\n                            transaction.setParams(tslib_1.__assign(tslib_1.__assign({}, transaction.txParams), { from: this.messenger.chainPrefix === utils_1.ChainType.Harmony\n                                    ? this.bech32Address\n                                    : this.checksumAddress || '0x', nonce: 0 }));\n                        }\n                        _b.label = 2;\n                    case 2:\n                        if (encodeMode === 'rlp') {\n                            _a = tslib_1.__read(transaction_1.RLPSign(transaction, this.privateKey), 2), signature_1 = _a[0], rawTransaction_1 = _a[1];\n                            return [2 /*return*/, transaction.map(function (obj) {\n                                    return tslib_1.__assign(tslib_1.__assign({}, obj), { signature: signature_1,\n                                        rawTransaction: rawTransaction_1, from: _this.messenger.chainPrefix === utils_1.ChainType.Harmony\n                                            ? _this.bech32Address\n                                            : _this.checksumAddress || '0x' });\n                                })];\n                        }\n                        else {\n                            // TODO: if we use other encode method, eg. protobuf, we should implement this\n                            return [2 /*return*/, transaction];\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * This function is still in development, coming soon!\n     *\n     * @param staking\n     * @param updateNonce\n     * @param encodeMode\n     * @param blockNumber\n     * @param shardID\n     */\n    Account.prototype.signStaking = function (staking, updateNonce, encodeMode, blockNumber, shardID) {\n        if (updateNonce === void 0) { updateNonce = true; }\n        if (encodeMode === void 0) { encodeMode = 'rlp'; }\n        if (blockNumber === void 0) { blockNumber = 'latest'; }\n        if (shardID === void 0) { shardID = this.messenger.currentShard; }\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var txShardID, shardBalanceObject, shardNonce, _a, signature, rawTransaction;\n            return tslib_1.__generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (!this.privateKey || !utils_1.isPrivateKey(this.privateKey)) {\n                            throw new Error(this.privateKey + \" is not found or not correct\");\n                        }\n                        if (!updateNonce) return [3 /*break*/, 2];\n                        txShardID = shardID;\n                        return [4 /*yield*/, this.getShardBalance(typeof txShardID === 'string' ? Number.parseInt(txShardID, 10) : txShardID, blockNumber)];\n                    case 1:\n                        shardBalanceObject = _b.sent();\n                        if (shardBalanceObject !== undefined) {\n                            shardNonce = shardBalanceObject.nonce;\n                            staking.setFromAddress(this.messenger.chainPrefix === utils_1.ChainType.Harmony\n                                ? this.bech32Address\n                                : this.checksumAddress || '0x');\n                            staking.setNonce(shardNonce);\n                        }\n                        else {\n                            staking.setFromAddress(this.messenger.chainPrefix === utils_1.ChainType.Harmony\n                                ? this.bech32Address\n                                : this.checksumAddress || '0x');\n                            staking.setNonce(0);\n                        }\n                        _b.label = 2;\n                    case 2:\n                        if (encodeMode === 'rlp') {\n                            _a = tslib_1.__read(staking.rlpSign(this.privateKey), 2), signature = _a[0], rawTransaction = _a[1];\n                            staking.setRawTransaction(rawTransaction);\n                            staking.setSignature(signature);\n                            staking.setFromAddress(this.messenger.chainPrefix === utils_1.ChainType.Harmony\n                                ? this.bech32Address\n                                : this.checksumAddress || '0x');\n                            return [2 /*return*/, staking];\n                        }\n                        else {\n                            // TODO: if we use other encode method, eg. protobuf, we should implement this\n                            return [2 /*return*/, staking];\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * @param messenger\n     *\n     * @example\n     * ```javascript\n     * // create a custom messenger\n     * const customMessenger = new Messenger(\n     *   new HttpProvider('http://localhost:9500'),\n     *   ChainType.Harmony, // if you are connected to Harmony's blockchain\n     *   ChainID.HmyLocal, // check if the chainId is correct\n     * )\n     *\n     * // to create an Account with random privateKey\n     * // and you can setMessenger later\n     * const randomAccount = new Account()\n     * randomAccount.setMessenger(customMessenger)\n     * ```\n     */\n    Account.prototype.setMessenger = function (messenger) {\n        this.messenger = messenger;\n    };\n    /**\n     * Get account address from shard ID\n     * @param shardID\n     *\n     * @example\n     * ```javascript\n     * console.log(account.getAddressFromShardID(0));\n     *\n     * > one103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7-0\n     * ```\n     */\n    Account.prototype.getAddressFromShardID = function (shardID) {\n        var shardObject = this.shards.get(shardID);\n        if (shardObject) {\n            return shardObject.address;\n        }\n        else {\n            return undefined;\n        }\n    };\n    /**\n     * Get all shards' addresses from the account\n     *\n     * @example\n     * ```javascript\n     * console.log(account.getAddresses());\n     * ```\n     */\n    Account.prototype.getAddresses = function () {\n        var e_2, _a;\n        var addressArray = [];\n        try {\n            for (var _b = tslib_1.__values(this.shards), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var _d = tslib_1.__read(_c.value, 2), name_2 = _d[0], val = _d[1];\n                var index = typeof name_2 === 'string' ? Number.parseInt(name_2, 10) : name_2;\n                addressArray[index] = val.address;\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        return addressArray;\n    };\n    /**\n     * Get the specific shard's balance\n     *\n     * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n     * @param blockNumber by default, it's `latest`\n     *\n     * @example\n     * ```\n     * account.getShardBalance().then((value) => {\n     *   console.log(value);\n     * });\n     * ```\n     */\n    Account.prototype.getShardBalance = function (shardID, blockNumber) {\n        if (blockNumber === void 0) { blockNumber = 'latest'; }\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var balance, nonce;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.messenger.send(network_1.RPCMethod.GetBalance, [this.address, blockNumber], this.messenger.chainPrefix, shardID)];\n                    case 1:\n                        balance = _a.sent();\n                        return [4 /*yield*/, this.messenger.send(network_1.RPCMethod.GetTransactionCount, [this.address, blockNumber], this.messenger.chainPrefix, shardID)];\n                    case 2:\n                        nonce = _a.sent();\n                        if (balance.isError()) {\n                            throw balance.error.message;\n                        }\n                        if (nonce.isError()) {\n                            throw nonce.error.message;\n                        }\n                        return [2 /*return*/, {\n                                address: \"\" + this.bech32Address + utils_1.AddressSuffix + shardID,\n                                balance: utils_1.hexToNumber(balance.result),\n                                nonce: Number.parseInt(utils_1.hexToNumber(nonce.result), 10),\n                            }];\n                }\n            });\n        });\n    };\n    /**\n     * @function _new private method create Account\n     * @return {Account} Account instance\n     * @ignore\n     */\n    Account.prototype._new = function () {\n        var prv = crypto_1.generatePrivateKey();\n        if (!utils_1.isPrivateKey(prv)) {\n            throw new Error('key gen failed');\n        }\n        return this._import(prv);\n    };\n    /**\n     * @function _import private method import a private Key\n     * @param  {string} key - private key\n     * @return {Account} Account instance\n     * @ignore\n     */\n    Account.prototype._import = function (key) {\n        if (!utils_1.isPrivateKey(key)) {\n            throw new Error(key + \" is not PrivateKey\");\n        }\n        this.privateKey = utils_1.add0xToString(key);\n        this.publicKey = crypto_1.getPubkeyFromPrivateKey(this.privateKey);\n        this.address = crypto_1.getAddressFromPrivateKey(this.privateKey);\n        this.shardID = this.messenger.currentShard || 0;\n        this.shards = new Map();\n        this.shards.set(this.shardID, {\n            address: \"\" + this.bech32Address + utils_1.AddressSuffix + \"0\",\n            balance: this.balance || '0',\n            nonce: this.nonce || 0,\n        });\n        this.encrypted = false;\n        return this;\n    };\n    return Account;\n}());\nexports.Account = Account;\n"},"sourceMaps":{"js":{"version":3,"file":"account.js","sourceRoot":"","sources":["../src/account.ts"],"names":[],"mappings":";AAAA;;;;GAIG;;;;AAEH,6CAW4B;AAE5B,2CAM2B;AAC3B,uDAA+D;AAE/D,+CAA2D;AAE3D,iCAA2C;AAQ3C;IAgGE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OAmCG;IACH,iBAAY,GAAY,EAAE,SAAuC;QAAvC,0BAAA,EAAA,YAAuB,wBAAgB;QAjGjE,aAAa;QACb,YAAO,GAAY,GAAG,CAAC;QACvB,aAAa;QACb,UAAK,GAAY,CAAC,CAAC;QAOnB,aAAa;QACb,cAAS,GAAY,KAAK,CAAC;QAuFzB,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;QAC3B,IAAI,CAAC,GAAG,EAAE;YACR,IAAI,CAAC,IAAI,EAAE,CAAC;SACb;aAAM;YACL,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;SACnB;QACD,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,YAAY,IAAI,CAAC,CAAC;QAChD,IAAI,CAAC,MAAM,GAAG,IAAI,GAAG,EAAE,CAAC;QACxB,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,OAAO,EAAE;YAC5B,OAAO,EAAE,KAAG,IAAI,CAAC,aAAa,GAAG,qBAAa,MAAG;YACjD,OAAO,EAAE,IAAI,CAAC,OAAO,IAAI,GAAG;YAC5B,KAAK,EAAE,IAAI,CAAC,KAAK,IAAI,CAAC;SACvB,CAAC,CAAC;IACL,CAAC;IAjJD;;;;;;;;OAQG;IACI,WAAG,GAAV;QACE,IAAM,MAAM,GAAG,IAAI,OAAO,EAAE,CAAC,IAAI,EAAE,CAAC;QACpC,OAAO,MAAM,CAAC;IAChB,CAAC;IACD;;;;;;;;;OASG;IACI,WAAG,GAAV,UAAW,GAAW;QACpB,IAAM,MAAM,GAAG,IAAI,OAAO,EAAE,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;QAC1C,OAAO,MAAM,CAAC;IAChB,CAAC;IA6BD,sBAAI,oCAAe;QARnB;;;;;;;WAOG;aACH;YACE,OAAO,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,mBAAU,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC;QAC/D,CAAC;;;OAAA;IAUD,sBAAI,kCAAa;QARjB;;;;;;;WAOG;aACH;YACE,OAAO,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,mBAAU,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC;QAC7D,CAAC;;;OAAA;IAUD,sBAAI,yCAAoB;QARxB;;;;;;;WAOG;aACH;YACE,OAAO,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,mBAAU,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC,EAAE,CAAC;QACpE,CAAC;;;OAAA;IAUD,sBAAI,mCAAc;QARlB;;;;;;;WAOG;aACH;YACE,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;QAC1B,CAAC;;;OAAA;IAsDK,wBAAM,GAAZ,UAAa,QAAgB,EAAE,OAAwB;;;;;;6BACjD,CAAA,IAAI,CAAC,UAAU,IAAI,oBAAY,CAAC,IAAI,CAAC,UAAU,CAAC,CAAA,EAAhD,wBAAgD;wBACrC,qBAAM,gBAAO,CAAC,IAAI,CAAC,UAAU,EAAE,QAAQ,EAAE,OAAO,CAAC,EAAA;;wBAAxD,IAAI,GAAG,SAAiD;wBAC9D,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;wBACvB,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;wBACtB,sBAAO,IAAI,EAAC;4BAEZ,MAAM,IAAI,KAAK,CAAC,qDAAqD,CAAC,CAAC;;;;KAE1E;IAEK,0BAAQ,GAAd,UAAe,QAAgB,EAAE,QAAgB;;;;;;;wBAE7C,IAAI,OAAO,QAAQ,KAAK,QAAQ,EAAE;4BAChC,MAAM,IAAI,KAAK,CAAC,2BAA2B,CAAC,CAAC;yBAC9C;wBACK,IAAI,GAAa,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,WAAW,EAAE,CAAC,CAAC;wBAC/B,qBAAM,gBAAO,CAAC,IAAI,EAAE,QAAQ,CAAC,EAAA;;wBAAlD,kBAAkB,GAAG,SAA6B;wBACxD,IAAI,oBAAY,CAAC,kBAAkB,CAAC,EAAE;4BACpC,sBAAO,IAAI,CAAC,OAAO,CAAC,kBAAkB,CAAC,EAAC;yBACzC;6BAAM;4BACL,MAAM,IAAI,KAAK,CAAC,kBAAkB,CAAC,CAAC;yBACrC;;;;wBAED,MAAM,OAAK,CAAC;;;;;KAEf;IAED;;;;;;;;;;;OAWG;IACG,4BAAU,GAAhB,UAAiB,WAA8B;QAA9B,4BAAA,EAAA,sBAA8B;;;;;;;6BAEvC,IAAI,CAAC,SAAS,EAAd,wBAAc;wBACA,qBAAM,IAAI,CAAC,SAAS,CAAC,IAAI,CACvC,mBAAS,CAAC,UAAU,EACpB,CAAC,IAAI,CAAC,OAAO,EAAE,WAAW,CAAC,EAC3B,IAAI,CAAC,SAAS,CAAC,WAAW,EAC1B,IAAI,CAAC,SAAS,CAAC,YAAY,IAAI,CAAC,CACjC,EAAA;;wBALK,OAAO,GAAG,SAKf;wBAEa,qBAAM,IAAI,CAAC,SAAS,CAAC,IAAI,CACrC,mBAAS,CAAC,mBAAmB,EAC7B,CAAC,IAAI,CAAC,OAAO,EAAE,WAAW,CAAC,EAC3B,IAAI,CAAC,SAAS,CAAC,WAAW,EAC1B,IAAI,CAAC,SAAS,CAAC,YAAY,IAAI,CAAC,CACjC,EAAA;;wBALK,KAAK,GAAG,SAKb;wBACD,IAAI,OAAO,CAAC,OAAO,EAAE,EAAE;4BACrB,MAAM,OAAO,CAAC,KAAK,CAAC,OAAO,CAAC;yBAC7B;wBACD,IAAI,KAAK,CAAC,OAAO,EAAE,EAAE;4BACnB,MAAM,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC;yBAC3B;wBAED,IAAI,CAAC,OAAO,GAAG,mBAAW,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;wBAC3C,IAAI,CAAC,KAAK,GAAG,MAAM,CAAC,QAAQ,CAAC,mBAAW,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE,EAAE,CAAC,CAAC;wBAC5D,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,YAAY,IAAI,CAAC,CAAC;;4BAEhD,MAAM,IAAI,KAAK,CAAC,oBAAoB,CAAC,CAAC;4BAExC,sBAAO;4BACL,OAAO,EAAE,IAAI,CAAC,OAAO;4BACrB,KAAK,EAAE,IAAI,CAAC,KAAK;4BACjB,OAAO,EAAE,IAAI,CAAC,OAAO;yBACtB,EAAC;;;wBAEF,MAAM,OAAK,CAAC;;;;;KAEf;IAED;;OAEG;IACG,gCAAc,GAApB,UAAqB,WAA8B;QAA9B,4BAAA,EAAA,sBAA8B;;;;;;;wBAE3C,cAAc,GAAG,IAAI,CAAC,SAAS,CAAC,cAAc,CAAC;6BACjD,CAAA,cAAc,CAAC,IAAI,GAAG,CAAC,CAAA,EAAvB,yBAAuB;;;;wBACC,mBAAA,iBAAA,cAAc,CAAA;;;;wBAA7B,KAAA,2CAAW,EAAV,cAAI,EAAE,GAAG,QAAA;wBACG,qBAAM,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,OAAO,EAAE,WAAW,CAAC,EAAA;;wBAApE,aAAa,GAAG,SAAoD;wBAC1E,qBAAM,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,MAAI,KAAK,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,MAAI,CAAC,CAAC,CAAC,GAAG,CAAC,OAAO,EAAE,aAAa,CAAC,EAAA;;wBAA/E,SAA+E,CAAC;;;;;;;;;;;;;;;;;6BAG7D,qBAAM,IAAI,CAAC,eAAe,CAC7C,IAAI,CAAC,SAAS,CAAC,YAAY,IAAI,CAAC,EAChC,WAAW,CACZ,EAAA;;wBAHK,YAAY,GAAG,SAGpB;wBACD,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,YAAY,IAAI,CAAC,EAAE,YAAY,CAAC,CAAC;;;;;;KAEnE;IAED;;OAEG;IACG,iCAAe,GAArB,UACE,WAAwB,EACxB,WAA2B,EAC3B,UAA0B,EAC1B,WAA8B;QAF9B,4BAAA,EAAA,kBAA2B;QAC3B,2BAAA,EAAA,kBAA0B;QAC1B,4BAAA,EAAA,sBAA8B;;;;;;;wBAE9B,IAAI,CAAC,IAAI,CAAC,UAAU,IAAI,CAAC,oBAAY,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE;4BACtD,MAAM,IAAI,KAAK,CAAI,IAAI,CAAC,UAAU,iCAA8B,CAAC,CAAC;yBACnE;6BAEG,WAAW,EAAX,wBAAW;wBAEP,SAAS,GAAG,WAAW,CAAC,QAAQ,CAAC,OAAO,CAAC;wBACpB,qBAAM,IAAI,CAAC,eAAe,CACnD,OAAO,SAAS,KAAK,QAAQ,CAAC,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,SAAS,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,SAAS,EAC1E,WAAW,CACZ,EAAA;;wBAHK,kBAAkB,GAAG,SAG1B;wBACD,IAAI,kBAAkB,KAAK,SAAS,EAAE;4BAC9B,UAAU,GAAG,kBAAkB,CAAC,KAAK,CAAC;4BAC5C,WAAW,CAAC,SAAS,uCAChB,WAAW,CAAC,QAAQ,KACvB,IAAI,EACF,IAAI,CAAC,SAAS,CAAC,WAAW,KAAK,iBAAS,CAAC,OAAO;oCAC9C,CAAC,CAAC,IAAI,CAAC,aAAa;oCACpB,CAAC,CAAC,IAAI,CAAC,eAAe,IAAI,IAAI,EAClC,KAAK,EAAE,UAAU,IACjB,CAAC;yBACJ;6BAAM;4BACL,WAAW,CAAC,SAAS,uCAChB,WAAW,CAAC,QAAQ,KACvB,IAAI,EACF,IAAI,CAAC,SAAS,CAAC,WAAW,KAAK,iBAAS,CAAC,OAAO;oCAC9C,CAAC,CAAC,IAAI,CAAC,aAAa;oCACpB,CAAC,CAAC,IAAI,CAAC,eAAe,IAAI,IAAI,EAClC,KAAK,EAAE,CAAC,IACR,CAAC;yBACJ;;;wBAGH,IAAI,UAAU,KAAK,KAAK,EAAE;4BAClB,KAAA,eAAmD,qBAAO,CAC9D,WAAW,EACX,IAAI,CAAC,UAAU,CAChB,IAAA,EAHM,mBAAS,EAAE,wBAAc,CAG9B;4BACF,sBAAO,WAAW,CAAC,GAAG,CAAC,UAAC,GAAQ;oCAC9B,6CACK,GAAG,KACN,SAAS,aAAA;wCACT,cAAc,kBAAA,EACd,IAAI,EACF,KAAI,CAAC,SAAS,CAAC,WAAW,KAAK,iBAAS,CAAC,OAAO;4CAC9C,CAAC,CAAC,KAAI,CAAC,aAAa;4CACpB,CAAC,CAAC,KAAI,CAAC,eAAe,IAAI,IAAI,IAClC;gCACJ,CAAC,CAAC,EAAC;yBACJ;6BAAM;4BACL,8EAA8E;4BAC9E,sBAAO,WAAW,EAAC;yBACpB;;;;;KACF;IAED;;;;;;;;OAQG;IACG,6BAAW,GAAjB,UACE,OAA2B,EAC3B,WAA2B,EAC3B,UAA0B,EAC1B,WAA8B,EAC9B,OAA6C;QAH7C,4BAAA,EAAA,kBAA2B;QAC3B,2BAAA,EAAA,kBAA0B;QAC1B,4BAAA,EAAA,sBAA8B;QAC9B,wBAAA,EAAA,UAAkB,IAAI,CAAC,SAAS,CAAC,YAAY;;;;;;wBAE7C,IAAI,CAAC,IAAI,CAAC,UAAU,IAAI,CAAC,oBAAY,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE;4BACtD,MAAM,IAAI,KAAK,CAAI,IAAI,CAAC,UAAU,iCAA8B,CAAC,CAAC;yBACnE;6BAEG,WAAW,EAAX,wBAAW;wBAEP,SAAS,GAAG,OAAO,CAAC;wBACC,qBAAM,IAAI,CAAC,eAAe,CACnD,OAAO,SAAS,KAAK,QAAQ,CAAC,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,SAAS,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,SAAS,EAC1E,WAAW,CACZ,EAAA;;wBAHK,kBAAkB,GAAG,SAG1B;wBACD,IAAI,kBAAkB,KAAK,SAAS,EAAE;4BAC9B,UAAU,GAAG,kBAAkB,CAAC,KAAK,CAAC;4BAE5C,OAAO,CAAC,cAAc,CACpB,IAAI,CAAC,SAAS,CAAC,WAAW,KAAK,iBAAS,CAAC,OAAO;gCAC9C,CAAC,CAAC,IAAI,CAAC,aAAa;gCACpB,CAAC,CAAC,IAAI,CAAC,eAAe,IAAI,IAAI,CACjC,CAAC;4BACF,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;yBAC9B;6BAAM;4BACL,OAAO,CAAC,cAAc,CACpB,IAAI,CAAC,SAAS,CAAC,WAAW,KAAK,iBAAS,CAAC,OAAO;gCAC9C,CAAC,CAAC,IAAI,CAAC,aAAa;gCACpB,CAAC,CAAC,IAAI,CAAC,eAAe,IAAI,IAAI,CACjC,CAAC;4BACF,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;yBACrB;;;wBAGH,IAAI,UAAU,KAAK,KAAK,EAAE;4BAClB,KAAA,eAAmD,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC,IAAA,EAAlF,SAAS,QAAA,EAAE,cAAc,QAAA,CAA0D;4BAC1F,OAAO,CAAC,iBAAiB,CAAC,cAAc,CAAC,CAAC;4BAC1C,OAAO,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC;4BAChC,OAAO,CAAC,cAAc,CACpB,IAAI,CAAC,SAAS,CAAC,WAAW,KAAK,iBAAS,CAAC,OAAO;gCAC9C,CAAC,CAAC,IAAI,CAAC,aAAa;gCACpB,CAAC,CAAC,IAAI,CAAC,eAAe,IAAI,IAAI,CACjC,CAAC;4BAEF,sBAAO,OAAO,EAAC;yBAChB;6BAAM;4BACL,8EAA8E;4BAC9E,sBAAO,OAAO,EAAC;yBAChB;;;;;KACF;IAED;;;;;;;;;;;;;;;;;OAiBG;IACH,8BAAY,GAAZ,UAAa,SAAoB;QAC/B,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;IAC7B,CAAC;IAED;;;;;;;;;;OAUG;IACH,uCAAqB,GAArB,UAAsB,OAAe;QACnC,IAAM,WAAW,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;QAC7C,IAAI,WAAW,EAAE;YACf,OAAO,WAAW,CAAC,OAAO,CAAC;SAC5B;aAAM;YACL,OAAO,SAAS,CAAC;SAClB;IACH,CAAC;IAED;;;;;;;OAOG;IACH,8BAAY,GAAZ;;QACE,IAAM,YAAY,GAAa,EAAE,CAAC;;YAClC,KAA0B,IAAA,KAAA,iBAAA,IAAI,CAAC,MAAM,CAAA,gBAAA,4BAAE;gBAA5B,IAAA,KAAA,2BAAW,EAAV,MAAI,QAAA,EAAE,GAAG,QAAA;gBACnB,IAAM,KAAK,GAAW,OAAO,MAAI,KAAK,QAAQ,CAAC,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,MAAI,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,MAAI,CAAC;gBAClF,YAAY,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC,OAAO,CAAC;aACnC;;;;;;;;;QACD,OAAO,YAAY,CAAC;IACtB,CAAC;IAED;;;;;;;;;;;;OAYG;IACG,iCAAe,GAArB,UAAsB,OAAe,EAAE,WAA8B;QAA9B,4BAAA,EAAA,sBAA8B;;;;;4BACnD,qBAAM,IAAI,CAAC,SAAS,CAAC,IAAI,CACvC,mBAAS,CAAC,UAAU,EACpB,CAAC,IAAI,CAAC,OAAO,EAAE,WAAW,CAAC,EAC3B,IAAI,CAAC,SAAS,CAAC,WAAW,EAC1B,OAAO,CACR,EAAA;;wBALK,OAAO,GAAG,SAKf;wBAEa,qBAAM,IAAI,CAAC,SAAS,CAAC,IAAI,CACrC,mBAAS,CAAC,mBAAmB,EAC7B,CAAC,IAAI,CAAC,OAAO,EAAE,WAAW,CAAC,EAC3B,IAAI,CAAC,SAAS,CAAC,WAAW,EAC1B,OAAO,CACR,EAAA;;wBALK,KAAK,GAAG,SAKb;wBAED,IAAI,OAAO,CAAC,OAAO,EAAE,EAAE;4BACrB,MAAM,OAAO,CAAC,KAAK,CAAC,OAAO,CAAC;yBAC7B;wBACD,IAAI,KAAK,CAAC,OAAO,EAAE,EAAE;4BACnB,MAAM,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC;yBAC3B;wBACD,sBAAO;gCACL,OAAO,EAAE,KAAG,IAAI,CAAC,aAAa,GAAG,qBAAa,GAAG,OAAS;gCAC1D,OAAO,EAAE,mBAAW,CAAC,OAAO,CAAC,MAAM,CAAC;gCACpC,KAAK,EAAE,MAAM,CAAC,QAAQ,CAAC,mBAAW,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE,EAAE,CAAC;6BACtD,EAAC;;;;KACH;IAED;;;;OAIG;IACK,sBAAI,GAAZ;QACE,IAAM,GAAG,GAAG,2BAAkB,EAAE,CAAC;QACjC,IAAI,CAAC,oBAAY,CAAC,GAAG,CAAC,EAAE;YACtB,MAAM,IAAI,KAAK,CAAC,gBAAgB,CAAC,CAAC;SACnC;QACD,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;IAC3B,CAAC;IAED;;;;;OAKG;IACK,yBAAO,GAAf,UAAgB,GAAW;QACzB,IAAI,CAAC,oBAAY,CAAC,GAAG,CAAC,EAAE;YACtB,MAAM,IAAI,KAAK,CAAI,GAAG,uBAAoB,CAAC,CAAC;SAC7C;QACD,IAAI,CAAC,UAAU,GAAG,qBAAa,CAAC,GAAG,CAAC,CAAC;QACrC,IAAI,CAAC,SAAS,GAAG,gCAAuB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QAC1D,IAAI,CAAC,OAAO,GAAG,iCAAwB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QACzD,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,YAAY,IAAI,CAAC,CAAC;QAChD,IAAI,CAAC,MAAM,GAAG,IAAI,GAAG,EAAE,CAAC;QACxB,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,OAAO,EAAE;YAC5B,OAAO,EAAE,KAAG,IAAI,CAAC,aAAa,GAAG,qBAAa,MAAG;YACjD,OAAO,EAAE,IAAI,CAAC,OAAO,IAAI,GAAG;YAC5B,KAAK,EAAE,IAAI,CAAC,KAAK,IAAI,CAAC;SACvB,CAAC,CAAC;QACH,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;QACvB,OAAO,IAAI,CAAC;IACd,CAAC;IACH,cAAC;AAAD,CAAC,AA9fD,IA8fC;AAKQ,0BAAO","sourcesContent":["/**\n * @packageDocumentation\n * @module harmony-account\n *\n */\n\nimport {\n  generatePrivateKey,\n  getAddressFromPrivateKey,\n  getPubkeyFromPrivateKey,\n  // toChecksumAddress,\n  encrypt,\n  decrypt,\n  EncryptOptions,\n  Keystore,\n  Signature,\n  getAddress,\n} from '@harmony-js/crypto';\n\nimport {\n  isPrivateKey,\n  add0xToString,\n  hexToNumber,\n  AddressSuffix,\n  ChainType,\n} from '@harmony-js/utils';\nimport { Transaction, RLPSign } from '@harmony-js/transaction';\nimport { StakingTransaction } from '@harmony-js/staking';\nimport { Messenger, RPCMethod } from '@harmony-js/network';\nimport { Shards } from './types';\nimport { defaultMessenger } from './utils';\n\nexport interface Balance {\n  balance?: string;\n  nonce?: number;\n  shardID?: number;\n}\n\nclass Account {\n  /**\n   * static method create account\n   *\n   * @example\n   * ```javascript\n   * const account = new Account();\n   * console.log(account);\n   * ```\n   */\n  static new(): Account {\n    const newAcc = new Account()._new();\n    return newAcc;\n  }\n  /**\n   * Static Method: add a private key to Account\n   * @param  {string} key - private Key\n   *\n   * @example\n   * ```javascript\n   * const account = new Account.add(key_1);\n   * console.log(account);\n   * ```\n   */\n  static add(key: string): Account {\n    const newAcc = new Account()._import(key);\n    return newAcc;\n  }\n\n  /**@hidden */\n  privateKey?: string;\n  /**@hidden */\n  publicKey?: string;\n  /**@hidden */\n  address?: string;\n  /**@hidden */\n  balance?: string = '0';\n  /**@hidden */\n  nonce?: number = 0;\n  /**@hidden */\n  shardID: number;\n  /**@hidden */\n  shards: Shards;\n  /**@hidden */\n  messenger: Messenger;\n  /**@hidden */\n  encrypted: boolean = false;\n\n  /**\n   * check sum address\n   *\n   * @example\n   * ```javascript\n   * console.log(account.checksumAddress);\n   * ```\n   */\n  get checksumAddress(): string {\n    return this.address ? getAddress(this.address).checksum : '';\n  }\n\n  /**\n   * Get bech32 Address\n   *\n   * @example\n   * ```javascript\n   * console.log(account.bech32Address);\n   * ```\n   */\n  get bech32Address(): string {\n    return this.address ? getAddress(this.address).bech32 : '';\n  }\n\n  /**\n   * get Bech32 TestNet Address\n   *\n   * @example\n   * ```javascript\n   * console.log(account.bech32TestNetAddress);\n   * ```\n   */\n  get bech32TestNetAddress(): string {\n    return this.address ? getAddress(this.address).bech32TestNet : '';\n  }\n\n  /**\n   * get Shards number with this Account\n   *\n   * @example\n   * ```javascript\n   * console.log(account.getShardsCount);\n   * ```\n   */\n  get getShardsCount(): number {\n    return this.shards.size;\n  }\n\n  /**\n   * Generate an account object\n   *\n   * @param key import an existing privateKey, or create a random one\n   * @param messenger you can setMessage later, or set message on `new`\n   *\n   * @example\n   * ```javascript\n   * // import the Account class\n   * const { Account } = require('@harmony-js/account');\n   *\n   * // Messenger is optional, by default, we have a defaultMessenger\n   * // If you like to change, you will import related package here.\n   * const { HttpProvider, Messenger } = require('@harmony-js/network');\n   * const { ChainType, ChainID } = require('@harmony-js/utils');\n   *\n   * // create a custom messenger\n   * const customMessenger = new Messenger(\n   *   new HttpProvider('http://localhost:9500'),\n   *   ChainType.Harmony, // if you are connected to Harmony's blockchain\n   *   ChainID.HmyLocal, // check if the chainId is correct\n   * )\n   *\n   * // setMessenger later\n   * const randomAccount = new Account()\n   * randomAccount.setMessenger(customMessenger)\n   *\n   * // or you can set messenger on `new`\n   * const randomAccountWithCustomMessenger = new Account(undefined, customMessenger)\n   *\n   * // NOTED: Key with or without `0x` are accepted, makes no different\n   * // NOTED: DO NOT import `mnemonic phrase` using `Account` class, use `Wallet` instead\n   * const myPrivateKey = '0xe19d05c5452598e24caad4a0d85a49146f7be089515c905ae6a19e8a578a6930'\n   * const myAccountWithMyPrivateKey = new Account(myPrivateKey)\n   * ```\n   */\n  constructor(key?: string, messenger: Messenger = defaultMessenger) {\n    this.messenger = messenger;\n    if (!key) {\n      this._new();\n    } else {\n      this._import(key);\n    }\n    this.shardID = this.messenger.currentShard || 0;\n    this.shards = new Map();\n    this.shards.set(this.shardID, {\n      address: `${this.bech32Address}${AddressSuffix}0`,\n      balance: this.balance || '0',\n      nonce: this.nonce || 0,\n    });\n  }\n\n  async toFile(password: string, options?: EncryptOptions): Promise<string> {\n    if (this.privateKey && isPrivateKey(this.privateKey)) {\n      const file = await encrypt(this.privateKey, password, options);\n      this.privateKey = file;\n      this.encrypted = true;\n      return file;\n    } else {\n      throw new Error('Encryption failed because PrivateKey is not correct');\n    }\n  }\n\n  async fromFile(keyStore: string, password: string): Promise<Account> {\n    try {\n      if (typeof password !== 'string') {\n        throw new Error('you must provide password');\n      }\n      const file: Keystore = JSON.parse(keyStore.toLowerCase());\n      const decyptedPrivateKey = await decrypt(file, password);\n      if (isPrivateKey(decyptedPrivateKey)) {\n        return this._import(decyptedPrivateKey);\n      } else {\n        throw new Error('decrypted failed');\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  /**\n   * Get the account balance\n   *\n   * @param blockNumber by default, it's `latest`\n   *\n   * @example\n   * ```javascript\n   * account.getBalance().then((value) => {\n   *   console.log(value);\n   * });\n   * ```\n   */\n  async getBalance(blockNumber: string = 'latest'): Promise<Balance> {\n    try {\n      if (this.messenger) {\n        const balance = await this.messenger.send(\n          RPCMethod.GetBalance,\n          [this.address, blockNumber],\n          this.messenger.chainPrefix,\n          this.messenger.currentShard || 0,\n        );\n\n        const nonce = await this.messenger.send(\n          RPCMethod.GetTransactionCount,\n          [this.address, blockNumber],\n          this.messenger.chainPrefix,\n          this.messenger.currentShard || 0,\n        );\n        if (balance.isError()) {\n          throw balance.error.message;\n        }\n        if (nonce.isError()) {\n          throw nonce.error.message;\n        }\n\n        this.balance = hexToNumber(balance.result);\n        this.nonce = Number.parseInt(hexToNumber(nonce.result), 10);\n        this.shardID = this.messenger.currentShard || 0;\n      } else {\n        throw new Error('No Messenger found');\n      }\n      return {\n        balance: this.balance,\n        nonce: this.nonce,\n        shardID: this.shardID,\n      };\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  /**\n   * @function updateShards\n   */\n  async updateBalances(blockNumber: string = 'latest'): Promise<void> {\n    // this.messenger.setShardingProviders();\n    const shardProviders = this.messenger.shardProviders;\n    if (shardProviders.size > 1) {\n      for (const [name, val] of shardProviders) {\n        const balanceObject = await this.getShardBalance(val.shardID, blockNumber);\n        await this.shards.set(name === val.shardID ? name : val.shardID, balanceObject);\n      }\n    } else {\n      const currentShard = await this.getShardBalance(\n        this.messenger.currentShard || 0,\n        blockNumber,\n      );\n      this.shards.set(this.messenger.currentShard || 0, currentShard);\n    }\n  }\n\n  /**\n   * @function signTransaction\n   */\n  async signTransaction(\n    transaction: Transaction,\n    updateNonce: boolean = true,\n    encodeMode: string = 'rlp',\n    blockNumber: string = 'latest',\n  ): Promise<Transaction> {\n    if (!this.privateKey || !isPrivateKey(this.privateKey)) {\n      throw new Error(`${this.privateKey} is not found or not correct`);\n    }\n\n    if (updateNonce) {\n      // await this.updateBalances(blockNumber);\n      const txShardID = transaction.txParams.shardID;\n      const shardBalanceObject = await this.getShardBalance(\n        typeof txShardID === 'string' ? Number.parseInt(txShardID, 10) : txShardID,\n        blockNumber,\n      );\n      if (shardBalanceObject !== undefined) {\n        const shardNonce = shardBalanceObject.nonce;\n        transaction.setParams({\n          ...transaction.txParams,\n          from:\n            this.messenger.chainPrefix === ChainType.Harmony\n              ? this.bech32Address\n              : this.checksumAddress || '0x',\n          nonce: shardNonce,\n        });\n      } else {\n        transaction.setParams({\n          ...transaction.txParams,\n          from:\n            this.messenger.chainPrefix === ChainType.Harmony\n              ? this.bech32Address\n              : this.checksumAddress || '0x',\n          nonce: 0,\n        });\n      }\n    }\n\n    if (encodeMode === 'rlp') {\n      const [signature, rawTransaction]: [Signature, string] = RLPSign(\n        transaction,\n        this.privateKey,\n      );\n      return transaction.map((obj: any) => {\n        return {\n          ...obj,\n          signature,\n          rawTransaction,\n          from:\n            this.messenger.chainPrefix === ChainType.Harmony\n              ? this.bech32Address\n              : this.checksumAddress || '0x',\n        };\n      });\n    } else {\n      // TODO: if we use other encode method, eg. protobuf, we should implement this\n      return transaction;\n    }\n  }\n\n  /**\n   * This function is still in development, coming soon!\n   *\n   * @param staking\n   * @param updateNonce\n   * @param encodeMode\n   * @param blockNumber\n   * @param shardID\n   */\n  async signStaking(\n    staking: StakingTransaction,\n    updateNonce: boolean = true,\n    encodeMode: string = 'rlp',\n    blockNumber: string = 'latest',\n    shardID: number = this.messenger.currentShard,\n  ): Promise<StakingTransaction> {\n    if (!this.privateKey || !isPrivateKey(this.privateKey)) {\n      throw new Error(`${this.privateKey} is not found or not correct`);\n    }\n\n    if (updateNonce) {\n      // await this.updateBalances(blockNumber);\n      const txShardID = shardID;\n      const shardBalanceObject = await this.getShardBalance(\n        typeof txShardID === 'string' ? Number.parseInt(txShardID, 10) : txShardID,\n        blockNumber,\n      );\n      if (shardBalanceObject !== undefined) {\n        const shardNonce = shardBalanceObject.nonce;\n\n        staking.setFromAddress(\n          this.messenger.chainPrefix === ChainType.Harmony\n            ? this.bech32Address\n            : this.checksumAddress || '0x',\n        );\n        staking.setNonce(shardNonce);\n      } else {\n        staking.setFromAddress(\n          this.messenger.chainPrefix === ChainType.Harmony\n            ? this.bech32Address\n            : this.checksumAddress || '0x',\n        );\n        staking.setNonce(0);\n      }\n    }\n\n    if (encodeMode === 'rlp') {\n      const [signature, rawTransaction]: [Signature, string] = staking.rlpSign(this.privateKey);\n      staking.setRawTransaction(rawTransaction);\n      staking.setSignature(signature);\n      staking.setFromAddress(\n        this.messenger.chainPrefix === ChainType.Harmony\n          ? this.bech32Address\n          : this.checksumAddress || '0x',\n      );\n\n      return staking;\n    } else {\n      // TODO: if we use other encode method, eg. protobuf, we should implement this\n      return staking;\n    }\n  }\n\n  /**\n   * @param messenger\n   *\n   * @example\n   * ```javascript\n   * // create a custom messenger\n   * const customMessenger = new Messenger(\n   *   new HttpProvider('http://localhost:9500'),\n   *   ChainType.Harmony, // if you are connected to Harmony's blockchain\n   *   ChainID.HmyLocal, // check if the chainId is correct\n   * )\n   *\n   * // to create an Account with random privateKey\n   * // and you can setMessenger later\n   * const randomAccount = new Account()\n   * randomAccount.setMessenger(customMessenger)\n   * ```\n   */\n  setMessenger(messenger: Messenger) {\n    this.messenger = messenger;\n  }\n\n  /**\n   * Get account address from shard ID\n   * @param shardID\n   *\n   * @example\n   * ```javascript\n   * console.log(account.getAddressFromShardID(0));\n   *\n   * > one103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7-0\n   * ```\n   */\n  getAddressFromShardID(shardID: number) {\n    const shardObject = this.shards.get(shardID);\n    if (shardObject) {\n      return shardObject.address;\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * Get all shards' addresses from the account\n   *\n   * @example\n   * ```javascript\n   * console.log(account.getAddresses());\n   * ```\n   */\n  getAddresses(): string[] {\n    const addressArray: string[] = [];\n    for (const [name, val] of this.shards) {\n      const index: number = typeof name === 'string' ? Number.parseInt(name, 10) : name;\n      addressArray[index] = val.address;\n    }\n    return addressArray;\n  }\n\n  /**\n   * Get the specific shard's balance\n   *\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   * @param blockNumber by default, it's `latest`\n   *\n   * @example\n   * ```\n   * account.getShardBalance().then((value) => {\n   *   console.log(value);\n   * });\n   * ```\n   */\n  async getShardBalance(shardID: number, blockNumber: string = 'latest') {\n    const balance = await this.messenger.send(\n      RPCMethod.GetBalance,\n      [this.address, blockNumber],\n      this.messenger.chainPrefix,\n      shardID,\n    );\n\n    const nonce = await this.messenger.send(\n      RPCMethod.GetTransactionCount,\n      [this.address, blockNumber],\n      this.messenger.chainPrefix,\n      shardID,\n    );\n\n    if (balance.isError()) {\n      throw balance.error.message;\n    }\n    if (nonce.isError()) {\n      throw nonce.error.message;\n    }\n    return {\n      address: `${this.bech32Address}${AddressSuffix}${shardID}`,\n      balance: hexToNumber(balance.result),\n      nonce: Number.parseInt(hexToNumber(nonce.result), 10),\n    };\n  }\n\n  /**\n   * @function _new private method create Account\n   * @return {Account} Account instance\n   * @ignore\n   */\n  private _new(): Account {\n    const prv = generatePrivateKey();\n    if (!isPrivateKey(prv)) {\n      throw new Error('key gen failed');\n    }\n    return this._import(prv);\n  }\n\n  /**\n   * @function _import private method import a private Key\n   * @param  {string} key - private key\n   * @return {Account} Account instance\n   * @ignore\n   */\n  private _import(key: string): Account {\n    if (!isPrivateKey(key)) {\n      throw new Error(`${key} is not PrivateKey`);\n    }\n    this.privateKey = add0xToString(key);\n    this.publicKey = getPubkeyFromPrivateKey(this.privateKey);\n    this.address = getAddressFromPrivateKey(this.privateKey);\n    this.shardID = this.messenger.currentShard || 0;\n    this.shards = new Map();\n    this.shards.set(this.shardID, {\n      address: `${this.bech32Address}${AddressSuffix}0`,\n      balance: this.balance || '0',\n      nonce: this.nonce || 0,\n    });\n    this.encrypted = false;\n    return this;\n  }\n}\n\n/**\n * This comment _supports_ [Markdown](https://marked.js.org/)\n */\nexport { Account };\n"]}},"error":null,"hash":"6dc62cb28bb6347ba02f51301f84546c","cacheData":{"env":{}}}