{"id":"../node_modules/@harmony-js/contract/dist/methods/method.js","dependencies":[{"name":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/contract/dist/methods/method.js.map","includedInParent":true,"mtime":499162500000},{"name":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/contract/src/methods/method.ts","includedInParent":true,"mtime":499162500000},{"name":"/home/rachit/Projects/demo/web Math Wallet/package.json","includedInParent":true,"mtime":1605273881149},{"name":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/contract/package.json","includedInParent":true,"mtime":1605275414276},{"name":"tslib","loc":{"line":8,"column":22},"parent":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/contract/dist/methods/method.js","resolved":"/home/rachit/Projects/demo/node_modules/tslib/tslib.es6.js"},{"name":"@harmony-js/transaction","loc":{"line":9,"column":28},"parent":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/contract/dist/methods/method.js","resolved":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/transaction/dist/index.js"},{"name":"@harmony-js/network","loc":{"line":10,"column":24},"parent":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/contract/dist/methods/method.js","resolved":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/network/dist/index.js"},{"name":"@harmony-js/utils","loc":{"line":11,"column":22},"parent":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/contract/dist/methods/method.js","resolved":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/utils/dist/index.js"},{"name":"@harmony-js/crypto","loc":{"line":12,"column":23},"parent":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/contract/dist/methods/method.js","resolved":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/crypto/dist/index.js"},{"name":"../utils/encoder","loc":{"line":13,"column":24},"parent":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/contract/dist/methods/method.js","resolved":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/contract/dist/utils/encoder.js"},{"name":"../utils/status","loc":{"line":14,"column":23},"parent":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/contract/dist/methods/method.js","resolved":"/home/rachit/Projects/demo/web Math Wallet/node_modules/@harmony-js/contract/dist/utils/status.js"}],"generated":{"js":"\"use strict\";\n/**\n * @packageDocumentation\n * @module harmony-contract\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContractMethod = void 0;\nvar tslib_1 = require(\"tslib\");\nvar transaction_1 = require(\"@harmony-js/transaction\");\nvar network_1 = require(\"@harmony-js/network\");\nvar utils_1 = require(\"@harmony-js/utils\");\nvar crypto_1 = require(\"@harmony-js/crypto\");\nvar encoder_1 = require(\"../utils/encoder\");\nvar status_1 = require(\"../utils/status\");\n// todo: have to judge if it is contractConstructor\nvar ContractMethod = /** @class */ (function () {\n    function ContractMethod(methodKey, params, abiItem, contract) {\n        this.methodKey = methodKey;\n        this.contract = contract;\n        this.wallet = contract.wallet;\n        this.params = params;\n        this.abiItem = abiItem;\n        this.transaction = this.createTransaction();\n        this.callPayload = undefined;\n        this.callResponse = undefined;\n    }\n    ContractMethod.prototype.send = function (params) {\n        var _this = this;\n        try {\n            var gasLimit_1;\n            var signTxs_1 = function () {\n                _this.transaction = _this.transaction.map(function (tx) {\n                    return tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, tx), params), { gasLimit: gasLimit_1 });\n                });\n                var waitConfirm = params && params.waitConfirm === false ? false : true;\n                var updateNonce = params && params.nonce !== undefined ? false : true;\n                _this.signTransaction(updateNonce)\n                    .then(function (signed) {\n                    _this.sendTransaction(signed).then(function (sent) {\n                        var _a = tslib_1.__read(sent, 2), txn = _a[0], id = _a[1];\n                        _this.transaction = txn;\n                        _this.contract.transaction = _this.transaction;\n                        if (_this.transaction.isRejected()) {\n                            _this.transaction.emitter.reject(id); // in this case, id is error message\n                        }\n                        else if (waitConfirm) {\n                            _this.confirm(id).then(function () {\n                                _this.transaction.emitter.resolve(_this.contract);\n                            });\n                        }\n                        else {\n                            _this.transaction.emitter.resolve(_this.contract);\n                        }\n                    });\n                })\n                    .catch(function (error) {\n                    _this.transaction.emitter.reject(error);\n                });\n            };\n            // tslint:disable-next-line: prefer-conditional-expression\n            if (params !== undefined) {\n                gasLimit_1 = params.gas || params.gasLimit;\n            }\n            if (gasLimit_1 === undefined) {\n                this.estimateGas().then(function (gas) {\n                    gasLimit_1 = utils_1.hexToBN(gas);\n                    signTxs_1();\n                });\n            }\n            else {\n                signTxs_1();\n            }\n            return this.transaction.emitter;\n        }\n        catch (error) {\n            throw error;\n        }\n    };\n    ContractMethod.prototype.call = function (options, blockNumber) {\n        if (blockNumber === void 0) { blockNumber = 'latest'; }\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var shardID, nonce_1, gasLimit_2, from_1, keys, txPayload, sendPayload, keys_1, keys_1_1, key, result, error_1;\n            var e_1, _a;\n            return tslib_1.__generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _b.trys.push([0, 2, , 3]);\n                        options = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, this.contract.options), { data: this.transaction.txParams.data }), options);\n                        shardID = options !== undefined && options.shardID !== undefined\n                            ? options.shardID\n                            : this.contract.shardID;\n                        nonce_1 = '0x0';\n                        gasLimit_2 = '21000000';\n                        if (options !== undefined && (options.gas || options.gasLimit)) {\n                            gasLimit_2 = options.gas || options.gasLimit;\n                        }\n                        from_1 = this.wallet.signer\n                            ? this.wallet.signer.address\n                            : '0x0000000000000000000000000000000000000000';\n                        if (options && options.from) {\n                            from_1 = options.from;\n                        }\n                        this.transaction = this.transaction.map(function (tx) {\n                            return tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, tx), options), { from: from_1 || tx.from, gasPrice: options ? options.gasPrice : tx.gasPrice, gasLimit: gasLimit_2 || tx.gasLimit, nonce: Number.parseInt(utils_1.hexToNumber(nonce_1), 10) });\n                        });\n                        keys = Object.keys(this.transaction.txPayload);\n                        txPayload = this.transaction.txPayload;\n                        sendPayload = {};\n                        try {\n                            for (keys_1 = tslib_1.__values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {\n                                key = keys_1_1.value;\n                                // tslint:disable-next-line: no-unused-expression\n                                if (txPayload[key] !== '0x') {\n                                    sendPayload[key] = txPayload[key];\n                                }\n                            }\n                        }\n                        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                        finally {\n                            try {\n                                if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);\n                            }\n                            finally { if (e_1) throw e_1.error; }\n                        }\n                        // tslint:disable-line\n                        return [4 /*yield*/, this.wallet.messenger.send(network_1.RPCMethod.Call, [sendPayload, blockNumber], \n                            // tslint:disable-line\n                            this.wallet.messenger.chainPrefix, shardID)];\n                    case 1:\n                        result = \n                        // tslint:disable-line\n                        _b.sent();\n                        this.callPayload = sendPayload;\n                        this.callResponse = result;\n                        if (result.isError()) {\n                            throw result.message;\n                        }\n                        else if (result.isResult()) {\n                            if (result.result === null) {\n                                return [2 /*return*/, this.afterCall(undefined)];\n                            }\n                            else {\n                                return [2 /*return*/, this.afterCall(result.result)];\n                            }\n                        }\n                        return [3 /*break*/, 3];\n                    case 2:\n                        error_1 = _b.sent();\n                        throw error_1;\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    ContractMethod.prototype.estimateGas = function (params) {\n        if (params === void 0) { params = {}; }\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var result, _a, error_2;\n            return tslib_1.__generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _b.trys.push([0, 2, , 3]);\n                        if (params.from === undefined && this.contract.options.from !== undefined) {\n                            params.from = this.contract.options.from;\n                        }\n                        if (params.to === undefined && this.transaction.txParams.to !== undefined) {\n                            params.to = this.transaction.txParams.to;\n                        }\n                        if (params.data === undefined) {\n                            params.data = this.transaction.txParams.data;\n                        }\n                        if (params.gasPrice === undefined && this.contract.options.gasPrice !== undefined) {\n                            params.gasPrice = this.contract.options.gasPrice;\n                        }\n                        if (this.methodKey === 'contractConstructor') {\n                            delete params.to;\n                        }\n                        _a = network_1.getResultForData;\n                        // tslint:disable-line\n                        return [4 /*yield*/, this.wallet.messenger.send(network_1.RPCMethod.EstimateGas, [params])];\n                    case 1:\n                        result = _a.apply(void 0, [\n                            // tslint:disable-line\n                            _b.sent()]);\n                        if (result.responseType === 'error') {\n                            throw result.message;\n                        }\n                        else if (result.responseType === 'raw') {\n                            throw new Error('Get estimateGas fail');\n                        }\n                        else {\n                            return [2 /*return*/, result];\n                        }\n                        return [3 /*break*/, 3];\n                    case 2:\n                        error_2 = _b.sent();\n                        throw error_2;\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    ContractMethod.prototype.encodeABI = function () {\n        return encoder_1.methodEncoder(this.contract.abiCoder, this.abiItem, this.contract.data);\n    };\n    ContractMethod.prototype.debug = function () {\n        return {\n            callResponse: this.callResponse,\n            callPayload: this.callPayload,\n        };\n    };\n    ContractMethod.prototype.signTransaction = function (updateNonce) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var signed, _a, error_3;\n            return tslib_1.__generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _b.trys.push([0, 5, , 6]);\n                        signed = void 0;\n                        if (!this.wallet.signer) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this.wallet.signTransaction(this.transaction, this.wallet.signer, undefined, updateNonce, 'rlp', 'latest')];\n                    case 1:\n                        _a = _b.sent();\n                        return [3 /*break*/, 4];\n                    case 2: return [4 /*yield*/, this.wallet.signTransaction(this.transaction, updateNonce, 'rlp', 'latest')];\n                    case 3:\n                        _a = _b.sent();\n                        _b.label = 4;\n                    case 4:\n                        signed = _a;\n                        if (this.methodKey === 'contractConstructor') {\n                            this.contract.address = transaction_1.TransactionFactory.getContractAddress(signed);\n                        }\n                        this.contract.setStatus(status_1.ContractStatus.SIGNED);\n                        return [2 /*return*/, signed];\n                    case 5:\n                        error_3 = _b.sent();\n                        throw error_3;\n                    case 6: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    ContractMethod.prototype.sendTransaction = function (signed) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var result, error_4;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, signed.sendTransaction()];\n                    case 1:\n                        result = _a.sent();\n                        this.contract.setStatus(status_1.ContractStatus.SENT);\n                        return [2 /*return*/, result];\n                    case 2:\n                        error_4 = _a.sent();\n                        throw error_4;\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    ContractMethod.prototype.confirm = function (id) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var result, error_5;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, this.transaction.confirm(id, 20, 1000, this.transaction ? this.transaction.txParams.shardID : this.contract.shardID)];\n                    case 1:\n                        result = _a.sent();\n                        if (result.receipt && result.txStatus === transaction_1.TxStatus.CONFIRMED) {\n                            if (this.methodKey === 'contractConstructor') {\n                                this.contract.setStatus(status_1.ContractStatus.DEPLOYED);\n                            }\n                            else {\n                                this.contract.setStatus(status_1.ContractStatus.CALLED);\n                            }\n                        }\n                        else {\n                            this.contract.setStatus(status_1.ContractStatus.REJECTED);\n                        }\n                        return [3 /*break*/, 3];\n                    case 2:\n                        error_5 = _a.sent();\n                        throw error_5;\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    ContractMethod.prototype.createTransaction = function () {\n        if (this.wallet.messenger) {\n            if (this.methodKey === 'contractConstructor') {\n                // tslint:disable-next-line: no-string-literal\n                this.contract.data = this.params[0]['data'] || '0x';\n                this.abiItem.contractMethodParameters =\n                    // tslint:disable-next-line: no-string-literal\n                    this.params[0]['arguments'] || [];\n            }\n            else {\n                this.abiItem.contractMethodParameters = this.params || [];\n            }\n            var txObject = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, this.contract.options), this.params[0]), { to: this.methodKey === 'contractConstructor'\n                    ? '0x'\n                    : crypto_1.getAddress(this.contract.address).checksum, data: this.encodeABI() });\n            // tslint:disable-line\n            var result = new transaction_1.TransactionFactory(this.wallet.messenger).newTx(txObject);\n            return result;\n        }\n        else {\n            throw new Error('Messenger is not found');\n        }\n    };\n    ContractMethod.prototype.afterCall = function (response) {\n        // length of `0x${methodSig}` is 2+4*2=10\n        if (response.length % 32 === 10 && response.startsWith(this.contract.errorFuncSig)) {\n            var errmsg = this.contract.abiCoder.decodeParameters([{ type: 'string' }], '0x' + response.slice(10));\n            throw { revert: errmsg[0] };\n        }\n        if (this.methodKey === 'contractConstructor') {\n            return response;\n        }\n        var outputs = this.abiItem.getOutputs();\n        if (outputs.length === 0) {\n            // if outputs is empty, we can't know the call is revert or not\n            return response;\n        }\n        if (!response || response === '0x') {\n            // if outputs isn't empty, treat it as revert\n            throw { revert: response };\n        }\n        if (outputs.length > 1) {\n            return this.contract.abiCoder.decodeParameters(outputs, response);\n        }\n        return this.contract.abiCoder.decodeParameter(outputs[0], response);\n        // return outputs;\n    };\n    return ContractMethod;\n}());\nexports.ContractMethod = ContractMethod;\n"},"sourceMaps":{"js":{"version":3,"file":"method.js","sourceRoot":"","sources":["../../src/methods/method.ts"],"names":[],"mappings":";AAAA;;;GAGG;;;;AAGH,uDAAoF;AACpF,+CAA2E;AAC3E,2CAAyD;AACzD,6CAAgD;AAGhD,4CAAiD;AACjD,0CAAiD;AAEjD,mDAAmD;AAEnD;IAUE,wBAAY,SAAiB,EAAE,MAAW,EAAE,OAAqB,EAAE,QAAkB;QACnF,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;QAC3B,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC;QAC9B,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;QAC5C,IAAI,CAAC,WAAW,GAAG,SAAS,CAAC;QAC7B,IAAI,CAAC,YAAY,GAAG,SAAS,CAAC;IAChC,CAAC;IACD,6BAAI,GAAJ,UAAK,MAAW;QAAhB,iBAgDC;QA/CC,IAAI;YACF,IAAI,UAAa,CAAC;YAClB,IAAM,SAAO,GAAG;gBACd,KAAI,CAAC,WAAW,GAAG,KAAI,CAAC,WAAW,CAAC,GAAG,CAAC,UAAC,EAAO;oBAC9C,8DAAY,EAAE,GAAK,MAAM,KAAE,QAAQ,YAAA,IAAG;gBACxC,CAAC,CAAC,CAAC;gBAEH,IAAM,WAAW,GAAY,MAAM,IAAI,MAAM,CAAC,WAAW,KAAK,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC;gBACnF,IAAM,WAAW,GAAY,MAAM,IAAI,MAAM,CAAC,KAAK,KAAK,SAAS,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC;gBACjF,KAAI,CAAC,eAAe,CAAC,WAAW,CAAC;qBAC9B,IAAI,CAAC,UAAC,MAAM;oBACX,KAAI,CAAC,eAAe,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,UAAC,IAAI;wBAC/B,IAAA,KAAA,eAAY,IAAI,IAAA,EAAf,GAAG,QAAA,EAAE,EAAE,QAAQ,CAAC;wBACvB,KAAI,CAAC,WAAW,GAAG,GAAG,CAAC;wBACvB,KAAI,CAAC,QAAQ,CAAC,WAAW,GAAG,KAAI,CAAC,WAAW,CAAC;wBAC7C,IAAI,KAAI,CAAC,WAAW,CAAC,UAAU,EAAE,EAAE;4BACjC,KAAI,CAAC,WAAW,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC,oCAAoC;yBAC1E;6BAAM,IAAI,WAAW,EAAE;4BACtB,KAAI,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC;gCACpB,KAAI,CAAC,WAAW,CAAC,OAAO,CAAC,OAAO,CAAC,KAAI,CAAC,QAAQ,CAAC,CAAC;4BAClD,CAAC,CAAC,CAAC;yBACJ;6BAAM;4BACL,KAAI,CAAC,WAAW,CAAC,OAAO,CAAC,OAAO,CAAC,KAAI,CAAC,QAAQ,CAAC,CAAC;yBACjD;oBACH,CAAC,CAAC,CAAC;gBACL,CAAC,CAAC;qBACD,KAAK,CAAC,UAAC,KAAK;oBACX,KAAI,CAAC,WAAW,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;gBACzC,CAAC,CAAC,CAAC;YACP,CAAC,CAAC;YAEF,0DAA0D;YAC1D,IAAI,MAAM,KAAK,SAAS,EAAE;gBACxB,UAAQ,GAAG,MAAM,CAAC,GAAG,IAAI,MAAM,CAAC,QAAQ,CAAC;aAC1C;YACD,IAAI,UAAQ,KAAK,SAAS,EAAE;gBAC1B,IAAI,CAAC,WAAW,EAAE,CAAC,IAAI,CAAC,UAAC,GAAG;oBAC1B,UAAQ,GAAG,eAAO,CAAC,GAAG,CAAC,CAAC;oBACxB,SAAO,EAAE,CAAC;gBACZ,CAAC,CAAC,CAAC;aACJ;iBAAM;gBACL,SAAO,EAAE,CAAC;aACX;YACD,OAAO,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC;SACjC;QAAC,OAAO,KAAK,EAAE;YACd,MAAM,KAAK,CAAC;SACb;IACH,CAAC;IACK,6BAAI,GAAV,UAAW,OAAY,EAAE,WAA2B;QAA3B,4BAAA,EAAA,sBAA2B;;;;;;;;wBAEhD,OAAO,0DAAQ,IAAI,CAAC,QAAQ,CAAC,OAAO,KAAE,IAAI,EAAE,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,IAAI,KAAK,OAAO,CAAE,CAAC;wBACnF,OAAO,GACX,OAAO,KAAK,SAAS,IAAI,OAAO,CAAC,OAAO,KAAK,SAAS;4BACpD,CAAC,CAAC,OAAO,CAAC,OAAO;4BACjB,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC;wBACtB,UAAQ,KAAK,CAAC;wBAEhB,aAAgB,UAAU,CAAC;wBAC/B,IAAI,OAAO,KAAK,SAAS,IAAI,CAAC,OAAO,CAAC,GAAG,IAAI,OAAO,CAAC,QAAQ,CAAC,EAAE;4BAC9D,UAAQ,GAAG,OAAO,CAAC,GAAG,IAAI,OAAO,CAAC,QAAQ,CAAC;yBAC5C;wBACG,SAAe,IAAI,CAAC,MAAM,CAAC,MAAM;4BACnC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,OAAO;4BAC5B,CAAC,CAAC,4CAA4C,CAAC;wBACjD,IAAI,OAAO,IAAI,OAAO,CAAC,IAAI,EAAE;4BAC3B,MAAI,GAAG,OAAO,CAAC,IAAI,CAAC;yBACrB;wBACD,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,UAAC,EAAO;4BAC9C,8DACK,EAAE,GACF,OAAO,KACV,IAAI,EAAE,MAAI,IAAI,EAAE,CAAC,IAAI,EACrB,QAAQ,EAAE,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,QAAQ,EAClD,QAAQ,EAAE,UAAQ,IAAI,EAAE,CAAC,QAAQ,EACjC,KAAK,EAAE,MAAM,CAAC,QAAQ,CAAC,mBAAW,CAAC,OAAK,CAAC,EAAE,EAAE,CAAC,IAC9C;wBACJ,CAAC,CAAC,CAAC;wBACG,IAAI,GAAa,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC;wBAyBzD,SAAS,GAAc,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC;wBAClD,WAAW,GAAgB,EAAE,CAAC;;4BAEpC,KAAkB,SAAA,iBAAA,IAAI,CAAA,sEAAE;gCAAb,GAAG;gCACZ,iDAAiD;gCACjD,IAAI,SAAS,CAAC,GAAG,CAAC,KAAK,IAAI,EAAE;oCAC3B,WAAW,CAAC,GAAG,CAAC,GAAG,SAAS,CAAC,GAAG,CAAC,CAAC;iCACnC;6BACF;;;;;;;;;wBAGC,sBAAsB;wBACtB,qBAAe,IAAI,CAAC,MAAO,CAAC,SAAS,CAAC,IAAI,CACxC,mBAAS,CAAC,IAAI,EACd,CAAC,WAAW,EAAE,WAAW,CAAC;4BAC1B,sBAAsB;4BACb,IAAI,CAAC,MAAO,CAAC,SAAS,CAAC,WAAW,EAC3C,OAAO,CACR,EAAA;;wBARG,MAAM;wBACV,sBAAsB;wBACtB,SAMC;wBACH,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;wBAC/B,IAAI,CAAC,YAAY,GAAG,MAAM,CAAC;wBAC3B,IAAI,MAAM,CAAC,OAAO,EAAE,EAAE;4BACpB,MAAM,MAAM,CAAC,OAAO,CAAC;yBACtB;6BAAM,IAAI,MAAM,CAAC,QAAQ,EAAE,EAAE;4BAC5B,IAAI,MAAM,CAAC,MAAM,KAAK,IAAI,EAAE;gCAC1B,sBAAO,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,EAAC;6BAClC;iCAAM;gCACL,sBAAO,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,MAAM,CAAC,EAAC;6BACtC;yBACF;;;;wBAED,MAAM,OAAK,CAAC;;;;;KAEf;IAEK,oCAAW,GAAjB,UACE,MAOM;QAPN,uBAAA,EAAA,WAOM;;;;;;;wBAGJ,IAAI,MAAM,CAAC,IAAI,KAAK,SAAS,IAAI,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,IAAI,KAAK,SAAS,EAAE;4BACzE,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC;yBAC1C;wBACD,IAAI,MAAM,CAAC,EAAE,KAAK,SAAS,IAAI,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,EAAE,KAAK,SAAS,EAAE;4BACzE,MAAM,CAAC,EAAE,GAAG,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,EAAE,CAAC;yBAC1C;wBACD,IAAI,MAAM,CAAC,IAAI,KAAK,SAAS,EAAE;4BAC7B,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,IAAI,CAAC;yBAC9C;wBACD,IAAI,MAAM,CAAC,QAAQ,KAAK,SAAS,IAAI,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,QAAQ,KAAK,SAAS,EAAE;4BACjF,MAAM,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,QAAQ,CAAC;yBAClD;wBAED,IAAI,IAAI,CAAC,SAAS,KAAK,qBAAqB,EAAE;4BAC5C,OAAO,MAAM,CAAC,EAAE,CAAC;yBAClB;wBACc,KAAA,0BAAgB,CAAA;wBAC7B,sBAAsB;wBACtB,qBAAe,IAAI,CAAC,MAAO,CAAC,SAAS,CAAC,IAAI,CAAC,mBAAS,CAAC,WAAW,EAAE,CAAC,MAAM,CAAC,CAAC,EAAA;;wBAFvE,MAAM,GAAG;4BACb,sBAAsB;4BACtB,SAA2E,EAC5E;wBAED,IAAI,MAAM,CAAC,YAAY,KAAK,OAAO,EAAE;4BACnC,MAAM,MAAM,CAAC,OAAO,CAAC;yBACtB;6BAAM,IAAI,MAAM,CAAC,YAAY,KAAK,KAAK,EAAE;4BACxC,MAAM,IAAI,KAAK,CAAC,sBAAsB,CAAC,CAAC;yBACzC;6BAAM;4BACL,sBAAO,MAAM,EAAC;yBACf;;;;wBAED,MAAM,OAAK,CAAC;;;;;KAEf;IAED,kCAAS,GAAT;QACE,OAAO,uBAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;IACjF,CAAC;IAEM,8BAAK,GAAZ;QACE,OAAO;YACL,YAAY,EAAE,IAAI,CAAC,YAAY;YAC/B,WAAW,EAAE,IAAI,CAAC,WAAW;SAC9B,CAAC;IACJ,CAAC;IAEe,wCAAe,GAA/B,UAAgC,WAAoB;;;;;;;wBAE5C,MAAM,SAAA,CAAC;6BACF,IAAI,CAAC,MAAM,CAAC,MAAM,EAAlB,wBAAkB;wBACvB,qBAAM,IAAI,CAAC,MAAM,CAAC,eAAe,CAC/B,IAAI,CAAC,WAAW,EAChB,IAAI,CAAC,MAAM,CAAC,MAAM,EAClB,SAAS,EACT,WAAW,EACX,KAAK,EACL,QAAQ,CACT,EAAA;;wBAPD,KAAA,SAOC,CAAA;;4BACD,qBAAM,IAAI,CAAC,MAAM,CAAC,eAAe,CAC/B,IAAI,CAAC,WAAW,EAChB,WAAW,EACX,KAAK,EACL,QAAQ,CACT,EAAA;;wBALD,KAAA,SAKC,CAAA;;;wBAdL,MAAM,KAcD,CAAC;wBACN,IAAI,IAAI,CAAC,SAAS,KAAK,qBAAqB,EAAE;4BAC5C,IAAI,CAAC,QAAQ,CAAC,OAAO,GAAG,gCAAkB,CAAC,kBAAkB,CAAC,MAAM,CAAC,CAAC;yBACvE;wBACD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,uBAAc,CAAC,MAAM,CAAC,CAAC;wBAC/C,sBAAO,MAAM,EAAC;;;wBAEd,MAAM,OAAK,CAAC;;;;;KAEf;IACe,wCAAe,GAA/B,UAAgC,MAAmB;;;;;;;wBAEhC,qBAAM,MAAM,CAAC,eAAe,EAAE,EAAA;;wBAAvC,MAAM,GAAG,SAA8B;wBAC7C,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,uBAAc,CAAC,IAAI,CAAC,CAAC;wBAC7C,sBAAO,MAAM,EAAC;;;wBAEd,MAAM,OAAK,CAAC;;;;;KAEf;IACe,gCAAO,GAAvB,UAAwB,EAAU;;;;;;;wBAEf,qBAAM,IAAI,CAAC,WAAW,CAAC,OAAO,CAC3C,EAAE,EACF,EAAE,EACF,IAAI,EACJ,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,OAAO,CAC7E,EAAA;;wBALK,MAAM,GAAG,SAKd;wBAED,IAAI,MAAM,CAAC,OAAO,IAAI,MAAM,CAAC,QAAQ,KAAK,sBAAQ,CAAC,SAAS,EAAE;4BAC5D,IAAI,IAAI,CAAC,SAAS,KAAK,qBAAqB,EAAE;gCAC5C,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,uBAAc,CAAC,QAAQ,CAAC,CAAC;6BAClD;iCAAM;gCACL,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,uBAAc,CAAC,MAAM,CAAC,CAAC;6BAChD;yBACF;6BAAM;4BACL,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,uBAAc,CAAC,QAAQ,CAAC,CAAC;yBAClD;;;;wBAED,MAAM,OAAK,CAAC;;;;;KAEf;IAES,0CAAiB,GAA3B;QACE,IAAI,IAAI,CAAC,MAAM,CAAC,SAAS,EAAE;YACzB,IAAI,IAAI,CAAC,SAAS,KAAK,qBAAqB,EAAE;gBAC5C,8CAA8C;gBAC9C,IAAI,CAAC,QAAQ,CAAC,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,IAAI,CAAC;gBAEpD,IAAI,CAAC,OAAO,CAAC,wBAAwB;oBACnC,8CAA8C;oBAC9C,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,IAAI,EAAE,CAAC;aACrC;iBAAM;gBACL,IAAI,CAAC,OAAO,CAAC,wBAAwB,GAAG,IAAI,CAAC,MAAM,IAAI,EAAE,CAAC;aAC3D;YACD,IAAM,QAAQ,0DACT,IAAI,CAAC,QAAQ,CAAC,OAAO,GACrB,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,KACjB,EAAE,EACA,IAAI,CAAC,SAAS,KAAK,qBAAqB;oBACtC,CAAC,CAAC,IAAI;oBACN,CAAC,CAAC,mBAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,QAAQ,EAChD,IAAI,EAAE,IAAI,CAAC,SAAS,EAAE,GACvB,CAAC;YAEF,sBAAsB;YACtB,IAAM,MAAM,GAAG,IAAI,gCAAkB,CAAU,IAAI,CAAC,MAAO,CAAC,SAAS,CAAC,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;YAEvF,OAAO,MAAM,CAAC;SACf;aAAM;YACL,MAAM,IAAI,KAAK,CAAC,wBAAwB,CAAC,CAAC;SAC3C;IACH,CAAC;IAES,kCAAS,GAAnB,UAAoB,QAAa;QAC/B,yCAAyC;QACzC,IAAI,QAAQ,CAAC,MAAM,GAAG,EAAE,KAAK,EAAE,IAAI,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,EAAE;YAClF,IAAM,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,gBAAgB,CACpD,CAAC,EAAE,IAAI,EAAE,QAAQ,EAAE,CAAC,EACpB,IAAI,GAAG,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAC1B,CAAC;YACF,MAAM,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC;SAC7B;QAED,IAAI,IAAI,CAAC,SAAS,KAAK,qBAAqB,EAAE;YAC5C,OAAO,QAAQ,CAAC;SACjB;QAED,IAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,UAAU,EAAE,CAAC;QAC1C,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;YACxB,+DAA+D;YAC/D,OAAO,QAAQ,CAAC;SACjB;QACD,IAAI,CAAC,QAAQ,IAAI,QAAQ,KAAK,IAAI,EAAE;YAClC,6CAA6C;YAC7C,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE,CAAC;SAC5B;QACD,IAAI,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE;YACtB,OAAO,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,gBAAgB,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;SACnE;QACD,OAAO,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,eAAe,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC;QACpE,kBAAkB;IACpB,CAAC;IACH,qBAAC;AAAD,CAAC,AA5UD,IA4UC;AA5UY,wCAAc","sourcesContent":["/**\n * @packageDocumentation\n * @module harmony-contract\n */\n\nimport { Wallet } from '@harmony-js/account';\nimport { TransactionFactory, Transaction, TxStatus } from '@harmony-js/transaction';\nimport { RPCMethod, getResultForData, Emitter } from '@harmony-js/network';\nimport { hexToNumber, hexToBN } from '@harmony-js/utils';\nimport { getAddress } from '@harmony-js/crypto';\nimport { AbiItemModel } from '../models/types';\nimport { Contract } from '../contract';\nimport { methodEncoder } from '../utils/encoder';\nimport { ContractStatus } from '../utils/status';\n\n// todo: have to judge if it is contractConstructor\n\nexport class ContractMethod {\n  contract: Contract;\n  params: any;\n  methodKey: string;\n  wallet: Wallet | any;\n  abiItem: AbiItemModel;\n  callResponse?: any;\n  callPayload?: any;\n\n  protected transaction: Transaction;\n  constructor(methodKey: string, params: any, abiItem: AbiItemModel, contract: Contract) {\n    this.methodKey = methodKey;\n    this.contract = contract;\n    this.wallet = contract.wallet;\n    this.params = params;\n    this.abiItem = abiItem;\n    this.transaction = this.createTransaction();\n    this.callPayload = undefined;\n    this.callResponse = undefined;\n  }\n  send(params: any): Emitter {\n    try {\n      let gasLimit: any;\n      const signTxs = () => {\n        this.transaction = this.transaction.map((tx: any) => {\n          return { ...tx, ...params, gasLimit };\n        });\n\n        const waitConfirm: boolean = params && params.waitConfirm === false ? false : true;\n        const updateNonce: boolean = params && params.nonce !== undefined ? false : true;\n        this.signTransaction(updateNonce)\n          .then((signed) => {\n            this.sendTransaction(signed).then((sent) => {\n              const [txn, id] = sent;\n              this.transaction = txn;\n              this.contract.transaction = this.transaction;\n              if (this.transaction.isRejected()) {\n                this.transaction.emitter.reject(id); // in this case, id is error message\n              } else if (waitConfirm) {\n                this.confirm(id).then(() => {\n                  this.transaction.emitter.resolve(this.contract);\n                });\n              } else {\n                this.transaction.emitter.resolve(this.contract);\n              }\n            });\n          })\n          .catch((error) => {\n            this.transaction.emitter.reject(error);\n          });\n      };\n\n      // tslint:disable-next-line: prefer-conditional-expression\n      if (params !== undefined) {\n        gasLimit = params.gas || params.gasLimit;\n      }\n      if (gasLimit === undefined) {\n        this.estimateGas().then((gas) => {\n          gasLimit = hexToBN(gas);\n          signTxs();\n        });\n      } else {\n        signTxs();\n      }\n      return this.transaction.emitter;\n    } catch (error) {\n      throw error;\n    }\n  }\n  async call(options: any, blockNumber: any = 'latest') {\n    try {\n      options = { ...this.contract.options, data: this.transaction.txParams.data, ...options };\n      const shardID =\n        options !== undefined && options.shardID !== undefined\n          ? options.shardID\n          : this.contract.shardID;\n      const nonce = '0x0';\n\n      let gasLimit: any = '21000000';\n      if (options !== undefined && (options.gas || options.gasLimit)) {\n        gasLimit = options.gas || options.gasLimit;\n      }\n      let from: string = this.wallet.signer\n        ? this.wallet.signer.address\n        : '0x0000000000000000000000000000000000000000';\n      if (options && options.from) {\n        from = options.from;\n      }\n      this.transaction = this.transaction.map((tx: any) => {\n        return {\n          ...tx,\n          ...options,\n          from: from || tx.from,\n          gasPrice: options ? options.gasPrice : tx.gasPrice,\n          gasLimit: gasLimit || tx.gasLimit,\n          nonce: Number.parseInt(hexToNumber(nonce), 10),\n        };\n      });\n      const keys: string[] = Object.keys(this.transaction.txPayload);\n\n      interface TxPayload {\n        [key: string]: any;\n        from?: string;\n        to?: string;\n        shardID?: string;\n        gas?: string;\n        gasPrice?: string;\n        value?: string;\n        data?: string;\n        nonce?: string;\n      }\n      interface SendPayload {\n        [key: string]: any;\n        from?: string;\n        to?: string;\n        shardID?: string;\n        gas?: string;\n        gasPrice?: string;\n        value?: string;\n        data?: string;\n        nonce?: string;\n      }\n\n      const txPayload: TxPayload = this.transaction.txPayload;\n      const sendPayload: SendPayload = {};\n\n      for (const key of keys) {\n        // tslint:disable-next-line: no-unused-expression\n        if (txPayload[key] !== '0x') {\n          sendPayload[key] = txPayload[key];\n        }\n      }\n\n      const result =\n        // tslint:disable-line\n        await (<Wallet>this.wallet).messenger.send(\n          RPCMethod.Call,\n          [sendPayload, blockNumber],\n          // tslint:disable-line\n          (<Wallet>this.wallet).messenger.chainPrefix,\n          shardID,\n        );\n      this.callPayload = sendPayload;\n      this.callResponse = result;\n      if (result.isError()) {\n        throw result.message;\n      } else if (result.isResult()) {\n        if (result.result === null) {\n          return this.afterCall(undefined);\n        } else {\n          return this.afterCall(result.result);\n        }\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async estimateGas(\n    params: {\n      from?: string;\n      to?: string;\n      gas?: string;\n      gasPrice?: string;\n      value?: string;\n      data?: string;\n    } = {},\n  ) {\n    try {\n      if (params.from === undefined && this.contract.options.from !== undefined) {\n        params.from = this.contract.options.from;\n      }\n      if (params.to === undefined && this.transaction.txParams.to !== undefined) {\n        params.to = this.transaction.txParams.to;\n      }\n      if (params.data === undefined) {\n        params.data = this.transaction.txParams.data;\n      }\n      if (params.gasPrice === undefined && this.contract.options.gasPrice !== undefined) {\n        params.gasPrice = this.contract.options.gasPrice;\n      }\n\n      if (this.methodKey === 'contractConstructor') {\n        delete params.to;\n      }\n      const result = getResultForData(\n        // tslint:disable-line\n        await (<Wallet>this.wallet).messenger.send(RPCMethod.EstimateGas, [params]),\n      );\n\n      if (result.responseType === 'error') {\n        throw result.message;\n      } else if (result.responseType === 'raw') {\n        throw new Error('Get estimateGas fail');\n      } else {\n        return result;\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  encodeABI() {\n    return methodEncoder(this.contract.abiCoder, this.abiItem, this.contract.data);\n  }\n\n  public debug() {\n    return {\n      callResponse: this.callResponse,\n      callPayload: this.callPayload,\n    };\n  }\n\n  protected async signTransaction(updateNonce: boolean) {\n    try {\n      let signed;\n      signed = this.wallet.signer\n        ? await this.wallet.signTransaction(\n            this.transaction,\n            this.wallet.signer,\n            undefined,\n            updateNonce,\n            'rlp',\n            'latest', // 'pending',\n          )\n        : await this.wallet.signTransaction(\n            this.transaction,\n            updateNonce,\n            'rlp',\n            'latest', // 'pending',\n          );\n      if (this.methodKey === 'contractConstructor') {\n        this.contract.address = TransactionFactory.getContractAddress(signed);\n      }\n      this.contract.setStatus(ContractStatus.SIGNED);\n      return signed;\n    } catch (error) {\n      throw error;\n    }\n  }\n  protected async sendTransaction(signed: Transaction) {\n    try {\n      const result = await signed.sendTransaction();\n      this.contract.setStatus(ContractStatus.SENT);\n      return result;\n    } catch (error) {\n      throw error;\n    }\n  }\n  protected async confirm(id: string) {\n    try {\n      const result = await this.transaction.confirm(\n        id,\n        20,\n        1000,\n        this.transaction ? this.transaction.txParams.shardID : this.contract.shardID,\n      );\n\n      if (result.receipt && result.txStatus === TxStatus.CONFIRMED) {\n        if (this.methodKey === 'contractConstructor') {\n          this.contract.setStatus(ContractStatus.DEPLOYED);\n        } else {\n          this.contract.setStatus(ContractStatus.CALLED);\n        }\n      } else {\n        this.contract.setStatus(ContractStatus.REJECTED);\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  protected createTransaction() {\n    if (this.wallet.messenger) {\n      if (this.methodKey === 'contractConstructor') {\n        // tslint:disable-next-line: no-string-literal\n        this.contract.data = this.params[0]['data'] || '0x';\n\n        this.abiItem.contractMethodParameters =\n          // tslint:disable-next-line: no-string-literal\n          this.params[0]['arguments'] || [];\n      } else {\n        this.abiItem.contractMethodParameters = this.params || [];\n      }\n      const txObject = {\n        ...this.contract.options,\n        ...this.params[0],\n        to:\n          this.methodKey === 'contractConstructor'\n            ? '0x'\n            : getAddress(this.contract.address).checksum,\n        data: this.encodeABI(),\n      };\n\n      // tslint:disable-line\n      const result = new TransactionFactory((<Wallet>this.wallet).messenger).newTx(txObject);\n\n      return result;\n    } else {\n      throw new Error('Messenger is not found');\n    }\n  }\n\n  protected afterCall(response: any) {\n    // length of `0x${methodSig}` is 2+4*2=10\n    if (response.length % 32 === 10 && response.startsWith(this.contract.errorFuncSig)) {\n      const errmsg = this.contract.abiCoder.decodeParameters(\n        [{ type: 'string' }],\n        '0x' + response.slice(10),\n      );\n      throw { revert: errmsg[0] };\n    }\n\n    if (this.methodKey === 'contractConstructor') {\n      return response;\n    }\n\n    const outputs = this.abiItem.getOutputs();\n    if (outputs.length === 0) {\n      // if outputs is empty, we can't know the call is revert or not\n      return response;\n    }\n    if (!response || response === '0x') {\n      // if outputs isn't empty, treat it as revert\n      throw { revert: response };\n    }\n    if (outputs.length > 1) {\n      return this.contract.abiCoder.decodeParameters(outputs, response);\n    }\n    return this.contract.abiCoder.decodeParameter(outputs[0], response);\n    // return outputs;\n  }\n}\n"]}},"error":null,"hash":"66a786a8ee79fe5da7281f16dca39ac0","cacheData":{"env":{}}}